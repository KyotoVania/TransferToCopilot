// --- FILE: Scripts/BannerMovement.cs ---
using UnityEngine;
using System.Collections;

public class BannerMovement : MonoBehaviour
{
    // --- FEATURE FUSIONNÉE: Garde la référence à l'unité attachée ---
    private Unit attachedUnit;

    [Header("Movement Settings")]
    [Tooltip("Hauteur finale de la bannière au-dessus de son point de référence.")]
    [SerializeField] private float finalHeightOffset = 4f;

    [Header("Rhythmic Movement")]
    [SerializeField] private bool enableRhythmicMovement = true;
    [SerializeField] private float swayAmount = 0.1f;
    [SerializeField] private float swayTransitionSpeed = 2.0f;

    [Header("Sway Type")]
    [SerializeField] private bool useRotationSway = true;
    [SerializeField] private float rotationSwayAmount = 10f;
    [SerializeField] private float bannerHeight = 2.0f;
    [SerializeField] [Range(0f, 1f)] private float pivotOffsetRatio = 0f;

    [Header("Camera Facing")]
    [SerializeField] private bool shouldFaceCamera = true;

    // --- État Interne (fusionné) ---
    private Camera mainCamera;
    private Vector3 baseWorldPosition;
    private Quaternion baseWorldRotation;
    private float currentSwayTarget;
    private float currentSwayActual;
    private int swayDirection = 1;
    private bool isInitialized = false;

    // --- Propriété publique pour l'accès externe ---
    public float FinalHeightOffset => finalHeightOffset;

    #region Public Setup Methods

    /// <summary>
    /// FEATURE DU FICHIER 1: Attache la bannière à une unité en mouvement.
    /// </summary>
    public void AttachToUnit(Unit unit)
    {
        if (unit == null)
        {
            Destroy(gameObject);
            return;
        }

        // Si on était attaché à une autre unité, on se désabonne d'abord
        if (attachedUnit != null)
        {
            attachedUnit.OnUnitDestroyed -= HandleAttachedUnitDeath;
        }

        this.attachedUnit = unit;
        transform.SetParent(unit.transform, false); // 'false' pour réinitialiser la position/rotation locale

        // S'abonner à la mort de la nouvelle unité
        unit.OnUnitDestroyed += HandleAttachedUnitDeath;

        // Initialiser la position et la rotation
        InitializeTransform(unit.transform.position + new Vector3(0, finalHeightOffset, 0));
    }

    /// <summary>
    /// FEATURE DU FICHIER 2: Place la bannière à une position fixe dans le monde.
    /// </summary>
    public void PlaceAtWorldPosition(Vector3 worldPosition)
    {
        // Si on était attaché à une unité, on se détache et on se désabonne
        if (attachedUnit != null)
        {
            attachedUnit.OnUnitDestroyed -= HandleAttachedUnitDeath;
            attachedUnit = null;
            transform.SetParent(null);
        }

        InitializeTransform(worldPosition);
    }

    // Alias pour la compatibilité avec le BannerController existant
    public void UpdatePosition(Vector3 newBaseWorldPosition)
    {
        PlaceAtWorldPosition(newBaseWorldPosition);
    }

    #endregion

    #region Unity Lifecycle & Callbacks

    void Awake()
    {
        mainCamera = Camera.main;
        if (mainCamera == null)
        {
            Debug.LogError("[BannerMovement] Caméra principale non trouvée !", this);
            enabled = false;
        }
    }

    void OnEnable()
    {
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat += OnBeat;
        }

        // Réinitialiser l'état du balancement
        currentSwayTarget = 0;
        currentSwayActual = 0;
        swayDirection = 1;
    }

    void OnDisable()
    {
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= OnBeat;
        }
        // Sécurité pour se désabonner si l'objet est désactivé
        if (attachedUnit != null)
        {
            attachedUnit.OnUnitDestroyed -= HandleAttachedUnitDeath;
        }
    }

    // LateUpdate est meilleur pour les suivis de position pour éviter les saccades
    void LateUpdate()
    {
        // FEATURE FUSIONNÉE: Met à jour la position de base si attaché à une unité
        if (attachedUnit != null)
        {
            // La position de base pour le balancement est mise à jour en permanence
            baseWorldPosition = attachedUnit.transform.position + new Vector3(0, finalHeightOffset, 0);
        }

        if (!isInitialized) return;

        if (enableRhythmicMovement)
        {
            ApplySwaying();
        }
    }

    private void OnBeat(float beatDuration)
    {
        if (!enableRhythmicMovement || !isInitialized) return;

        swayDirection *= -1; // Inverser la direction du balancement
        currentSwayTarget = useRotationSway ? (rotationSwayAmount * swayDirection) : (swayAmount * swayDirection);
    }

    private void HandleAttachedUnitDeath()
    {
        if (this == null) return;
        transform.SetParent(null);
        // On peut ajouter un petit effet avant de détruire
        Destroy(gameObject, 0.2f);
    }

    #endregion

    #region Private Logic

    private void InitializeTransform(Vector3 initialPosition)
    {
        baseWorldPosition = initialPosition;
        transform.position = initialPosition;

        if (shouldFaceCamera)
        {
            FaceCamera();
        }
        baseWorldRotation = transform.rotation;
        isInitialized = true;
    }

    /// <summary>
    /// FEATURE DU FICHIER 2: Applique le balancement avancé basé sur un pivot.
    /// </summary>
    private void ApplySwaying()
    {
        currentSwayActual = Mathf.Lerp(currentSwayActual, currentSwayTarget, Time.deltaTime * swayTransitionSpeed);

        if (shouldFaceCamera && attachedUnit == null) // Pour les bannières statiques, on rafraîchit l'orientation
        {
            FaceCamera();
            baseWorldRotation = transform.rotation;
        }

        if (useRotationSway)
        {
            // Calcul du pivot pour une rotation naturelle
            float pivotYWorldOffset = bannerHeight * (pivotOffsetRatio - 0.5f);
            Vector3 pivotPoint = baseWorldPosition + transform.up * pivotYWorldOffset;

            // Appliquer la rotation de base (vers la caméra) et la rotation de balancement
            transform.rotation = baseWorldRotation * Quaternion.AngleAxis(currentSwayActual, transform.right);

            // Ajuster la position pour simuler la rotation autour du pivot
            transform.position = baseWorldPosition;
            transform.RotateAround(pivotPoint, transform.right, currentSwayActual);
        }
        else
        {
            // Balancement simple en position
            Vector3 swayOffsetVector = transform.right * currentSwayActual;
            transform.position = baseWorldPosition + swayOffsetVector;
        }
    }

    private void FaceCamera()
    {
        if (mainCamera != null)
        {
            transform.rotation = Quaternion.LookRotation(transform.position - mainCamera.transform.position);
        }
    }

    #endregion

    #region Editor Gizmos

    /// <summary>
    /// FEATURE DU FICHIER 2: Dessine des aides visuelles dans l'éditeur.
    /// </summary>
    void OnDrawGizmosSelected()
    {
        if (!Application.isPlaying && !isInitialized) return;

        Vector3 positionToDrawFrom = Application.isPlaying ? baseWorldPosition : transform.position;
        Quaternion rotationToDrawFrom = Application.isPlaying ? baseWorldRotation : transform.rotation;

        Gizmos.color = Color.blue;
        Gizmos.DrawSphere(positionToDrawFrom, 0.1f);
        Gizmos.DrawLine(positionToDrawFrom, transform.position);

        if (useRotationSway)
        {
            float pivotYOffset = bannerHeight * (pivotOffsetRatio - 0.5f);
            Vector3 pivotPointPreview = positionToDrawFrom + transform.up * pivotYOffset;
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(pivotPointPreview, 0.1f);
            Gizmos.DrawLine(positionToDrawFrom, pivotPointPreview);

            Vector3 topOfBannerRelative = Vector3.up * bannerHeight * (1f - pivotOffsetRatio);
            Gizmos.color = Color.green;
            Gizmos.DrawLine(pivotPointPreview, pivotPointPreview + (rotationToDrawFrom * Quaternion.AngleAxis(-rotationSwayAmount, Vector3.right) * topOfBannerRelative));
            Gizmos.DrawLine(pivotPointPreview, pivotPointPreview + (rotationToDrawFrom * Quaternion.AngleAxis(rotationSwayAmount, Vector3.right) * topOfBannerRelative));
        }
        else
        {
            Gizmos.color = Color.green;
            Vector3 leftExtent = positionToDrawFrom - (transform.right * swayAmount);
            Vector3 rightExtent = positionToDrawFrom + (transform.right * swayAmount);
            Gizmos.DrawLine(leftExtent, rightExtent);
        }
    }

    #endregion
}

// --- FILE: Scripts/ConditionalColliderActivator.cs ---
using UnityEngine;

/// <summary>
/// Un composant qui implémente IScenarioTriggerable pour activer ou désactiver un Collider.
/// Parfait pour être utilisé avec l'action TriggerGameObject du LevelScenarioManager.
/// </summary>
public class ConditionalColliderActivator : MonoBehaviour, IScenarioTriggerable
{
    [Header("Settings")]
    [Tooltip("Le Collider à activer ou désactiver.")]
    [SerializeField] private Collider targetCollider;

    [Tooltip("L'état dans lequel le Collider doit être mis lorsque l'action est déclenchée.")]
    [SerializeField] private bool shouldBeEnabled = true;

    private void Awake()
    {
        if (targetCollider == null)
        {
            // Essayez de trouver le collider sur le même GameObject si non assigné.
            targetCollider = GetComponent<Collider>();
            if (targetCollider == null)
            {
                Debug.LogError($"[ConditionalColliderActivator] sur {gameObject.name}: Aucun Collider n'est assigné et aucun n'a été trouvé sur cet objet.", this);
            }
        }
    }

    /// <summary>
    /// Exécute l'action de changement d'état du collider.
    /// </summary>
    public void TriggerAction()
    {
        if (targetCollider != null)
        {
            targetCollider.enabled = shouldBeEnabled;
            Debug.Log($"[ConditionalColliderActivator] sur {gameObject.name}: Collider mis à l'état 'enabled = {shouldBeEnabled}'.", this);
        }
        else
        {
            Debug.LogWarning($"[ConditionalColliderActivator] sur {gameObject.name}: Impossible d'exécuter l'action car targetCollider est null.", this);
        }
    }
}

// --- FILE: Scripts/ConditionalRiser.cs ---
using UnityEngine;
using System.Collections;

public class ConditionalRiser : MonoBehaviour, IScenarioTriggerable
{
    [Header("Configuration de Position et Animation")]
    [Tooltip("De combien l'objet doit descendre initialement par rapport à sa position Y de départ.")]
    public float teleportDownAmount = 10f;
    [Tooltip("Hauteur supplémentaire au-dessus de la position Y d'origine pendant l'animation de montée.")]
    public float riseExtraHeight = 2f;

    [Tooltip("Nombre de battements musicaux pour l'animation de montée vers le pic.")]
    public int riseToPeakBeats = 4;
    [Tooltip("Nombre de battements musicaux pour l'animation de descente vers la position d'origine.")]
    public int settleToOriginalBeats = 3;

    [Header("Configuration du Wobble (Oscillation après chaque pas)")]
    [Tooltip("Amplitude verticale du wobble.")]
    public float wobbleAmount = 0.1f;
    [Tooltip("Durée totale en secondes d'un cycle de wobble (doit être < durée d'un battement).")]
    public float wobbleDurationSeconds = 0.25f;
    [Tooltip("Courbe pour l'effet de wobble.")]
    public AnimationCurve wobbleCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

    [Header("Durées de Secours")]
    [Tooltip("Durée de secours en secondes pour la montée si MusicManager n'est pas disponible.")]
    public float fallbackRiseDurationSeconds = 1.5f;
    [Tooltip("Durée de secours en secondes pour la descente si MusicManager n'est pas disponible.")]
    public float fallbackSettleDurationSeconds = 1.0f;

    private Vector3 _originalWorldPosition;
    private bool _isAnimating = false;
    private Coroutine _animationCoroutine;
    private bool _beatReceivedForStep;
    private System.Action<float> _onBeatAction;

    void Awake()
    {
        // On sauvegarde la position finale désirée et on se place en position basse.
        _originalWorldPosition = transform.position;
        Vector3 lowerPosition = _originalWorldPosition - new Vector3(0, teleportDownAmount, 0);
        transform.position = lowerPosition;
        Debug.Log($"[{gameObject.name}] Initialized. Original Y: {_originalWorldPosition.y}. Teleported down to Y: {transform.position.y}");

        _onBeatAction = (_) => _beatReceivedForStep = true;
    }

    /// <summary>
    /// C'est la méthode que le LevelScenarioManager va appeler.
    /// </summary>
    public void TriggerAction()
    {
        if (!_isAnimating)
        {
            _isAnimating = true;
            if (_animationCoroutine != null) StopCoroutine(_animationCoroutine);
            _animationCoroutine = StartCoroutine(AnimateRiseAndSettleByBeats());
        }
        else
        {
            Debug.LogWarning($"[{gameObject.name}] A déjà une animation en cours, appel de TriggerAction ignoré.");
        }
    }

    // La coroutine d'animation reste la même que dans votre script original.
    // Je la replace ici pour que le script soit complet.
    IEnumerator AnimateRiseAndSettleByBeats()
    {
        Debug.Log($"[{gameObject.name}] Starting BEAT-BASED rise and settle animation.");
        _isAnimating = true;

        Vector3 startRisePosition = transform.position;
        Vector3 peakTargetPosition = new Vector3(_originalWorldPosition.x, _originalWorldPosition.y + riseExtraHeight, _originalWorldPosition.z);
        Vector3 finalSettlePosition = _originalWorldPosition;

        float musicBeatDuration = fallbackRiseDurationSeconds / Mathf.Max(1, riseToPeakBeats);

        if (MusicManager.Instance != null)
        {
            float tempBeatDur = MusicManager.Instance.GetBeatDuration();
            if (tempBeatDur > 0.01f) musicBeatDuration = tempBeatDur;
            else Debug.LogWarning($"[{gameObject.name}] MusicManager returned invalid beat duration ({tempBeatDur}). Using fallback logic.");
        } else {
            Debug.LogWarning($"[{gameObject.name}] MusicManager.Instance not found. Using fallback timing logic.");
        }

        if (riseToPeakBeats > 0)
        {
            float totalRiseHeight = peakTargetPosition.y - startRisePosition.y;
            float risePerBeat = totalRiseHeight / riseToPeakBeats;
            Vector3 currentStepTargetPos = startRisePosition;

            Debug.Log($"[{gameObject.name}] Rise Phase: Target Y={peakTargetPosition.y}, Steps={riseToPeakBeats}, RisePerBeatY={risePerBeat}");
            if(MusicManager.Instance != null) MusicManager.Instance.OnBeat += _onBeatAction;

            for (int i = 0; i < riseToPeakBeats; i++)
            {
                _beatReceivedForStep = false;
                if (MusicManager.Instance != null) {
                    yield return new WaitUntil(() => _beatReceivedForStep);
                } else {
                    yield return new WaitForSeconds(musicBeatDuration);
                }
                if (!_isAnimating) yield break;

                currentStepTargetPos.y += risePerBeat;
                if (i == riseToPeakBeats - 1) currentStepTargetPos.y = peakTargetPosition.y;

                transform.position = currentStepTargetPos;
                Debug.Log($"[{gameObject.name}] Rise Step {i + 1}/{riseToPeakBeats}: Moved to Y={transform.position.y}");

                if (wobbleAmount > 0.001f && wobbleDurationSeconds > 0.01f)
                {
                    yield return StartCoroutine(PerformWobble(currentStepTargetPos));
                }
            }
            if(MusicManager.Instance != null) MusicManager.Instance.OnBeat -= _onBeatAction;
        }
        transform.position = peakTargetPosition;
        Debug.Log($"[{gameObject.name}] Reached peak position Y: {transform.position.y}");

        if (settleToOriginalBeats > 0)
        {
            float totalSettleHeight = peakTargetPosition.y - finalSettlePosition.y;
            float settlePerBeat = totalSettleHeight / settleToOriginalBeats;
            Vector3 currentStepTargetPos = peakTargetPosition;

            Debug.Log($"[{gameObject.name}] Settle Phase: Target Y={finalSettlePosition.y}, Steps={settleToOriginalBeats}, SettlePerBeatY={settlePerBeat}");
            if(MusicManager.Instance != null) MusicManager.Instance.OnBeat += _onBeatAction;

            for (int i = 0; i < settleToOriginalBeats; i++)
            {
                 _beatReceivedForStep = false;
                if (MusicManager.Instance != null) {
                    yield return new WaitUntil(() => _beatReceivedForStep);
                } else {
                    yield return new WaitForSeconds(musicBeatDuration);
                }
                if (!_isAnimating) yield break;

                currentStepTargetPos.y -= settlePerBeat;
                 if (i == settleToOriginalBeats - 1) currentStepTargetPos.y = finalSettlePosition.y;

                transform.position = currentStepTargetPos;
                Debug.Log($"[{gameObject.name}] Settle Step {i + 1}/{settleToOriginalBeats}: Moved to Y={transform.position.y}");

                if (wobbleAmount > 0.001f && wobbleDurationSeconds > 0.01f)
                {
                    yield return StartCoroutine(PerformWobble(currentStepTargetPos));
                }
            }
            if(MusicManager.Instance != null) MusicManager.Instance.OnBeat -= _onBeatAction;
        }
        transform.position = finalSettlePosition;
        Debug.Log($"[{gameObject.name}] Settled at original position Y: {transform.position.y}. Beat-based animation complete.");

        _isAnimating = false;
        _animationCoroutine = null;
    }

    private IEnumerator PerformWobble(Vector3 basePositionForWobble)
    {
        if (wobbleDurationSeconds <= 0.01f || wobbleAmount <= 0.001f) yield break;

        float elapsedTime = 0f;
        float peakTime = wobbleDurationSeconds / 2f;

        while (elapsedTime < wobbleDurationSeconds)
        {
            float yOffset;
            if (elapsedTime < peakTime)
            {
                yOffset = wobbleCurve.Evaluate(elapsedTime / peakTime) * wobbleAmount;
            }
            else
            {
                yOffset = wobbleCurve.Evaluate(1f - ((elapsedTime - peakTime) / (wobbleDurationSeconds - peakTime))) * wobbleAmount;
            }

            transform.position = new Vector3(basePositionForWobble.x, basePositionForWobble.y + yOffset, basePositionForWobble.z);

            elapsedTime += Time.deltaTime;
            yield return null;
        }
        transform.position = basePositionForWobble;
    }

    void OnDestroy()
    {
        if (_animationCoroutine != null) StopCoroutine(_animationCoroutine);
        if (MusicManager.Instance != null && _onBeatAction != null)
        {
            MusicManager.Instance.OnBeat -= _onBeatAction;
        }
    }
}

// --- FILE: Scripts/CoverageTest.cs ---
using UnityEngine;

public class SimpleMath
{
    // Méthode simple qui ajoute deux nombres
    public int Add(int a, int b)
    {
        return a + b;
    }

    // Méthode simple qui multiplie deux nombres
    public int Multiply(int a, int b)
    {
        return a * b;
    }
}

// --- FILE: Scripts/DetectionSystem.cs ---
using UnityEngine;

public static class DetectionSystem
{
    public static Transform FindClosestTarget(Vector3 origin, string tag, float range, LayerMask layer)
    {
        Collider[] hits = Physics.OverlapSphere(origin, range, layer);
        Transform closest = null;
        float closestDistance = Mathf.Infinity;

        foreach (Collider hit in hits)
        {
            if (!hit.CompareTag(tag)) continue;

            float distance = Vector3.Distance(origin, hit.transform.position);
            if (distance < closestDistance)
            {
                closestDistance = distance;
                closest = hit.transform;
            }
        }
        return closest;
    }
}


// --- FILE: Scripts/MusicReactiveTile.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Sirenix.OdinInspector;
using Game.Observers; 
using ScriptableObjects;


public class MusicReactiveTile : Tile, IComboObserver
{
    #region Profile & State Reactivity
    [Title("Reaction Profile")]
    [SerializeField]
    [Required("A TileReactionProfile_SO must be assigned for this tile to react.")]
    private TileReactionProfile_SO reactionProfile;

    [Title("Rhythm Interaction")]
    [Tooltip("Si coché, cette tuile ne réagira PAS aux événements rythmiques.")]
    [SerializeField]
    public bool disableRhythmReactions = false;

    [Title("Music State Reactivity")]
    [SerializeField] private bool enableMusicStateReactions = true;
    [ShowIf("enableMusicStateReactions")]
    [SerializeField] private float explorationIntensityFactor = 1.0f;
    [ShowIf("enableMusicStateReactions")]
    [SerializeField] private float combatIntensityFactor = 1.2f;
    [ShowIf("enableMusicStateReactions")]
    [SerializeField] private float bossIntensityFactor = 1.4f;
    #endregion

    #region Instance Specific Settings
    [Title("Instance Specific Water Sequence")]
    [ShowIf("IsWaterTile")]
    [SerializeField, Tooltip("Sequence number for this specific water tile (0 to Total-1).")]
    private int waterSequenceNumber = 0;

    [ShowIf("IsWaterTile")]
    [SerializeField, Tooltip("Total number of unique steps in this water body's animation sequence.")]
    [MinValue(1)]
    private int waterSequenceTotal = 3;
    #endregion

    private string currentMusicStateKey = "Exploration";

    #region Private Variables
    private Coroutine currentAnimation;
    private bool isAnimating = false;
    private float currentMovementDuration;
    private bool isReactiveStateInitialized = false;
    private List<int> activeWaveSequences = new List<int>();
    private int beatCounterForWaterWaves = 0;
    private TMPro.TextMeshPro sequenceNumberText;
    private float currentDynamicReactionProbability;
    private int lastComboThresholdReached = 0;

    // NOUVEAU: Position de base pour les animations, capturée au Start en mode Play.
    private Vector3 basePositionForAnimation;
    #endregion

    #region Initialization Methods
    protected override void Start()
    {
        base.Start(); // Tile.Start() est maintenant plus simple

        // Capturer la position actuelle comme base pour les animations de CETTE session de jeu.
        // Cela se produit APRÈS que la tuile soit potentiellement attachée à un parent et positionnée.
        basePositionForAnimation = transform.position;
        // Debug.Log($"[{this.name}/MusicReactiveTile.Start] basePositionForAnimation capturée: {basePositionForAnimation}");

        if (reactionProfile == null)
        {
            disableRhythmReactions = true; // Sécurité
        }

        ValidateProfileAssignment();
        if (reactionProfile != null)
        {
             currentDynamicReactionProbability = reactionProfile.reactionProbability;
        }


        if (!disableRhythmReactions && reactionProfile != null)
        {
            if (MusicManager.Instance != null)
            {
                MusicManager.Instance.OnBeat += HandleBeat;
                MusicManager.Instance.OnMusicStateChanged += HandleMusicStateChange;
            }
            if (tileType == TileType.Ground && reactionProfile.reactToCombo && ComboController.Instance != null)
            {
                ComboController.Instance.AddObserver(this);
            }
        }

        if (tileType == TileType.Water)
        {
            waterSequenceNumber = Mathf.Clamp(waterSequenceNumber, 0, Mathf.Max(0, waterSequenceTotal - 1));
            CreateSequenceNumberText();
            if(reactionProfile != null) beatCounterForWaterWaves = reactionProfile.waterBeatsBetweenWaves;
        }

        // Appliquer l'état visuel initial (avec offset si Ground) UNIQUEMENT en mode Play.
        // En mode éditeur, InitializeReactiveVisualState ne modifiera plus la position.
        if (Application.isPlaying)
        {
            InitializeReactiveVisualState();
        }
        else
        {
            // En mode éditeur, on peut appeler d'autres logiques d'init visuelle qui ne touchent pas à la position.
            // Par exemple, mise à jour de matériel si nécessaire.
        }

        isReactiveStateInitialized = true;
    }

    private void ValidateProfileAssignment() // Inchangé
    {
        if (reactionProfile == null) return;
        if (reactionProfile.applicableTileType == TileReactionProfile_SO.ProfileApplicability.Generic) return;
        bool mismatch = false;
        switch (this.tileType)
        {
            case TileType.Ground: if (reactionProfile.applicableTileType != TileReactionProfile_SO.ProfileApplicability.Ground) mismatch = true; break;
            case TileType.Water: if (reactionProfile.applicableTileType != TileReactionProfile_SO.ProfileApplicability.Water) mismatch = true; break;
            case TileType.Mountain: if (reactionProfile.applicableTileType != TileReactionProfile_SO.ProfileApplicability.Mountain) mismatch = true; break;
        }
        if (mismatch) Debug.LogWarning($"[{this.name}] Mismatch: TileType '{this.tileType}', Profile for '{reactionProfile.applicableTileType}'.", this);
    }

    // MODIFIÉ: Ne change la position qu'en mode Play
    public void InitializeReactiveVisualState()
    {
        if (Application.isPlaying) // N'appliquer la logique de positionnement initial qu'en mode Play
        {
            if (disableRhythmReactions || reactionProfile == null)
            {
                transform.position = basePositionForAnimation; // Utiliser la base capturée au Start
            }
            else if (tileType == TileType.Ground)
            {
                // Appliquer l'offset aléatoire UNIQUEMENT en mode Play
                float initialOffset = Random.Range(reactionProfile.downMin, reactionProfile.upMax);
                transform.position = basePositionForAnimation + Vector3.up * initialOffset;
            }
            else // Water, Mountain
            {
                transform.position = basePositionForAnimation; // Utiliser la base capturée au Start
            }
        }
        // Si !Application.isPlaying (appel potentiel depuis OnValidate), cette méthode
        // ne modifiera PLUS transform.position. La tuile conservera sa position de scène.

        // Arrêter toute animation en cours et réinitialiser l'état d'animation (ceci est sûr dans les deux modes)
        if (currentAnimation != null)
        {
            StopCoroutine(currentAnimation);
            currentAnimation = null;
        }
        isAnimating = false;
    }
    // ... (CreateSequenceNumberText reste inchangé) ...
    #endregion

    #region Combo Observer Implementation // Inchangé
    public void OnComboUpdated(int newCombo)
    {
        if (disableRhythmReactions || reactionProfile == null || tileType != TileType.Ground || !reactionProfile.reactToCombo) return;
        int thresholdsReached = reactionProfile.comboThreshold > 0 ? newCombo / reactionProfile.comboThreshold : 0;
        if (thresholdsReached > lastComboThresholdReached)
        {
            lastComboThresholdReached = thresholdsReached;
            float boostPercentage = Mathf.Min(reactionProfile.comboReactionBoostPercentage * thresholdsReached, reactionProfile.maxReactionBoostPercentage);
            currentDynamicReactionProbability = Mathf.Clamp01(reactionProfile.reactionProbability * (1f + (boostPercentage / 100f)));
        }
    }

    public void OnComboReset()
    {
        if (disableRhythmReactions || reactionProfile == null || tileType == TileType.Ground || !reactionProfile.reactToCombo) return;
        currentDynamicReactionProbability = reactionProfile.reactionProbability;
        lastComboThresholdReached = 0;
    }
    #endregion

    #region Beat Handling // Inchangé, mais les animations utiliseront basePositionForAnimation
    private void HandleBeat(float beatDuration)
    {
        if (disableRhythmReactions)
        {
            if (isAnimating) { if (currentAnimation != null) StopCoroutine(currentAnimation); transform.position = basePositionForAnimation; isAnimating = false; }
            return;
        }
        if (!isReactiveStateInitialized) InitializeReactiveVisualState();
        if (reactionProfile == null) return; // isBasePositionCaptured n'est plus pertinent ici

        switch (tileType)
        {
            case TileType.Water: HandleWaterTileBeat(beatDuration); break;
            case TileType.Ground: HandleGroundTileBeat(beatDuration); break;
            case TileType.Mountain: HandleMountainTileBeat(beatDuration); break;
        }
    }
    // ... (HandleWaterTileBeat, HandleGroundTileBeat, HandleMountainTileBeat restent structurellement les mêmes mais les animations internes changeront) ...
     private void HandleWaterTileBeat(float beatDuration) // Structure inchangée
    {
        if (reactionProfile == null) return;
        beatCounterForWaterWaves++;
        if (beatCounterForWaterWaves >= reactionProfile.waterBeatsBetweenWaves)
        {
            beatCounterForWaterWaves = 0;
            activeWaveSequences.Add(0);
        }
        for (int i = activeWaveSequences.Count - 1; i >= 0; i--)
        {
            activeWaveSequences[i]++;
            if (activeWaveSequences[i] > this.waterSequenceTotal) { activeWaveSequences.RemoveAt(i); continue; }
            if (activeWaveSequences[i] - 1 == this.waterSequenceNumber)
            {
                if (!reactionProfile.alwaysReact && Random.value > currentDynamicReactionProbability) continue;
                if (currentAnimation != null) StopCoroutine(currentAnimation);
                currentAnimation = StartCoroutine(AnimateWaterTile(beatDuration, reactionProfile));
                break;
            }
        }
    }

    private void HandleGroundTileBeat(float beatDuration) // Structure inchangée
    {
        if (reactionProfile == null) return;
        if (!reactionProfile.alwaysReact && Random.value > currentDynamicReactionProbability) return;
        if (currentAnimation != null) { StopCoroutine(currentAnimation); isAnimating = false; }
        RandomizeMovementDuration(beatDuration, reactionProfile);
        float currentOffset = transform.position.y - basePositionForAnimation.y; // Changé pour utiliser basePositionForAnimation
        float intensity = GetCurrentIntensityFactor();
        float targetOffset = (currentOffset >= 0f) ?
            Random.Range(reactionProfile.downMin * intensity, reactionProfile.downMax * intensity) :
            Random.Range(reactionProfile.upMin * intensity, reactionProfile.upMax * intensity);
        currentAnimation = StartCoroutine(AnimateWithBounce(targetOffset, reactionProfile));
    }

    private void HandleMountainTileBeat(float beatDuration) // Structure inchangée
    {
        if (reactionProfile == null) return;
        if (!reactionProfile.alwaysReact && Random.value > currentDynamicReactionProbability) return;
        if (currentAnimation != null) { StopCoroutine(currentAnimation); isAnimating = false; }
        float shakeDurationMultiplier = reactionProfile.groundAnimBeatMultiplier * 0.7f; // Assurez-vous que groundAnimBeatMultiplier est pertinent ou utilisez une variable dédiée
        float shakeDuration = beatDuration * shakeDurationMultiplier;
        float currentMountainReactionStrength = reactionProfile.mountainReactionStrength * GetCurrentIntensityFactor();
        currentAnimation = StartCoroutine(ShakeMountain(currentMountainReactionStrength, shakeDuration));
    }
    #endregion

    #region Animations // Doivent maintenant utiliser basePositionForAnimation
    private IEnumerator AnimateWaterTile(float beatDuration, TileReactionProfile_SO profile)
    {
        if (profile == null) yield break;
        isAnimating = true;
        Vector3 currentActualPos = transform.position;
        Vector3 originalScale = transform.localScale;
        float intensityFactor = GetCurrentIntensityFactor();
        Vector3 maxScale = originalScale * profile.waterScaleFactor * intensityFactor;
        float currentWaterMoveHeight = profile.waterMoveHeight * intensityFactor;
        Vector3 upPosTarget = basePositionForAnimation + new Vector3(0, currentWaterMoveHeight, 0); // UTILISE basePositionForAnimation

        float nextBeatTime = Time.time + beatDuration;
        if(MusicManager.Instance != null) nextBeatTime = MusicManager.Instance.GetNextBeatTime();

        float timeUntilNextBeatOnStart = nextBeatTime - Time.time;
        float totalAnimationDuration = beatDuration * profile.waterAnimationDurationMultiplier;
        float preBeatDuration = totalAnimationDuration * profile.preBeatFraction;
        float postBeatDuration = totalAnimationDuration - preBeatDuration;

        if (timeUntilNextBeatOnStart < preBeatDuration * 0.8f && MusicManager.Instance != null) nextBeatTime += beatDuration;

        float animationStartTime = nextBeatTime - preBeatDuration;
        float waitTime = animationStartTime - Time.time;
        if (waitTime > 0) yield return new WaitForSeconds(waitTime);

        float startTimePhase1 = Time.time;
        float endTimePhase1 = nextBeatTime;
        while (Time.time < endTimePhase1)
        {
            float progress = Mathf.InverseLerp(startTimePhase1, endTimePhase1, Time.time);
            float easedProgress = Mathf.Sin(progress * Mathf.PI * 0.5f);
            transform.position = Vector3.Lerp(currentActualPos, upPosTarget, easedProgress);
            transform.localScale = Vector3.Lerp(originalScale, maxScale, easedProgress);
            yield return null;
        }
        transform.position = upPosTarget;
        transform.localScale = maxScale;

        float startTimePhase2 = Time.time;
        float endTimePhase2 = startTimePhase2 + postBeatDuration;
        currentActualPos = transform.position;
        while (Time.time < endTimePhase2)
        {
            float progress = Mathf.InverseLerp(startTimePhase2, endTimePhase2, Time.time);
            float easedProgress = 1f - Mathf.Sin((1f - progress) * Mathf.PI * 0.5f);
            transform.position = Vector3.Lerp(currentActualPos, basePositionForAnimation, easedProgress); // RETOURNE à basePositionForAnimation
            transform.localScale = Vector3.Lerp(maxScale, originalScale, easedProgress);
            yield return null;
        }
        transform.position = basePositionForAnimation; // Assure le retour à basePositionForAnimation
        transform.localScale = originalScale;
        isAnimating = false;
    }

    private void RandomizeMovementDuration(float beatDuration, TileReactionProfile_SO profile) // Inchangé
    {
        if (profile == null) return;
        float baseAnimDuration = beatDuration * profile.groundAnimBeatMultiplier;
        currentMovementDuration = Mathf.Clamp(baseAnimDuration + Random.Range(-profile.durationVariation, profile.durationVariation), 0.1f, beatDuration * 0.95f);
    }

    private IEnumerator AnimateWithBounce(float targetOffsetY, TileReactionProfile_SO profile)
    {
        if (profile == null) yield break;
        isAnimating = true;
        Vector3 startPos = transform.position;
        Vector3 targetPos = basePositionForAnimation + Vector3.up * targetOffsetY; // UTILISE basePositionForAnimation
        float elapsedTime = 0f;
        while (elapsedTime < currentMovementDuration)
        {
            float t = profile.movementCurve.Evaluate(elapsedTime / currentMovementDuration);
            transform.position = Vector3.Lerp(startPos, targetPos, t);
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        transform.position = targetPos;

        float traveledDistance = Mathf.Abs(targetPos.y - startPos.y);
        float bounceAmplitude = profile.bouncePercentage * traveledDistance;
        // Le rebond se fait par rapport à targetPos, qui est déjà calculée par rapport à basePositionForAnimation
        Vector3 bounceUpTarget = targetPos + Vector3.up * (targetOffsetY > (startPos.y - basePositionForAnimation.y) ? -bounceAmplitude : bounceAmplitude);

        yield return StartCoroutine(AnimateBounceInternal(targetPos, bounceUpTarget, profile.bounceDuration, profile));
        isAnimating = false;
    }

    private IEnumerator AnimateBounceInternal(Vector3 fromPos, Vector3 bouncePeakPos, float duration, TileReactionProfile_SO profile) // Inchangé
    {
        if (profile == null) yield break;
        float halfDuration = duration / 2f;
        float elapsedTime = 0f;
        while (elapsedTime < halfDuration)
        {
            transform.position = Vector3.Lerp(fromPos, bouncePeakPos, profile.movementCurve.Evaluate(elapsedTime / halfDuration));
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        elapsedTime = 0f;
        while (elapsedTime < halfDuration)
        {
            transform.position = Vector3.Lerp(bouncePeakPos, fromPos, profile.movementCurve.Evaluate(elapsedTime / halfDuration));
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        transform.position = fromPos;
    }

    private IEnumerator ShakeMountain(float intensity, float duration)
    {
        isAnimating = true;
        Vector3 actualBasePos = basePositionForAnimation; // UTILISE basePositionForAnimation
        float elapsedTime = 0f;
        while (elapsedTime < duration)
        {
            float xOffset = Random.Range(-1f, 1f) * 0.02f * intensity;
            float zOffset = Random.Range(-1f, 1f) * 0.02f * intensity;
            transform.position = actualBasePos + new Vector3(xOffset, 0, zOffset);
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        transform.position = actualBasePos; // Retourne à basePositionForAnimation
        isAnimating = false;
    }
    #endregion

    #region Utility and State Management // GetCurrentIntensityFactor et HandleMusicStateChange inchangés
    private void HandleMusicStateChange(string newStateKey)
    {
        if (disableRhythmReactions) return;
        if (enableMusicStateReactions) currentMusicStateKey = newStateKey;
    }

    private float GetCurrentIntensityFactor()
    {
        if (!enableMusicStateReactions) return 1.0f;
        switch (currentMusicStateKey.ToLower()) // Utiliser ToLower() pour la robustesse
        {
            case "exploration": return explorationIntensityFactor;
            case "combat": return combatIntensityFactor;
            case "boss": return bossIntensityFactor;
            default: return 1.0f;
        }
    }

    protected override void OnDestroy() // Inchangé
    {
        base.OnDestroy();
        if (!disableRhythmReactions)
        {
            if (MusicManager.Instance != null)
            {
                MusicManager.Instance.OnBeat -= HandleBeat;
                MusicManager.Instance.OnMusicStateChanged -= HandleMusicStateChange;
            }
            if (reactionProfile != null && ComboController.Instance != null && tileType == TileType.Ground && reactionProfile.reactToCombo)
            {
                ComboController.Instance.RemoveObserver(this);
            }
        }
    }

    public void ResetToDefaultState() // Doit maintenant utiliser basePositionForAnimation
    {
        if (currentAnimation != null) StopCoroutine(currentAnimation);
        if (reactionProfile != null) currentDynamicReactionProbability = reactionProfile.reactionProbability;
        lastComboThresholdReached = 0;

        isReactiveStateInitialized = false; // Permettre à Initialize de s'exécuter (si Start l'appelle conditionnellement)
        // Réinitialiser la position à celle capturée au début du jeu
        if (Application.isPlaying) // Ne le faire que si le jeu tourne, sinon OnValidate s'en occupe.
        {
            transform.position = basePositionForAnimation;
        }
        InitializeReactiveVisualState(); // Pour réinitialiser l'état d'animation, etc.
    }

    protected override void UpdateTileAppearance() // Inchangé
    {
        base.UpdateTileAppearance();
        if (currentAnimation != null) StopCoroutine(currentAnimation);
        if (tileType == TileType.Water)
        {
            if (sequenceNumberText == null) CreateSequenceNumberText();
            else { sequenceNumberText.text = waterSequenceNumber.ToString(); sequenceNumberText.gameObject.SetActive(true); }
        }
        else if (sequenceNumberText != null) sequenceNumberText.gameObject.SetActive(false);
    }
    #endregion

    #region Editor Specifics // OnValidate ne doit plus appeler InitializeReactiveVisualState pour la position
    #if UNITY_EDITOR
        void OnValidate()
        {
            if (Application.isPlaying || UnityEditor.EditorApplication.isPlayingOrWillChangePlaymode) return;

            UnityEditor.EditorApplication.delayCall += () =>
            {
                if (this == null || this.gameObject == null || !this.gameObject.scene.IsValid()) return;

                // InitializeReactiveVisualState() ne modifiera plus transform.position en mode éditeur.
                // Elle peut être appelée si elle a d'autres logiques d'initialisation visuelle
                // qui sont sûres pour l'éditeur (ex: matériaux).
                // Si elle ne fait QUE gérer la position, cet appel peut être commenté/supprimé d'ici.
                // Pour l'instant, on la laisse, car elle reset isAnimating et currentAnimation.
                InitializeReactiveVisualState();

                // Si vous avez d'autres logiques dans OnValidate qui doivent s'exécuter, gardez-les.
                ValidateProfileAssignment();
                if (tileType == TileType.Water && GetComponentInChildren<TMPro.TextMeshPro>() != null) // Recréer si nécessaire
                {
                    // Mettre à jour le texte si le composant existe déjà
                    // Pourrait aussi être dans CreateSequenceNumberText, mais OnValidate est appelé plus souvent.
                    var tmp = GetComponentInChildren<TMPro.TextMeshPro>();
                    if (tmp) tmp.text = this.waterSequenceNumber.ToString();
                } else if (tileType == TileType.Water) {
                    CreateSequenceNumberText(); // S'il n'existe pas
                }


                // Forcer la mise à jour de la vue Scène peut toujours être utile
                if (UnityEditor.SceneView.lastActiveSceneView != null) {
                    UnityEditor.SceneView.lastActiveSceneView.Repaint();
                }
            };
        }
    #endif
    #endregion

    #region Helper Methods for Odin Inspector // Inchangé
    private bool IsWaterTile() => tileType == TileType.Water;
    private bool IsGroundTile() => tileType == TileType.Ground;
    private bool IsMountainTile() => tileType == TileType.Mountain;
    #endregion

    #region Editor Utilities // Inchangé
#if UNITY_EDITOR
    [ContextMenu("Increment Sequence Number")]
    private void IncrementSequenceNumber()
    {
        if (waterSequenceTotal <= 0) waterSequenceTotal = 1;
        waterSequenceNumber = (waterSequenceNumber + 1) % waterSequenceTotal;
        if (sequenceNumberText != null) sequenceNumberText.text = waterSequenceNumber.ToString();
        else CreateSequenceNumberText();
    }
    [ContextMenu("Decrement Sequence Number")]
    private void DecrementSequenceNumber()
    {
        if (waterSequenceTotal <= 0) waterSequenceTotal = 1;
        waterSequenceNumber = (waterSequenceNumber - 1 + waterSequenceTotal) % waterSequenceTotal;
        if (sequenceNumberText != null) sequenceNumberText.text = waterSequenceNumber.ToString();
        else CreateSequenceNumberText();
    }
    [ContextMenu("Test Combo Increase (Add Threshold)")]
    private void TestComboIncrease()
    {
        if (reactionProfile == null) { Debug.LogWarning($"Cannot test combo: ReactionProfile is null."); return; }
        if (!reactionProfile.reactToCombo) { Debug.LogWarning($"Cannot test combo: reactToCombo is false in profile."); return; }
        if (tileType != TileType.Ground) { Debug.LogWarning($"Cannot test combo: TileType is not Ground."); return; }

        int currentComboForTest = (lastComboThresholdReached + 1) * (reactionProfile.comboThreshold > 0 ? reactionProfile.comboThreshold : 5);
        OnComboUpdated(currentComboForTest);
        Debug.Log($"Tested combo increase to {currentComboForTest}. New dynamic probability: {currentDynamicReactionProbability}");
    }
    [ContextMenu("Reset Combo Reaction")]
    private void TestComboReset() { OnComboReset(); Debug.Log($"Tested combo reset. Dynamic probability: {currentDynamicReactionProbability}"); }
#endif
    #endregion

    // Ajout de CreateSequenceNumberText() comme dans la version précédente si elle avait été omise.
    private void CreateSequenceNumberText()
    {
        sequenceNumberText = GetComponentInChildren<TMPro.TextMeshPro>();
        if (sequenceNumberText == null)
        {
            GameObject textObject = new GameObject("SequenceNumberText");
            textObject.transform.SetParent(transform);
            RectTransform rect = textObject.AddComponent<RectTransform>();
            rect.localPosition = new Vector3(0, 0.05f, 0); // Ajuster si nécessaire
            rect.localRotation = Quaternion.Euler(90, 0, 0);
            rect.localScale = new Vector3(0.05f, 0.05f, 0.05f);
            rect.sizeDelta = new Vector2(100, 20);

            sequenceNumberText = textObject.AddComponent<TMPro.TextMeshPro>();
            sequenceNumberText.alignment = TMPro.TextAlignmentOptions.Center;
            sequenceNumberText.fontSize = 10;
            sequenceNumberText.color = Color.white;
            sequenceNumberText.enableWordWrapping = false;
        }
        sequenceNumberText.text = this.waterSequenceNumber.ToString();
        sequenceNumberText.gameObject.SetActive(true);
    }
}


// --- FILE: Scripts/MusicReactiveTile_Optimized.cs ---
﻿using UnityEngine;
using System.Collections.Generic;
using Sirenix.OdinInspector;
using Game.Observers;
using ScriptableObjects;

public class MusicReactiveTile_Optimized : Tile, IComboObserver
{
    #region Profile & State Reactivity
    [Title("Reaction Profile")]
    [SerializeField]
    [Required("A TileReactionProfile_SO must be assigned for this tile to react.")]
    private TileReactionProfile_SO reactionProfile;

    [Title("Rhythm Interaction")]
    [Tooltip("Si coché, cette tuile ne réagira PAS aux événements rythmiques.")]
    [SerializeField]
    public bool disableRhythmReactions = false;

    [Title("Music State Reactivity")]
    [SerializeField] private bool enableMusicStateReactions = true;
    [ShowIf("enableMusicStateReactions")]
    [SerializeField] private float explorationIntensityFactor = 1.0f;
    [ShowIf("enableMusicStateReactions")]
    [SerializeField] private float combatIntensityFactor = 1.2f;
    [ShowIf("enableMusicStateReactions")]
    [SerializeField] private float bossIntensityFactor = 1.4f;
    #endregion

    #region Instance Specific Settings
    [Title("Instance Specific Water Sequence")]
    [ShowIf("IsWaterTile")]
    [SerializeField, Tooltip("Sequence number for this specific water tile (0 to Total-1).")]
    private int waterSequenceNumber = 0;

    [ShowIf("IsWaterTile")]
    [SerializeField, Tooltip("Total number of unique steps in this water body's animation sequence.")]
    [MinValue(1)]
    private int waterSequenceTotal = 3;
    #endregion

    private string currentMusicStateKey = "Exploration";

    #region Private Variables
    private bool isAnimating = false;
    private float currentMovementDuration;
    private bool isReactiveStateInitialized = false;
    private List<int> activeWaveSequences = new List<int>();
    private int beatCounterForWaterWaves = 0;
    private TMPro.TextMeshPro sequenceNumberText;
    private float currentDynamicReactionProbability;
    private int lastComboThresholdReached = 0;
    private Vector3 basePositionForAnimation;
    private Vector3 baseScaleForAnimation;
    private Vector3 pendingWaterTargetPos;
    private Vector3 pendingWaterTargetScale;
    private float pendingWaterPhase1Duration;
    private float pendingWaterPhase2Duration;
    #endregion

    #region Initialization Methods
    protected override void Start()
    {
        base.Start();

        basePositionForAnimation = transform.position;
        baseScaleForAnimation = transform.localScale;

        if (reactionProfile == null)
        {
            disableRhythmReactions = true;
        }

        ValidateProfileAssignment();
        if (reactionProfile != null)
        {
            currentDynamicReactionProbability = reactionProfile.reactionProbability;

            // CORRIGÉ : L'appel à CacheAnimationCurve existe maintenant
            if (TileAnimationManager.Instance != null && reactionProfile.movementCurve != null)
            {
                TileAnimationManager.Instance.CacheAnimationCurve(
                    $"TileProfile_{reactionProfile.name}",
                    reactionProfile.movementCurve
                );
            }
        }

        if (!disableRhythmReactions && reactionProfile != null)
        {
            if (MusicManager.Instance != null)
            {
                MusicManager.Instance.OnBeat += HandleBeat;
                MusicManager.Instance.OnMusicStateChanged += HandleMusicStateChange;
            }
            if (tileType == TileType.Ground && reactionProfile.reactToCombo && ComboController.Instance != null)
            {
                ComboController.Instance.AddObserver(this);
            }
        }

        if (tileType == TileType.Water)
        {
            waterSequenceNumber = Mathf.Clamp(waterSequenceNumber, 0, Mathf.Max(0, waterSequenceTotal - 1));
            CreateSequenceNumberText();
            if (reactionProfile != null) beatCounterForWaterWaves = reactionProfile.waterBeatsBetweenWaves;
        }

        if (Application.isPlaying)
        {
            InitializeReactiveVisualState();
        }

        isReactiveStateInitialized = true;
    }
    #endregion

    #region Beat Handling - Version Finale avec Manager Unifié
    private void HandleBeat(float beatDuration)
    {
        if (disableRhythmReactions || !isReactiveStateInitialized || reactionProfile == null || isAnimating)
        {
            return;
        }

        switch (tileType)
        {
            case TileType.Water:
                HandleWaterTileBeat_Optimized(beatDuration);
                break;
            case TileType.Ground:
                HandleGroundTileBeat_Optimized(beatDuration);
                break;
            case TileType.Mountain:
                HandleMountainTileBeat_Optimized(beatDuration);
                break;
        }
    }

    private void HandleGroundTileBeat_Optimized(float beatDuration)
    {
        if (!reactionProfile.alwaysReact && Random.value > currentDynamicReactionProbability) return;

        RandomizeMovementDuration(beatDuration, reactionProfile);
        float intensity = GetCurrentIntensityFactor();
        float targetOffset = (transform.position.y >= basePositionForAnimation.y) ?
            Random.Range(reactionProfile.downMin * intensity, reactionProfile.downMax * intensity) :
            Random.Range(reactionProfile.upMin * intensity, reactionProfile.upMax * intensity);

        Vector3 targetPosition = basePositionForAnimation + Vector3.up * targetOffset;
        float totalDuration = currentMovementDuration + reactionProfile.bounceDuration;

        isAnimating = true;
        TileAnimationManager.Instance.RequestAnimation(
            this.transform,
            totalDuration,
            OnAnimationComplete,
            targetPosition: targetPosition,
            moveCurve: reactionProfile.movementCurve
        );
    }

    private void HandleWaterTileBeat_Optimized(float beatDuration)
    {
        if (reactionProfile == null) return;
        
        beatCounterForWaterWaves++;
        if (beatCounterForWaterWaves >= reactionProfile.waterBeatsBetweenWaves)
        {
            beatCounterForWaterWaves = 0;
            activeWaveSequences.Add(0);
        }

        for (int i = activeWaveSequences.Count - 1; i >= 0; i--)
        {
            activeWaveSequences[i]++;
            if (activeWaveSequences[i] > this.waterSequenceTotal)
            {
                activeWaveSequences.RemoveAt(i);
                continue;
            }

            if (activeWaveSequences[i] - 1 == this.waterSequenceNumber)
            {
                if (!reactionProfile.alwaysReact && Random.value > currentDynamicReactionProbability) continue;

                // Préparer les paramètres de l'animation
                float intensityFactor = GetCurrentIntensityFactor();
                float currentWaterMoveHeight = reactionProfile.waterMoveHeight * intensityFactor;
                Vector3 upPosition = basePositionForAnimation + Vector3.up * currentWaterMoveHeight;
                Vector3 maxScale = baseScaleForAnimation * reactionProfile.waterScaleFactor * intensityFactor;
                
                // Calculer les durées comme dans l'original
                float totalAnimationDuration = beatDuration * reactionProfile.waterAnimationDurationMultiplier;
                float preBeatDuration = totalAnimationDuration * reactionProfile.preBeatFraction;
                float postBeatDuration = totalAnimationDuration - preBeatDuration;

                // Calcul du timing par rapport au prochain beat
                float nextBeatTime = Time.time + beatDuration;
                if (MusicManager.Instance != null) 
                {
                    nextBeatTime = MusicManager.Instance.GetNextBeatTime();
                }
                
                float timeUntilNextBeat = nextBeatTime - Time.time;
                
                // Ajuster si on est trop proche du prochain beat
                if (timeUntilNextBeat < preBeatDuration * 0.8f && MusicManager.Instance != null) 
                {
                    nextBeatTime += beatDuration;
                }
                
                // Calculer le délai avant de commencer l'animation
                float animationStartTime = nextBeatTime - preBeatDuration;
                float delayBeforeStart = Mathf.Max(0, animationStartTime - Time.time);

                isAnimating = true;
                
                // Si on doit attendre avant de commencer
                if (delayBeforeStart > 0)
                {
                    Invoke(nameof(StartWaterAnimationSequence), delayBeforeStart);
                    // Stocker les paramètres pour l'animation différée
                    StoreWaterAnimationParams(upPosition, maxScale, preBeatDuration, postBeatDuration);
                }
                else
                {
                    // Commencer immédiatement
                    StartWaterAnimationPhase1(upPosition, maxScale, preBeatDuration, postBeatDuration);
                }
                
                break;
            }
        }
    }

    
    
private void StoreWaterAnimationParams(Vector3 targetPos, Vector3 targetScale, float phase1Duration, float phase2Duration)
{
    pendingWaterTargetPos = targetPos;
    pendingWaterTargetScale = targetScale;
    pendingWaterPhase1Duration = phase1Duration;
    pendingWaterPhase2Duration = phase2Duration;
}

private void StartWaterAnimationSequence()
{
    StartWaterAnimationPhase1(pendingWaterTargetPos, pendingWaterTargetScale, pendingWaterPhase1Duration, pendingWaterPhase2Duration);
}

private void StartWaterAnimationPhase1(Vector3 upPosition, Vector3 maxScale, float phase1Duration, float phase2Duration)
{
    // Phase 1 : Montée et grossissement avec une courbe sinusoïdale d'entrée
    AnimationCurve phase1Curve = AnimationCurve.EaseInOut(0, 0, 1, 1);
    // Approximation de Sin(t * PI * 0.5) - courbe d'accélération douce
    phase1Curve.keys = new Keyframe[] {
        new Keyframe(0f, 0f, 0f, 1.8f),
        new Keyframe(0.5f, 0.5f, 1.2f, 1.2f),
        new Keyframe(1f, 1f, 0f, 0f)
    };
    
    TileAnimationManager.Instance.RequestAnimation(
        this.transform,
        phase1Duration,
        () => OnWaterPhase1Complete(upPosition, maxScale, phase2Duration),
        targetPosition: upPosition,
        moveCurve: phase1Curve,
        targetScale: maxScale,
        scaleCurve: phase1Curve
    );
}

private void OnWaterPhase1Complete(Vector3 currentUpPosition, Vector3 currentMaxScale, float phase2Duration)
{
    // Phase 2 : Descente et rétrécissement avec une courbe sinusoïdale de sortie
    AnimationCurve phase2Curve = AnimationCurve.EaseInOut(0, 0, 1, 1);
    // Approximation de 1 - Sin((1-t) * PI * 0.5) - courbe de décélération douce
    phase2Curve.keys = new Keyframe[] {
        new Keyframe(0f, 0f, 0f, 0f),
        new Keyframe(0.5f, 0.5f, 1.2f, 1.2f),
        new Keyframe(1f, 1f, 1.8f, 0f)
    };
    
    TileAnimationManager.Instance.RequestAnimation(
        this.transform,
        phase2Duration,
        OnAnimationComplete,
        targetPosition: basePositionForAnimation,
        moveCurve: phase2Curve,
        targetScale: baseScaleForAnimation,
        scaleCurve: phase2Curve
    );
}

// Modifier aussi la méthode InitializeReactiveVisualState pour nettoyer les invocations en attente :


    private void HandleMountainTileBeat_Optimized(float beatDuration)
    {
        if (!reactionProfile.alwaysReact && Random.value > currentDynamicReactionProbability) return;

        float shakeDuration = beatDuration * (reactionProfile.groundAnimBeatMultiplier * 0.7f);
        float shakeIntensity = reactionProfile.mountainReactionStrength * GetCurrentIntensityFactor() * 0.02f; // Ajuster l'échelle ici

        isAnimating = true;
        TileAnimationManager.Instance.RequestAnimation(
            this.transform,
            shakeDuration,
            OnAnimationComplete,
            isShake: true,
            shakeIntensity: shakeIntensity
        );
    }

    /// <summary>
    /// Callback fiable appelé par le TileAnimationManager.
    /// </summary>
    public void OnAnimationComplete()
    {
        isAnimating = false;
        // La position/scale de fin est déjà gérée par le Manager.
        // On peut ajouter d'autres logiques ici si nécessaire.
    }
    
    
    
    #endregion

    #region Utility Methods
    private void RandomizeMovementDuration(float beatDuration, TileReactionProfile_SO profile)
    {
        float baseAnimDuration = beatDuration * profile.groundAnimBeatMultiplier;
        currentMovementDuration = Mathf.Clamp(
            baseAnimDuration + Random.Range(-profile.durationVariation, profile.durationVariation),
            0.1f,
            beatDuration * 0.95f
        );
    }

    private float GetCurrentIntensityFactor()
    {
        if (!enableMusicStateReactions) return 1.0f;
        switch (currentMusicStateKey.ToLower())
        {
            case "exploration": return explorationIntensityFactor;
            case "combat": return combatIntensityFactor;
            case "boss": return bossIntensityFactor;
            default: return 1.0f;
        }
    }
    
    public void InitializeReactiveVisualState()
    {
        // Annuler toute animation différée
        CancelInvoke(nameof(StartWaterAnimationSequence));
    
        if (Application.isPlaying)
        {
            if (isAnimating && TileAnimationManager.Instance != null)
            {
                TileAnimationManager.Instance.StopTileAnimations(transform);
            }
            isAnimating = false;

            if (disableRhythmReactions || reactionProfile == null)
            {
                transform.position = basePositionForAnimation;
            }
            else if (tileType == TileType.Ground)
            {
                float initialOffset = Random.Range(reactionProfile.downMin, reactionProfile.upMax);
                transform.position = basePositionForAnimation + Vector3.up * initialOffset;
            }
            else
            {
                transform.position = basePositionForAnimation;
            }
            transform.localScale = baseScaleForAnimation;
        }
    }

    protected override void OnDestroy()
    {
        base.OnDestroy();

        if (isAnimating && TileAnimationManager.Instance != null)
        {
            TileAnimationManager.Instance.StopTileAnimations(transform);
        }

        CancelInvoke();

        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= HandleBeat;
            MusicManager.Instance.OnMusicStateChanged -= HandleMusicStateChange;
        }
        if (ComboController.Instance != null && reactionProfile != null && reactionProfile.reactToCombo)
        {
            ComboController.Instance.RemoveObserver(this);
        }
    }
    #endregion
    
    private void CreateSequenceNumberText()
    {
        sequenceNumberText = GetComponentInChildren<TMPro.TextMeshPro>();
        if (sequenceNumberText == null)
        {
            GameObject textObject = new GameObject("SequenceNumberText");
            textObject.transform.SetParent(transform);
            RectTransform rect = textObject.AddComponent<RectTransform>();
            rect.localPosition = new Vector3(0, 0.05f, 0);
            rect.localRotation = Quaternion.Euler(90, 0, 0);
            rect.localScale = new Vector3(0.05f, 0.05f, 0.05f);
            rect.sizeDelta = new Vector2(100, 20);

            sequenceNumberText = textObject.AddComponent<TMPro.TextMeshPro>();
            sequenceNumberText.alignment = TMPro.TextAlignmentOptions.Center;
            sequenceNumberText.fontSize = 10;
            sequenceNumberText.color = Color.white;
            // CORRIGÉ : L'avertissement CS0618 est résolu ici
            sequenceNumberText.textWrappingMode = TMPro.TextWrappingModes.NoWrap;
        }
        sequenceNumberText.text = this.waterSequenceNumber.ToString();
        sequenceNumberText.gameObject.SetActive(true);
    }
    
    // --- Le reste de votre script (Validation, Combo, Éditeur, etc.) reste ici ---
    // --- Il n'a pas besoin d'être modifié. ---
    #region Unchanged Methods
    private void ValidateProfileAssignment()
    {
        if (reactionProfile == null) return;
        if (reactionProfile.applicableTileType == TileReactionProfile_SO.ProfileApplicability.Generic) return;
        bool mismatch = false;
        switch (this.tileType)
        {
            case TileType.Ground: if (reactionProfile.applicableTileType != TileReactionProfile_SO.ProfileApplicability.Ground) mismatch = true; break;
            case TileType.Water: if (reactionProfile.applicableTileType != TileReactionProfile_SO.ProfileApplicability.Water) mismatch = true; break;
            case TileType.Mountain: if (reactionProfile.applicableTileType != TileReactionProfile_SO.ProfileApplicability.Mountain) mismatch = true; break;
        }
        if (mismatch) Debug.LogWarning($"[{this.name}] Mismatch: TileType '{this.tileType}', Profile for '{reactionProfile.applicableTileType}'.", this);
    }

    public void OnComboUpdated(int newCombo)
    {
        if (disableRhythmReactions || reactionProfile == null || tileType != TileType.Ground || !reactionProfile.reactToCombo) return;
        int thresholdsReached = reactionProfile.comboThreshold > 0 ? newCombo / reactionProfile.comboThreshold : 0;
        if (thresholdsReached > lastComboThresholdReached)
        {
            lastComboThresholdReached = thresholdsReached;
            float boostPercentage = Mathf.Min(reactionProfile.comboReactionBoostPercentage * thresholdsReached, reactionProfile.maxReactionBoostPercentage);
            currentDynamicReactionProbability = Mathf.Clamp01(reactionProfile.reactionProbability * (1f + (boostPercentage / 100f)));
        }
    }

    public void OnComboReset()
    {
        if (disableRhythmReactions || reactionProfile == null || tileType == TileType.Ground || !reactionProfile.reactToCombo) return;
        currentDynamicReactionProbability = reactionProfile.reactionProbability;
        lastComboThresholdReached = 0;
    }

    private void HandleMusicStateChange(string newStateKey)
    {
        if (disableRhythmReactions) return;
        if (enableMusicStateReactions) currentMusicStateKey = newStateKey;
    }

    protected override void UpdateTileAppearance()
    {
        base.UpdateTileAppearance();
        if (isAnimating && TileAnimationManager.Instance != null)
        {
            TileAnimationManager.Instance.StopTileAnimations(transform);
        }
        if (tileType == TileType.Water)
        {
            if (sequenceNumberText == null) CreateSequenceNumberText();
            else { sequenceNumberText.text = waterSequenceNumber.ToString(); sequenceNumberText.gameObject.SetActive(true); }
        }
        else if (sequenceNumberText != null) sequenceNumberText.gameObject.SetActive(false);
    }

    private bool IsWaterTile() => tileType == TileType.Water;
    private bool IsGroundTile() => tileType == TileType.Ground;
    private bool IsMountainTile() => tileType == TileType.Mountain;
    #endregion

#if UNITY_EDITOR
    [Title("Migration Tools")]
    [Button("Copy Values from Original MusicReactiveTile", ButtonSizes.Large)]
    private void CopyValuesFromOriginalTile()
    {
        // Chercher l'ancien script sur le même GameObject
        MusicReactiveTile originalTile = GetComponent<MusicReactiveTile>();
        
        if (originalTile == null)
        {
            Debug.LogError("No original MusicReactiveTile found on this GameObject!");
            return;
        }
        
        // Copier toutes les valeurs publiques et serialized
        // D'abord les valeurs de base de Tile
        this.column = originalTile.column;
        this.row = originalTile.row;
        this.state = originalTile.state;
        this.tileType = originalTile.tileType;
        
        // Ensuite les valeurs spécifiques à MusicReactiveTile via reflection
        var originalType = originalTile.GetType();
        var optimizedType = this.GetType();
        
        // Liste des champs à copier
        string[] fieldsToCopy = {
            "reactionProfile",
            "disableRhythmReactions",
            "enableMusicStateReactions",
            "explorationIntensityFactor",
            "combatIntensityFactor",
            "bossIntensityFactor",
            "waterSequenceNumber",
            "waterSequenceTotal"
        };
        
        foreach (string fieldName in fieldsToCopy)
        {
            var originalField = originalType.GetField(fieldName, 
                System.Reflection.BindingFlags.NonPublic | 
                System.Reflection.BindingFlags.Instance);
            var optimizedField = optimizedType.GetField(fieldName, 
                System.Reflection.BindingFlags.NonPublic | 
                System.Reflection.BindingFlags.Instance);
            
            if (originalField != null && optimizedField != null)
            {
                object value = originalField.GetValue(originalTile);
                optimizedField.SetValue(this, value);
            }
        }
        
        Debug.Log($"Successfully copied values from original tile at ({column}, {row})");
        
        // Marquer l'objet comme modifié pour sauvegarder les changements
        UnityEditor.EditorUtility.SetDirty(this);
    }
    
    [Button("Remove Original Script After Migration")]
    [ShowIf("HasOriginalScript")]
    private void RemoveOriginalScript()
    {
        MusicReactiveTile originalTile = GetComponent<MusicReactiveTile>();
        if (originalTile != null)
        {
            DestroyImmediate(originalTile);
            Debug.Log("Original MusicReactiveTile script removed.");
            UnityEditor.EditorUtility.SetDirty(gameObject);
        }
    }
    
    private bool HasOriginalScript()
    {
        return GetComponent<MusicReactiveTile>() != null;
    }
#endif
}



// --- FILE: Scripts/MusicReactiveVisuals.cs ---
using UnityEngine;

public class MusicReactiveVisuals : MonoBehaviour
{
    [Header("Visual Effects")]
    [SerializeField] protected Color beatColor = Color.cyan;
    [SerializeField] protected float glowIntensity = 1.5f;
    [SerializeField] protected bool useEmission = true;

    protected Material material;
    protected Color originalColor;

    protected virtual void Awake()
    {
        material = GetComponent<Renderer>().material;
        originalColor = material.color;
    }

    /// <summary>
    /// Call this during an animation to update color/emission based on progress (t from 0 to 1).
    /// </summary>
    public virtual void ApplyVisualEffects(float t)
    {
        if (useEmission)
        {
            float colorT = Mathf.Clamp01(t * 2f);
            material.SetColor("_EmissionColor", Color.Lerp(Color.black, beatColor * glowIntensity, colorT));
            material.color = Color.Lerp(originalColor, beatColor, colorT);
        }
    }

    /// <summary>
    /// Resets the material colors to their original state.
    /// </summary>
    public virtual void ResetVisuals()
    {
        if (useEmission)
        {
            material.SetColor("_EmissionColor", Color.black);
            material.color = originalColor;
        }
    }
}

// --- FILE: Scripts/TeamType.cs ---
using UnityEngine;

// Define the possible teams for buildings and units
public enum TeamType
{
    Neutral,
    NeutralPlayer,
    NeutralEnemy,
    Player,
    Enemy
}

// --- FILE: Scripts/Tile.cs ---
// Fichier: Scripts2/Tile.cs
using UnityEngine;
using System.Collections.Generic;

public enum TileState { Default, Activated, Captured } // Assurez-vous que ces enums sont définis
public enum TileType { Ground, Water, Mountain } // Assurez-vous que ces enums sont définis

public class Tile : MonoBehaviour
{
    [SerializeField] private int _column;
    [SerializeField] private int _row;
    [SerializeField] private TileState _tileState = TileState.Default;
    [SerializeField] private TileType _tileType = TileType.Ground; // Gardez le type par défaut
    [SerializeField] private List<Tile> _neighbors = new List<Tile>();

    // Références aux objets sur la tuile
    [SerializeField] private Building _building;
    [SerializeField] private Unit _unit;
    [SerializeField] private Environment _environment;

    protected HexGridManager gridManager;
    // private Vector3 originalWorldPosition; // SUPPRIMÉ
    // private bool isBasePositionCaptured = false; // SUPPRIMÉ

    public int column { get => _column; set => _column = value; }
    public int row { get => _row; set => _row = value; }
    public TileState state
    {
        get => _tileState;
        protected set { if (_tileState != value) { _tileState = value; NotifyManagerOfStateChange(); } }
    }
    public TileType tileType
    {
        get => _tileType;
        set { if (_tileType != value) { _tileType = value; UpdateTileAppearance(); NotifyManagerOfStateChange(); } }
    }
    public List<Tile> Neighbors => _neighbors;
    public Building currentBuilding => _building;
    public Unit currentUnit => _unit;
    public Environment currentEnvironment => _environment;

    public bool IsOccupied => _building != null || _unit != null ||
                              _tileType == TileType.Water ||
                              _tileType == TileType.Mountain ||
                              (_environment != null && _environment.IsBlocking);

    public bool IsReserved
    {
        get
        {
            if (TileReservationController.Instance != null)
            {
                return TileReservationController.Instance.IsTileReserved(new Vector2Int(_column, _row));
            }
            return false;
        }
    }

    // Awake est maintenant plus simple
    protected virtual void Awake()
    {
        // Plus besoin de capturer originalWorldPosition ici
    }

    // Start est maintenant plus simple
    protected virtual void Start()
    {
        UpdateTileAppearance();
    }

    protected virtual void OnDestroy()
    {
        // Si HexGridManager est un singleton qui persiste, pas besoin de nullifier la référence ici,
        // sauf si vous avez une logique spécifique de nettoyage de scène.
        // gridManager = null;
    }

    public void SetGridManager(HexGridManager manager) { gridManager = manager; }
    public void SetNeighbors(List<Tile> newNeighbors) { _neighbors = newNeighbors; }

    public virtual void AssignUnit(Unit unit)
    {
        if (_tileType == TileType.Water || _tileType == TileType.Mountain) return;
        bool oldOccupiedState = IsOccupied;
        _unit = unit;
        if (oldOccupiedState != IsOccupied) NotifyManagerOfStateChange();
    }
    public virtual void RemoveUnit()
    {
        if (_unit != null) { bool old = IsOccupied; _unit = null; if (old != IsOccupied) NotifyManagerOfStateChange(); }
    }
    public virtual void AssignBuilding(Building building)
    {
        if (_tileType == TileType.Water || _tileType == TileType.Mountain) return;
        bool oldOccupiedState = IsOccupied;
        _building = building;
        if (oldOccupiedState != IsOccupied) NotifyManagerOfStateChange();
    }
    public virtual void RemoveBuilding()
    {
        if (_building != null) { bool old = IsOccupied; _building = null; if (old != IsOccupied) NotifyManagerOfStateChange(); }
    }
    public virtual void AssignEnvironment(Environment environment)
    {
        bool oldOccupiedState = IsOccupied;
        _environment = environment;
        if (environment != null && environment.transform.IsChildOf(transform))
        {
            // La logique de compensation d'échelle peut rester si nécessaire
            Vector3 originalScale = environment.transform.localScale;
            Vector3 tileScale = transform.lossyScale; // Utiliser lossyScale si la tuile elle-même est scalée
            Vector3 counterScale = new Vector3(
                tileScale.x != 0 ? 1.0f / tileScale.x : 1.0f,
                tileScale.y != 0 ? 1.0f / tileScale.y : 1.0f,
                tileScale.z != 0 ? 1.0f / tileScale.z : 1.0f);
            environment.transform.localScale = Vector3.Scale(originalScale, counterScale);
        }
        if (oldOccupiedState != IsOccupied) NotifyManagerOfStateChange();
    }
    public virtual void RemoveEnvironment()
    {
        if (_environment != null) { bool old = IsOccupied; _environment = null; if (old != IsOccupied) NotifyManagerOfStateChange(); }
    }
    public void NotifyManagerOfStateChange() { gridManager?.NotifyTileChanged(this); }
    protected virtual void UpdateTileAppearance() { /* Logique visuelle ici, ne doit pas dépendre de originalWorldPosition */ }
}

// --- FILE: Scripts/TileAnimationManager.cs ---
﻿// Fichier : Assets/Scripts/TileAnimationManager.cs (COMPLET ET CORRIGÉ)
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Gestionnaire centralisé pour toutes les animations de tuiles.
/// Version finale et corrigée : interface simplifiée, supporte position et scale,
/// et inclut les méthodes de gestion nécessaires.
/// </summary>
public class TileAnimationManager : MonoBehaviour
{
    public static TileAnimationManager Instance { get; private set; }

    public struct TileAnimationState
    {
        // Références
        public Transform transform;
        public System.Action onCompleteCallback;

        // Paramètres de l'animation
        public float startTime;
        public float duration;

        // Mouvement de position
        public Vector3 startPosition;
        public Vector3 targetPosition;
        public AnimationCurve movementCurve;

        // Mouvement de scale
        public Vector3 startScale;
        public Vector3 targetScale;
        public AnimationCurve scaleCurve;

        // Animation de type "Shake"
        public bool isShakeAnimation;
        public float shakeIntensity;

        public bool isActive;
    }

    private List<TileAnimationState> activeAnimations = new List<TileAnimationState>(500);
    private Queue<int> freeIndices = new Queue<int>(500);
    private int currentActiveAnimations = 0;

    // Le cache de courbe que votre code utilise
    private Dictionary<string, AnimationCurve> curveCache = new Dictionary<string, AnimationCurve>();

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Pré-allouer la capacité de la liste et de la file
        for (int i = 0; i < 500; i++)
        {
            activeAnimations.Add(new TileAnimationState());
            freeIndices.Enqueue(i);
        }
    }

    /// <summary>
    /// La méthode UNIQUE et flexible pour demander TOUS types d'animations.
    /// </summary>
    public bool RequestAnimation(
        Transform tileTransform,
        float duration,
        System.Action onComplete,
        // Paramètres pour le mouvement
        Vector3? targetPosition = null,
        AnimationCurve moveCurve = null,
        // Paramètres pour le scale
        Vector3? targetScale = null,
        AnimationCurve scaleCurve = null,
        // Paramètres pour le shake
        bool isShake = false,
        float shakeIntensity = 0f)
    {
        if (freeIndices.Count == 0)
        {
            Debug.LogWarning("[TileAnimationManager] Limite d'animations atteinte!");
            return false;
        }

        int index = freeIndices.Dequeue();

        var animState = new TileAnimationState
        {
            transform = tileTransform,
            onCompleteCallback = onComplete,
            startTime = Time.time,
            duration = duration,

            // Position (utilise la position actuelle si la cible est nulle)
            startPosition = tileTransform.position,
            targetPosition = targetPosition ?? tileTransform.position,
            movementCurve = moveCurve,

            // Scale (utilise le scale actuel si la cible est nulle)
            startScale = tileTransform.localScale,
            targetScale = targetScale ?? tileTransform.localScale,
            scaleCurve = scaleCurve,

            // Shake
            isShakeAnimation = isShake,
            shakeIntensity = shakeIntensity,

            isActive = true
        };

        activeAnimations[index] = animState;
        currentActiveAnimations++;
        return true;
    }

    void Update()
    {
        if (currentActiveAnimations == 0) return;

        float currentTime = Time.time;
        for (int i = 0; i < activeAnimations.Count; i++)
        {
            if (!activeAnimations[i].isActive) continue;

            // Il est plus sûr de travailler sur une copie
            var anim = activeAnimations[i];
            float progress = Mathf.Clamp01((currentTime - anim.startTime) / anim.duration);

            if (anim.isShakeAnimation)
            {
                // Logique de Shake
                float currentIntensity = Mathf.Lerp(anim.shakeIntensity, 0f, progress);
                float shakeX = (Mathf.PerlinNoise(currentTime * 20f, 0f) * 2f - 1f) * currentIntensity;
                float shakeZ = (Mathf.PerlinNoise(0f, currentTime * 20f) * 2f - 1f) * currentIntensity;
                anim.transform.position = anim.startPosition + new Vector3(shakeX, 0, shakeZ);
            }
            else
            {
                // Logique de Position
                if (anim.movementCurve != null)
                {
                    float curveValue = anim.movementCurve.Evaluate(progress);
                    anim.transform.position = Vector3.LerpUnclamped(anim.startPosition, anim.targetPosition, curveValue);
                }

                // Logique de Scale
                if (anim.scaleCurve != null && anim.targetScale != anim.startScale)
                {
                    float scaleValue = anim.scaleCurve.Evaluate(progress);
                    anim.transform.localScale = Vector3.LerpUnclamped(anim.startScale, anim.targetScale, scaleValue);
                }
            }

            if (progress >= 1f)
            {
                CompleteAnimation(i);
            }
            else
            {
                // Remettre la copie modifiée dans la liste (important car c'est une struct)
                activeAnimations[i] = anim;
            }
        }
    }

    private void CompleteAnimation(int index)
    {
        var anim = activeAnimations[index];
        if (!anim.isActive) return; // Sécurité pour éviter double complétion

        // Assurer l'état final
        anim.transform.position = anim.isShakeAnimation ? anim.startPosition : anim.targetPosition;
        anim.transform.localScale = anim.targetScale;

        // Le callback fiable
        anim.onCompleteCallback?.Invoke();

        // Recycler l'animation
        anim.isActive = false;
        activeAnimations[index] = anim; // Mettre à jour la structure dans la liste
        freeIndices.Enqueue(index);
        currentActiveAnimations--;
    }

    /// <summary>
    /// Arrête proprement toutes les animations pour une tuile donnée.
    /// Méthode requise pour corriger l'erreur de compilation.
    /// </summary>
    public void StopTileAnimations(Transform tileTransform)
    {
        if (tileTransform == null) return;
        for (int i = 0; i < activeAnimations.Count; i++)
        {
            if (activeAnimations[i].isActive && activeAnimations[i].transform == tileTransform)
            {
                // On appelle CompleteAnimation qui s'occupe de tout le nettoyage.
                CompleteAnimation(i);
            }
        }
    }

    /// <summary>
    /// Met en cache une courbe pour une utilisation future (si nécessaire).
    /// Méthode requise pour corriger l'erreur de compilation.
    /// </summary>
    public void CacheAnimationCurve(string curveName, AnimationCurve curve)
    {
        if (curve == null || string.IsNullOrEmpty(curveName)) return;
        curveCache[curveName] = curve;
    }
}

// --- FILE: Scripts/WaitForBeat.cs ---
using UnityEngine;



// --- FILE: Scripts/Attacks/BossAttackSystem.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BossAttackSystem : MonoBehaviour, IAttack
{
    [Tooltip("Effet visuel à jouer lors de l'attaque (ex: une onde de choc). Optionnel.")]
    [SerializeField] private GameObject attackVFX;
    [Tooltip("La distance de repoussement en nombre de cases.")]
    [SerializeField] private int knockbackDistance = 2;

    public bool CanAttack(Transform attacker, Transform target, float attackRange)
    {
        // La décision d'attaquer est gérée par le boss, pas par la portée.
        return true;
    }

    public IEnumerator PerformAttack(Transform attacker, Transform target, int damage, float animationDuration)
    {
        Unit bossUnit = attacker.GetComponent<Unit>();
        if (bossUnit == null) yield break;

        if (attackVFX != null)
        {
            Instantiate(attackVFX, attacker.position, Quaternion.identity);
        }

        // On attend un peu pour la synchronisation visuelle
        yield return new WaitForSeconds(animationDuration * 0.3f);

        Tile centralTile = bossUnit.GetOccupiedTile();
        if (centralTile == null) yield break;

        // On récupère les cases adjacentes au corps du boss (rayon 2)
        List<Tile> tilesInAoERange = HexGridManager.Instance.GetTilesWithinRange(centralTile.column, centralTile.row, 2);

        // --- NOUVEAU: Liste pour stocker les coroutines de repoussement ---
        List<Coroutine> knockbackCoroutines = new List<Coroutine>();

        foreach (var tile in tilesInAoERange)
        {
            if (tile.currentUnit != null && tile.currentUnit is AllyUnit)
            {
                AllyUnit allyToPush = tile.currentUnit as AllyUnit;

                // 1. Appliquer les dégâts
                Debug.Log($"[{bossUnit.name}] attaque [{allyToPush.name}].");
                allyToPush.TakeDamage(damage, bossUnit);

                // 2. Tenter de repousser l'unité
                if (allyToPush != null && allyToPush.Health > 0) // On ne repousse pas une unité morte
                {
                    // --- NOUVEAU: On lance la coroutine et on l'ajoute à la liste ---
                    knockbackCoroutines.Add(StartCoroutine(KnockbackUnit(bossUnit, allyToPush)));
                }
            }
        }

        // --- NOUVEAU: On attend que TOUTES les coroutines de repoussement soient terminées ---
        foreach (var coroutine in knockbackCoroutines)
        {
            yield return coroutine;
        }
        // --- FIN DES MODIFICATIONS ---

        yield return new WaitForSeconds(animationDuration * 0.7f);
    }

    /// <summary>
    /// Gère la logique de repoussement pour une unité spécifique.
    /// </summary>
    private IEnumerator KnockbackUnit(Unit boss, AllyUnit unitToPush)
    {
        Tile startTile = unitToPush.GetOccupiedTile();
        Tile currentTileForPathfinding = startTile;
        Tile destinationTile = startTile;

        if (startTile == null) yield break;

        // On cherche une case de destination valide en s'éloignant du boss, case par case.
        for (int i = 0; i < knockbackDistance; i++)
        {
            // Trouve le voisin le plus éloigné du boss
            Tile nextTileAway = HexGridManager.Instance.GetNeighborAwayFromTarget(
                currentTileForPathfinding.column, currentTileForPathfinding.row,
                boss.GetOccupiedTile().column, boss.GetOccupiedTile().row
            );

            if (nextTileAway != null && !nextTileAway.IsOccupied &&
                !TileReservationController.Instance.IsTileReservedByOtherUnit(new Vector2Int(nextTileAway.column, nextTileAway.row), unitToPush))
            {
                // Si la case est valide, elle devient notre nouvelle destination potentielle
                destinationTile = nextTileAway;
                currentTileForPathfinding = nextTileAway;
            }
            else
            {
                // Si on rencontre un obstacle, on arrête de chercher plus loin.
                break;
            }
        }

        // Si on a trouvé une nouvelle destination (différente de celle de départ)
        if (destinationTile != startTile)
        {
            Debug.Log($"[{boss.name}] repousse [{unitToPush.name}] vers la case ({destinationTile.column}, {destinationTile.row}).");
            // On lance la coroutine de mouvement de l'unité elle-même.
            // C'est la manière la plus propre de la faire bouger.
            yield return unitToPush.StartCoroutine(unitToPush.MoveToTile(destinationTile));
        }
    }
}

// --- FILE: Scripts/Attacks/MeleeAttack.cs ---
using UnityEngine;
using System.Collections;

public class MeleeAttack : MonoBehaviour, IAttack
{
    [Header("Visual Effects")]
    [SerializeField] private GameObject attackVFXPrefab;
    [SerializeField] private float vfxDuration = 0.5f;

    [Header("Beat Synchronization")]
    [SerializeField] private bool syncToBeats = true;
    [SerializeField] private bool visualizeAttackTiming = true;

    [Header("Debug")]
    [SerializeField] private bool showAttackLogs = true;

    [Header("Fever Mode")]
    [Tooltip("L'effet visuel d'impact à utiliser quand le mode Fever est actif.")]
    [SerializeField] private GameObject feverImpactVFXPrefab;

    private MusicManager musicManager;

    private void Awake()
    {
        musicManager = FindObjectOfType<MusicManager>();
        if (musicManager == null && syncToBeats)
        {
            Debug.LogWarning($"[{name}] MusicManager not found but syncToBeats is enabled. Attack timing might be inconsistent.");
        }
    }

    public IEnumerator PerformAttack(Transform attacker, Transform target, int damage, float duration)
    {
        if (target == null || !target.gameObject.activeInHierarchy)
        {
            if (showAttackLogs) Debug.LogWarning($"[{attacker.name}] MeleeAttack: Target is null or inactive. Attack cancelled.");
            yield break;
        }

        if (showAttackLogs)
        {
            Debug.Log($"[{attacker.name}] MeleeAttack: Attacking {target.name} for {damage} damage. Animation duration: {duration}s.");
        }

        Vector3 directionToTarget = target.position - attacker.position;
        directionToTarget.y = 0;
        if (directionToTarget != Vector3.zero)
        {
            attacker.rotation = Quaternion.LookRotation(directionToTarget);
        }

        Unit attackerUnit = attacker.GetComponent<Unit>();
        GameObject vfxToUse = attackVFXPrefab;

        if (attackerUnit != null && attackerUnit.IsFeverActive && feverImpactVFXPrefab != null)
        {
            vfxToUse = feverImpactVFXPrefab;
        }

        GameObject vfxInstance = null;
        if (vfxToUse != null)
        {
            Vector3 vfxPosition = target.position + Vector3.up * 0.5f;
            vfxInstance = Instantiate(vfxToUse, vfxPosition, Quaternion.identity);
        }

        float animationTime = duration;
        if (syncToBeats && musicManager != null)
        {
            float timeUntilNextBeat = musicManager.GetTimeUntilNextBeat();
            animationTime = Mathf.Min(duration, timeUntilNextBeat * 0.95f);
            animationTime = Mathf.Max(animationTime, 0.1f);
            if (showAttackLogs && visualizeAttackTiming)
            {
                Debug.Log($"[{attacker.name}] MeleeAttack Timing: Adjusted anim time: {animationTime:F3}s / Beat Duration: {musicManager.BeatDuration:F3}s");
            }
        }

        float elapsed = 0f;
        while (elapsed < animationTime)
        {
            if (target == null || !target.gameObject.activeInHierarchy)
            {
                if (showAttackLogs) Debug.LogWarning($"[{attacker.name}] MeleeAttack: Target became null or inactive during attack animation. Cancelling attack.");
                if (vfxInstance != null) Destroy(vfxInstance);
                yield break;
            }
            if (attacker == null || !attacker.gameObject.activeInHierarchy)
            {
                if (showAttackLogs) Debug.LogWarning($"[{attacker.name}] MeleeAttack: Attacker became null or inactive during attack animation. Cancelling attack.");
                if (vfxInstance != null) Destroy(vfxInstance);
                yield break;
            }

            elapsed += Time.deltaTime;
            yield return null;
        }

        if (target != null && target.gameObject.activeInHierarchy)
        {
            Unit targetUnit = target.GetComponent<Unit>(); 
            if (targetUnit == null) targetUnit = target.GetComponentInParent<Unit>(); 

            Building targetBuilding = target.GetComponent<Building>(); 
            if (targetBuilding == null) targetBuilding = target.GetComponentInParent<Building>(); 
            
            if ((targetUnit != null && targetUnit.Health <= 0) || 
                (targetBuilding != null && targetBuilding.CurrentHealth <= 0))
            {
                if (showAttackLogs) Debug.LogWarning($"[{attacker.name}] MeleeAttack: Target {target.name} is dead, cancelling damage application.");
                yield break; 
            }
            if (targetUnit != null)
            {
                if (showAttackLogs) Debug.Log($"[{attacker.name}] MeleeAttack: Applying {damage} damage to Unit {targetUnit.name}.");
                targetUnit.TakeDamage(damage, attacker.GetComponent<Unit>()); 
                
            }
            else if (targetBuilding != null)
            {
                if (showAttackLogs) Debug.Log($"[{attacker.name}] MeleeAttack: Applying {damage} damage to Building {targetBuilding.name}.");
                targetBuilding.TakeDamage(damage, attacker.GetComponent<Unit>()); 
               
            }
            else
            {
                if (showAttackLogs) Debug.LogWarning($"[{attacker.name}] MeleeAttack: Target {target.name} has no Unit or Building component to apply damage to.");
            }
        }
        else
        {
            if (showAttackLogs) Debug.LogWarning($"[{attacker.name}] MeleeAttack: Target became null or inactive before damage application.");
        }

        if (vfxInstance != null)
        {
            Destroy(vfxInstance, Mathf.Max(0, vfxDuration - animationTime));
        }

        if (showAttackLogs)
        {
            Debug.Log($"[{attacker.name}] MeleeAttack: Attack animation and damage phase completed for target {target?.name ?? "UNKNOWN"}.");
        }
    }

    public bool CanAttack(Transform attacker, Transform target, float attackRange)
    {
        if (showAttackLogs)
        {
             Debug.Log($"[{attacker.name}] MeleeAttack: CanAttack {target.name} - On se fie à la détection de portée par tuile de l'unité.");
        }
        return true;
    }
}

// --- FILE: Scripts/Attacks/Projectile.cs ---
using UnityEngine;
using System.Collections;

public class Projectile : MonoBehaviour
{
    private Transform targetTransform;
    private int damage;
    private float speed;
    private GameObject impactVFXPrefab;
    private Transform attackerTransform; // Pour éviter de se toucher soi-même si l'attaquant a un collider
    private Unit attacker; // Référence à l'attaquant

    private bool initialized = false;
    private Vector3 lastKnownTargetPosition;

    [Tooltip("Distance à laquelle le projectile est considéré comme ayant atteint la cible (pour les cibles mobiles).")]
    [SerializeField] private float hitThreshold = 0.5f;
    [Tooltip("Durée de vie maximale du projectile en secondes, pour éviter qu'il ne vole indéfiniment si la cible est détruite.")]
    [SerializeField] private float maxLifetime = 5f;
    [Tooltip("Le projectile doit-il suivre la cible (homing) ou aller en ligne droite vers la position initiale de la cible ?")]
    [SerializeField] private bool isHoming = true;
    [Tooltip("Que faire quand la cible disparaît : 0 = disparaître, 1 = continuer vers la dernière position connue")]
    [SerializeField] private int targetDestroyedBehavior = 1;

    public void Initialize(Transform target, int projectileDamage, float projectileSpeed, GameObject vfxPrefab, Unit attacker)
    {
        targetTransform = target;
        damage = projectileDamage;
        speed = projectileSpeed;
        impactVFXPrefab = vfxPrefab;
        this.attacker = attacker; // Update to store the Unit attacker

        if (targetTransform != null)
        {
            lastKnownTargetPosition = targetTransform.position;
        }
        else
        {
            Debug.LogWarning("[Projectile] Cible nulle à l'initialisation. Le projectile s'autodétruira.");
            Destroy(gameObject, 0.1f);
            return;
        }

        initialized = true;
        Destroy(gameObject, maxLifetime); // Autodestruction après un certain temps pour éviter les projectiles perdus
    }

    void Update()
    {
        if (!initialized) return;

        bool targetDestroyed = false;
        
        // Vérifier si la cible existe toujours
        if (targetTransform != null && targetTransform.gameObject.activeInHierarchy)
        {
            lastKnownTargetPosition = targetTransform.position; // Mettre à jour la dernière position connue
        }
        else
        {
            targetDestroyed = true;
            
            // Si la cible est détruite, agir en fonction du comportement configuré
            if (targetDestroyedBehavior == 0) // Disparaître
            {
                HandleImpact(null);
                return;
            }
            // Sinon (comportement == 1), continuer vers la dernière position connue
        }

        Vector3 targetPositionToChase;
        
        if (targetDestroyed)
        {
            // Si la cible est détruite, continuer vers la dernière position connue quelle que soit l'option homing
            targetPositionToChase = lastKnownTargetPosition;
        }
        else if (isHoming)
        {
            // Projectile téléguidé qui suit la cible
            targetPositionToChase = lastKnownTargetPosition;
        }
        else
        {
            // Projectile non téléguidé qui va en ligne droite vers la position initiale
            targetPositionToChase = lastKnownTargetPosition;
        }


        Vector3 direction = (targetPositionToChase - transform.position).normalized;

        if (direction != Vector3.zero)
        {
            transform.rotation = Quaternion.LookRotation(direction);
        }

        transform.position += direction * speed * Time.deltaTime;

        // Vérifier la distance par rapport à la dernière position connue de la cible
        if (Vector3.Distance(transform.position, lastKnownTargetPosition) < hitThreshold)
        {
            HandleImpact(targetTransform != null && targetTransform.gameObject.activeInHierarchy ? targetTransform.GetComponent<Collider>() : null);
        }
    }

    // Gérer la collision du projectile
    void OnTriggerEnter(Collider other)
    {
        if (!initialized) return;

        // Éviter la collision avec l'attaquant lui-même juste après le lancement
        if (attackerTransform != null && other.transform == attackerTransform)
        {
            return;
        }

        // Vérifier si la collision est avec la cible désignée OU si la cible n'existe plus et qu'on touche quelque chose
        if ((targetTransform != null && other.transform == targetTransform) || (targetTransform == null && other.gameObject.layer != gameObject.layer))
        {
            HandleImpact(other);
        }
        // Optionnel : gérer les collisions avec d'autres objets (par exemple, des obstacles)
        // else if (other.gameObject.layer != LayerMask.NameToLayer("IgnoreProjectile")) // Exemple de couche à ignorer
        // {
        //     Debug.Log($"[Projectile] Collision avec un objet inattendu: {other.name}");
        //     HandleImpact(null); // Détruire le projectile, instancier VFX d'impact générique
        // }
    }

    private void HandleImpact(Collider hitCollider)
    {
        if (!initialized) return; // S'assurer que le projectile n'est pas déjà en train d'être détruit

        initialized = false; // Empêcher les impacts multiples

        if (showAttackLogs) Debug.Log($"[Projectile] Impact avec {(hitCollider != null ? hitCollider.name : "cible détruite/position")}.");

        if (hitCollider != null) // Si on a touché un collider valide (pas juste atteint une position)
        {
            // Essayer d'appliquer des dégâts si la cible est une unité ou un bâtiment
            Unit unitTarget = hitCollider.GetComponent<Unit>();
            if (unitTarget == null) unitTarget = hitCollider.GetComponentInParent<Unit>();

            Building buildingTarget = hitCollider.GetComponent<Building>();
            if (buildingTarget == null) buildingTarget = hitCollider.GetComponentInParent<Building>();

            if (unitTarget != null)
            {
                if (showAttackLogs) Debug.Log($"[Projectile] Application de {damage} dégâts à l'unité {unitTarget.name}.");
                unitTarget.TakeDamage(damage, attacker); // Passer l'attaquant
            }
            else if (buildingTarget != null)
            {
                if (showAttackLogs) Debug.Log($"[Projectile] Application de {damage} dégâts au bâtiment {buildingTarget.name}.");
                buildingTarget.TakeDamage(damage, attacker); // Passer l'attaquant
            }
        }

        // Instancier l'effet visuel d'impact si défini
        if (impactVFXPrefab != null)
        {
            Instantiate(impactVFXPrefab, transform.position, Quaternion.LookRotation(-transform.forward)); // Tourné vers l'arrière pour l'explosion
        }

        // Détruire le projectile
        Destroy(gameObject);
    }

    private static bool showAttackLogs = true; // Pourrait être synchronisé avec RangedAttack, mais simple pour l'instant
}

// --- FILE: Scripts/Attacks/RangedAttack.cs ---
using UnityEngine;
using System.Collections;

public class RangedAttack : MonoBehaviour, IAttack
{
    [Header("Projectile Settings")]
    [Tooltip("Le prefab du projectile à lancer (doit avoir un script Projectile).")]
    [SerializeField] private GameObject projectilePrefab;
    [Tooltip("Le prefab de l'effet visuel à l'impact (optionnel).")]
    [SerializeField] private GameObject impactVFXPrefab;
    [Tooltip("Vitesse du projectile en unités par seconde.")]
    [SerializeField] private float projectileSpeed = 20f;
    [Tooltip("Point de lancement du projectile. Si non assigné, utilise la position de l'attaquant avec un offset.")]
    [SerializeField] private Transform projectileSpawnPoint;
    [Tooltip("Offset par rapport à la position de l'attaquant si projectileSpawnPoint n'est pas défini.")]
    [SerializeField] private Vector3 spawnOffset = new Vector3(0, 1f, 0.5f);
    [Tooltip("Délai dans l'animation de l'attaquant avant que le projectile ne soit réellement lancé (en secondes).")]
    [SerializeField] private float fireAnimationDelay = 0.5f;

    [Header("Debug")]
    [SerializeField] private bool showAttackLogs = true;

    [Header("Fever Mode")]
    [Tooltip("Angle de dispersion pour les projectiles supplémentaires en Mode Fever.")]
    [SerializeField] private float feverSpreadAngle = 10f;

    [Header("Fever Mode")]
    [Tooltip("L'effet visuel d'impact à utiliser quand le mode Fever est actif.")]
    [SerializeField] private GameObject feverImpactVFXPrefab;

    [Header("Fever Mode")]
    [Tooltip("Délai entre chaque projectile supplémentaire en secondes.")]
    [SerializeField] private float feverProjectileDelay = 0.1f;
    public IEnumerator PerformAttack(Transform attacker, Transform target, int damage, float duration)
    {
        if (projectilePrefab == null)
        {
            if (showAttackLogs) Debug.LogError($"[{attacker.name}] RangedAttack: Projectile Prefab non assigné !");
            yield break;
        }

        if (target == null)
        {
            if (showAttackLogs) Debug.LogWarning($"[{attacker.name}] RangedAttack: Cible nulle, attaque annulée.");
            yield break;
        }

        Vector3 directionToTarget = target.position - attacker.position;
        directionToTarget.y = 0;
        if (directionToTarget != Vector3.zero)
        {
            attacker.rotation = Quaternion.LookRotation(directionToTarget);
        }

        if (fireAnimationDelay > 0)
        {
            yield return new WaitForSeconds(fireAnimationDelay);
        }

        if (target == null || !target.gameObject.activeInHierarchy)
        {
            if (showAttackLogs) Debug.LogWarning($"[{attacker.name}] RangedAttack: Cible devenue invalide pendant l'animation de tir.");
            yield break;
        }
        
        Vector3 spawnPosition = projectileSpawnPoint != null ? projectileSpawnPoint.position : attacker.position + attacker.TransformDirection(spawnOffset);
        Unit attackerUnit = attacker.GetComponent<Unit>();

        // --- LOGIQUE PRINCIPALE MISE À JOUR ---
        // 1. Tirer le projectile principal
        GameObject vfxToUse = impactVFXPrefab;
        if (attackerUnit != null && attackerUnit.IsFeverActive && feverImpactVFXPrefab != null)
        {
            vfxToUse = feverImpactVFXPrefab;
        }
        FireProjectile(attacker, target, damage, spawnPosition, attacker.rotation, vfxToUse);
        
        // 2. Vérifier si on est en Mode Fever et tirer les projectiles supplémentaires
         if (attackerUnit != null && attackerUnit.IsFeverActive)
        {
            int extraProjectiles = attackerUnit.ActiveFeverBuffs.ExtraProjectiles;
            if (extraProjectiles > 0)
            {
                if (showAttackLogs) Debug.Log($"[{attacker.name}] Mode Fever: Tir de {extraProjectiles} projectiles en plus.");
                
                for (int i = 0; i < extraProjectiles; i++)
                {
                    // On attend AVANT de tirer le prochain projectile
                    if (feverProjectileDelay > 0)
                    {
                        yield return new WaitForSeconds(feverProjectileDelay);
                    }

                    // On ne tire que si la cible existe toujours
                    if (target != null && target.gameObject.activeInHierarchy)
                    {
                         // On tire simplement droit devant, sans calcul d'angle
                         FireProjectile(attacker, target, damage, spawnPosition, attacker.rotation, vfxToUse);
                    }
                    else
                    {
                        // Si la cible disparaît au milieu de la rafale, on arrête
                        break; 
                    }
                }
            }
        }


        float remainingDuration = duration - fireAnimationDelay;
        if (remainingDuration > 0)
        {
            yield return new WaitForSeconds(remainingDuration);
        }
    }
        private void FireProjectile(Transform attacker, Transform target, int damage, Vector3 spawnPosition, Quaternion spawnRotation, GameObject impactVfx)
    {
        if (showAttackLogs) Debug.Log($"[{attacker.name}] RangedAttack: Instanciation du projectile à {spawnPosition} vers {target.name}.");
        GameObject projectileGO = Instantiate(projectilePrefab, spawnPosition, spawnRotation);
        Projectile projectileScript = projectileGO.GetComponent<Projectile>();

        if (projectileScript == null)
        {
            Debug.LogError($"[{attacker.name}] RangedAttack: Le prefab du projectile '{projectilePrefab.name}' ne contient pas de script Projectile !");
            Destroy(projectileGO);
            return;
        }
        
        projectileScript.Initialize(target, damage, projectileSpeed, impactVfx, attacker.GetComponent<Unit>());
    }
    public bool CanAttack(Transform attacker, Transform target, float attackRange)
    {
        if (showAttackLogs)
        {
             Debug.Log($"[{attacker.name}] RangedAttack: CanAttack {target.name} - On se fie à la détection de portée par tuile de l'unité.");
        }
        return true;
    }
}

// --- FILE: Scripts/Behaviours/IAttack.cs ---
using UnityEngine;
using System.Collections;

public interface IAttack
{
    IEnumerator PerformAttack(Transform attacker, Transform target, int damage, float duration);
    bool CanAttack(Transform attacker, Transform target, float attackRange);
}

// --- FILE: Scripts/Behaviours/IMovement.cs ---
using UnityEngine;
using System.Collections;

public interface IMovement
{
    IEnumerator MoveToTile(Transform unitTransform,
        Vector3 startPos,
        Vector3 targetPos,
        float duration);
}

// --- FILE: Scripts/Buildings/AllyBuilding.cs ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.UI;
using TMPro;
using Sirenix.OdinInspector;

public class PlayerBuilding : Building
{
    [System.Serializable]
    public class UnitSequence
    {
        [ListDrawerSettings(ShowFoldout = true)]
        public List<KeyCode> sequence;
        public GameObject unitPrefab;
    }

    [SerializeField, ListDrawerSettings(ShowFoldout = true)]
    private List<UnitSequence> unitSequences;

    private int beatCounter = 0;

    private bool isGoldGenerationActive = false;
    // --- FIN NOUVEAU ---

    [Header("Visual Feedback")]
    [SerializeField] private GameObject healthBarPrefab;
    [SerializeField] private float healthBarOffset = 1.5f;
    [SerializeField] private bool showHealthBar = true;

    // Health bar components
    private GameObject healthBarInstance;
    private Slider healthBarSlider;
    private TextMeshProUGUI healthText;

    // Effects for damage and repair
    [Header("Effects")]
    [SerializeField] private GameObject damageVFXPrefab;
    [SerializeField] private GameObject repairVFXPrefab;
    [SerializeField] private AudioClip damageSound;
    [SerializeField] private AudioClip repairSound;

    // Audio source for SFX
    private AudioSource audioSource;

    // NOUVEAU: Système de cases de réserves
    [Header("Reserve System")]
    [Tooltip("Tiles linked to this building where units can be positioned in defensive mode")]
    [SerializeField] private List<Tile> reserveTiles = new List<Tile>();
    
    [Tooltip("Visual indicator for reserve tiles in scene view")]
    [SerializeField] private bool showReserveTilesGizmos = true;
    
    [SerializeField] private Color reserveTileGizmoColor = Color.cyan;

    // Dictionnaire pour tracker quelles cases de réserves sont occupées
    private Dictionary<Tile, Unit> occupiedReserveTiles = new Dictionary<Tile, Unit>();

    private void OnEnable()
    {
        // --- MODIFICATION : Utilisation de MusicManager ---
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat += HandleBeat;
        }
        // --- NOUVEAU ---
        // S'abonner à l'événement de fin du tutoriel
        TutorialManager.OnTutorialCompleted += EnableGoldGeneration;
        // --- FIN NOUVEAU ---
    }

    private void OnDisable()
    {
        // --- MODIFICATION : Utilisation de MusicManager ---
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= HandleBeat;
        }
        if (TutorialManager.Instance != null) // Bonne pratique
        {
            TutorialManager.OnTutorialCompleted -= EnableGoldGeneration;
        }
        // --- FIN MODIFIÉ ---
    }

    protected override IEnumerator Start()
    {
        // Set the team to Player right at the start
        SetTeam(TeamType.Player);

        // Initialize audio
        audioSource = gameObject.AddComponent<AudioSource>();
        audioSource.spatialBlend = 1.0f; // 3D sound
        audioSource.rolloffMode = AudioRolloffMode.Linear;
        audioSource.maxDistance = 20f;

        // Setup health bar if needed
        if (showHealthBar && healthBarPrefab != null)
        {
            CreateHealthBar();
        }

        // Subscribe to the damage event
        Building.OnBuildingDamaged += OnAnyBuildingDamaged;

        // --- NOUVEAU ---
        // Vérifier l'état du tutoriel au démarrage. Si le manager n'existe pas ou que le tuto est déjà fini, on active l'or.
        if (TutorialManager.Instance == null || !TutorialManager.IsTutorialActive)
        {
            isGoldGenerationActive = true;
        }
        // --- FIN NOUVEAU ---

        yield return StartCoroutine(base.Start());

        // Initialize reserve tiles system
        InitializeReserveTiles();

        Debug.Log($"[ALLY BUILDING] {gameObject.name} initialized as {Team} team with {reserveTiles.Count} reserve tiles!");
    }

    // --- NOUVELLE MÉTHODE ---
    /// <summary>
    /// Cette méthode est appelée par l'événement OnTutorialCompleted du TutorialManager.
    /// </summary>
    private void EnableGoldGeneration()
    {
        Debug.Log($"[{gameObject.name}] Tutoriel terminé. La génération d'or est maintenant activée.");
        isGoldGenerationActive = true;

        // On peut aussi réinitialiser le compteur pour que la première génération
        // ait lieu après le délai normal suivant la fin du tuto.
        beatCounter = 0;
    }
    // --- FIN NOUVELLE MÉTHODE ---

    private void HandleBeat(float beatDuration)
    {
        if (!isGoldGenerationActive)
        {
            return;
        }

        beatCounter++;
        if (beatCounter >= Stats.goldGenerationDelay)
        {
            if (Stats.goldGeneration > 0)
            {
                GoldController.Instance.AddGold(Stats.goldGeneration);
            }
            beatCounter = 0;
        }
    }

    #region Reserve Tiles System

    private void InitializeReserveTiles()
    {
        occupiedReserveTiles.Clear();
        foreach (Tile tile in reserveTiles)
        {
            if (tile != null)
            {
                occupiedReserveTiles[tile] = null;
            }
        }
    }

    /// <summary>
    /// Trouve une case de réserve libre pour une unité spécifique.
    /// Si l'unité occupe déjà une case de réserve de ce bâtiment, cette case est retournée.
    /// </summary>
    public Tile GetAvailableReserveTileForUnit(Unit unitSeekingReserve)
    {
        if (unitSeekingReserve == null) return null;

        // 1. Vérifier si l'unité occupe déjà une des cases de réserve de CE bâtiment
        foreach (var kvp in occupiedReserveTiles)
        {
            if (kvp.Value == unitSeekingReserve && kvp.Key != null && reserveTiles.Contains(kvp.Key))
            {
                // L'unité est déjà sur une de nos cases de réserve, elle est "disponible" pour elle-même.
                return kvp.Key;
            }
        }

        // 2. Sinon, chercher une case de réserve réellement libre.
        foreach (Tile tile in reserveTiles)
        {
            // IsReserveTileAvailable vérifie si la tuile est dans reserveTiles,
            // n'est pas occupée physiquement (par une autre unité sur Tile.currentUnit),
            // et est marquée comme libre dans notre dictionnaire occupiedReserveTiles.
            if (tile != null && IsReserveTileAvailable(tile))
            {
                return tile;
            }
        }
        return null; // Aucune case de réserve disponible pour cette unité.
    }

    /// <summary>
    /// Vérifie si une case de réserve spécifique est disponible de manière générale (non assignée et non occupée physiquement).
    /// </summary>
    public bool IsReserveTileAvailable(Tile tile)
    {
        if (tile == null || !reserveTiles.Contains(tile)) // Doit être une de nos cases de réserve connues
            return false;

        // Vérifier l'occupation physique sur la tuile elle-même (par une *autre* unité que celle qui pourrait être dans notre dictionnaire)
        if (tile.currentUnit != null && (!occupiedReserveTiles.ContainsKey(tile) || occupiedReserveTiles[tile] != tile.currentUnit) )
        {
            return false; // Occupée physiquement par une unité non enregistrée ici ou une autre unité
        }
        if (tile.currentBuilding != null && tile.currentBuilding != this) // Occupée par un autre bâtiment
        {
            return false;
        }
        if (tile.currentEnvironment != null && tile.currentEnvironment.IsBlocking) // Environnement bloquant
        {
            return false;
        }

        return occupiedReserveTiles.ContainsKey(tile) && occupiedReserveTiles[tile] == null;
    }

    public bool AssignUnitToReserveTile(Unit unit, Tile newReserveTile)
    {
        if (unit == null || newReserveTile == null || !reserveTiles.Contains(newReserveTile))
        {
            Debug.LogWarning($"[PlayerBuilding:{name}] AssignUnitToReserveTile: Conditions non remplies (Unit, newReserveTile ou tile pas dans la liste). Unit: {unit?.name}, Tile: {newReserveTile?.name}", this);
            return false;
        }

        Tile previousTileForThisUnit = null;
        foreach(var kvp in occupiedReserveTiles)
        {
            if (kvp.Value == unit && kvp.Key != newReserveTile)
            {
                previousTileForThisUnit = kvp.Key;
                break;
            }
        }

        if (previousTileForThisUnit != null)
        {
            occupiedReserveTiles[previousTileForThisUnit] = null;
            Debug.Log($"[PlayerBuilding:{name}] Unit {unit.name} a libéré son ancienne case de réserve {previousTileForThisUnit.name} sur ce bâtiment.", this);
        }

        if (occupiedReserveTiles.ContainsKey(newReserveTile))
        {
            if (occupiedReserveTiles[newReserveTile] == null || occupiedReserveTiles[newReserveTile] == unit)
            {
                // La case est libre OU déjà assignée à cette unité (parfait, on confirme/réassigne).
                occupiedReserveTiles[newReserveTile] = unit;
                Debug.Log($"[PlayerBuilding:{name}] Unit {unit.name} assignée à la case de réserve ({newReserveTile.column},{newReserveTile.row}).", this);
                return true;
            }
            else
            {
                // La case est occupée par une AUTRE unité.
                Debug.LogWarning($"[PlayerBuilding:{name}] AssignUnitToReserveTile: La nouvelle case {newReserveTile.name} est déjà occupée par {occupiedReserveTiles[newReserveTile].name}. Impossible d'assigner {unit.name}.", this);
                return false;
            }
        }
        else
        {
            // La tuile de réserve n'était même pas dans notre dictionnaire, ce qui est étrange si reserveTiles.Contains(newReserveTile) est vrai.
            // Cela peut arriver si InitializeReserveTiles n'a pas inclus toutes les tuiles de la liste reserveTiles.
            Debug.LogError($"[PlayerBuilding:{name}] AssignUnitToReserveTile: La case {newReserveTile.name} est dans reserveTiles mais pas dans occupiedReserveTiles. Problème d'initialisation probable.", this);
            return false;
        }
    }

    public void ReleaseReserveTile(Tile reserveTile, Unit unit)
    {
        if (unit == null || reserveTile == null) return;

        if (occupiedReserveTiles.ContainsKey(reserveTile) && occupiedReserveTiles[reserveTile] == unit)
        {
            occupiedReserveTiles[reserveTile] = null;
            Debug.Log($"[PlayerBuilding:{name}] Case de réserve ({reserveTile.column},{reserveTile.row}) explicitement libérée par/pour {unit.name}.", this);
        }
    }

    public bool HasAvailableReserveTiles()
    {
        foreach (Tile tile in reserveTiles)
        {
            // Utilise la vérification générale IsReserveTileAvailable
            if (tile != null && IsReserveTileAvailable(tile))
            {
                return true;
            }
        }
        return false;
    }

    public List<Tile> GetReserveTiles()
    {
        return new List<Tile>(reserveTiles); // Retourne une copie
    }
    #endregion
    private bool AreSequencesEqual(List<KeyCode> seq1, List<KeyCode> seq2)
    {
        if (seq1.Count != seq2.Count) return false;
        for (int i = 0; i < seq1.Count; i++)
        {
            if (seq1[i] != seq2[i]) return false;
        }
        return true;
    }

    private void ProduceUnit(GameObject unitPrefab)
    {
        if (unitPrefab == null)
        {
            Debug.LogError("Unit prefab is null!");
            return;
        }

        List<Tile> adjacentTiles = HexGridManager.Instance.GetAdjacentTiles(occupiedTile);
        foreach (Tile tile in adjacentTiles)
        {
            if (!tile.IsOccupied)
            {
                Instantiate(unitPrefab, tile.transform.position, Quaternion.identity);
                return;
            }
        }
        Debug.LogWarning("No available adjacent tiles to spawn unit!");
    }

    private void CreateHealthBar()
    {
        healthBarInstance = Instantiate(healthBarPrefab, transform);
        healthBarInstance.transform.localPosition = Vector3.up * healthBarOffset;
        healthBarInstance.transform.rotation = Quaternion.Euler(30, 0, 0);
        healthBarSlider = healthBarInstance.GetComponentInChildren<Slider>();
        healthText = healthBarInstance.GetComponentInChildren<TextMeshProUGUI>();
        UpdateHealthBar();
    }

    private void UpdateHealthBar()
    {
        if (healthBarSlider != null)
        {
            healthBarSlider.maxValue = MaxHealth;
            healthBarSlider.value = CurrentHealth;
        }

        if (healthText != null)
        {
            healthText.text = $"{CurrentHealth}/{MaxHealth}";
        }
    }

    private void OnAnyBuildingDamaged(Building building, int newHealth, int damage)
    {
        if (building != this) return;
        UpdateHealthBar();
        PlayDamageEffects(damage);
    }

    private void PlayDamageEffects(int damage)
    {
        if (damageSound != null && audioSource != null)
        {
            audioSource.PlayOneShot(damageSound);
        }
        if (damageVFXPrefab != null)
        {
            GameObject vfx = Instantiate(
                damageVFXPrefab,
                transform.position + Vector3.up,
                Quaternion.identity
            );

            // Auto-destroy the VFX after 2 seconds
            Destroy(vfx, 2.0f);
        }
    }

    public void Repair(int amount)
    {
        if (CurrentHealth >= MaxHealth)
            return;

        // Calculate new health
        int newHealth = Mathf.Min(CurrentHealth + amount, MaxHealth);
        int actualRepair = newHealth - CurrentHealth;

        if (actualRepair <= 0)
            return;

        // Update health using the protected method from the base class
        SetCurrentHealth(newHealth);

        if (debugBuildingCombat)
        {
            Debug.Log($"[ALLY BUILDING] {gameObject.name} repaired for {actualRepair}. Health: {CurrentHealth}/{MaxHealth}");
        }

        // Play repair effects
        PlayRepairEffects(actualRepair);

        // Update health bar
        UpdateHealthBar();
    }

    private void PlayRepairEffects(int amount)
    {
        // Play repair sound
        if (repairSound != null && audioSource != null)
        {
            audioSource.PlayOneShot(repairSound);
        }

        // Spawn repair VFX
        if (repairVFXPrefab != null)
        {
            GameObject vfx = Instantiate(
                repairVFXPrefab,
                transform.position + Vector3.up,
                Quaternion.identity
            );

            // Auto-destroy the VFX after 2 seconds
            Destroy(vfx, 2.0f);
        }
    }

    // Override team change visuals
    protected override void OnTeamChanged(TeamType newTeam)
    {
        base.OnTeamChanged(newTeam);

        // Visual feedback for team change
        if (newTeam == TeamType.Player)
        {
            // For example, if you want to tint the building blue for player team
            Renderer[] renderers = GetComponentsInChildren<Renderer>();
            foreach (Renderer renderer in renderers)
            {
                // Apply a slight blue tint to materials
                foreach (Material material in renderer.materials)
                {
                    Color originalColor = material.color;
                    Color tintedColor = Color.Lerp(originalColor, Color.blue, 0.3f);
                    material.color = tintedColor;
                }
            }
        }
    }

    private void OnDrawGizmosSelected()
    {
        if (!showReserveTilesGizmos || reserveTiles == null) return;

        Gizmos.color = reserveTileGizmoColor;
        
        foreach (Tile tile in reserveTiles)
        {
            if (tile != null)
            {
                // Dessiner une sphère wireframe pour chaque case de réserve
                Gizmos.DrawWireSphere(tile.transform.position + Vector3.up * 0.5f, 0.3f);
                
                // Dessiner une ligne entre le bâtiment et la case de réserve
                Gizmos.DrawLine(transform.position + Vector3.up, tile.transform.position + Vector3.up * 0.5f);
            }
        }
    }

    public override void OnDestroy()
    {
        // Unsubscribe from events
        Building.OnBuildingDamaged -= OnAnyBuildingDamaged;

        if (TutorialManager.Instance != null)
        {
            TutorialManager.OnTutorialCompleted -= EnableGoldGeneration;
        }

        // Appeler la méthode de la classe de base est une bonne pratique.
        base.OnDestroy();
    }

    public override void TakeDamage(int damage, Unit attacker = null)
    {
        base.TakeDamage(damage, attacker);

        if (attacker != null)
        {
            AlertReserveUnitsOfAttack(attacker);
        }
    }

    private void AlertReserveUnitsOfAttack(Unit attacker)
    {
        foreach (var kvp in occupiedReserveTiles)
        {
            Unit unit = kvp.Value;
            if (unit != null)
            {
                if (unit is AllyUnit ally)
                {
                    ally.OnDefendedBuildingAttacked(this, attacker);
                }
            }
        }
    }
}


// --- FILE: Scripts/Buildings/BossDamageBuilding.cs ---
// Fichier: Scripts/Buildings/BossDamageBuilding.cs
using UnityEngine;

public class BossDamageBuilding : NeutralBuilding
{
    [Header("Boss Targeting")]
    [Tooltip("Faites glisser ici le Boss que ce bâtiment doit attaquer.")]
    [SerializeField] private BossUnit targetBoss; // La nouvelle variable pour la cible !

    [Header("Boss Damage Settings")]
    [Tooltip("Le pourcentage de la vie maximale du boss à infliger comme dégâts lors de la capture.")]
    [Range(0f, 100f)]
    [SerializeField] private float damagePercentage = 10f;

    /// <summary>
    /// Cette méthode est appelée automatiquement lorsque l'équipe du bâtiment change.
    /// </summary>
    protected override void OnTeamChanged(TeamType newTeam)
    {
        base.OnTeamChanged(newTeam);

        // Si le bâtiment est capturé par le joueur
        if (newTeam == TeamType.Player)
        {
            // On vérifie si une cible a été assignée dans l'inspecteur
            if (targetBoss != null)
            {
                Debug.Log($"[BossDamageBuilding] Bâtiment capturé ! Inflige {damagePercentage}% de dégâts au boss '{targetBoss.name}'.");
                // On appelle la méthode pour infliger des dégâts sur notre cible spécifique
                targetBoss.TakePercentageDamage(damagePercentage);
            }
            else
            {
                // Message d'erreur si on a oublié d'assigner le boss dans l'éditeur
                Debug.LogError($"[BossDamageBuilding] Le bâtiment '{this.name}' a été capturé, mais aucun 'Target Boss' n'a été assigné dans l'inspecteur !");
            }
        }
    }
}

// --- FILE: Scripts/Buildings/Building.cs ---
using UnityEngine;
using System.Collections;
using Sirenix.OdinInspector;

public abstract class Building : MonoBehaviour
{
    [Header("Team Settings")]
    [SerializeField] private TeamType _team = TeamType.Neutral;
    protected Tile occupiedTile;
    [SerializeField] private float yOffset = 0f; // Adjustable vertical offset in the editor
    private bool isAttached = false;

    [Header("Combat")]
    [SerializeField] protected bool debugBuildingCombat = true;
    public virtual bool IsTargetable => true; // Most buildings should be targetable by default

    [Header("Effects")]
    [SerializeField] protected GameObject destructionVFXPrefab; // Prefab for destruction visual effect
    [SerializeField] protected float destructionVFXDuration = 3f; // Duration in seconds before the VFX is destroyed

    // Reference to the BuildingStats asset.
    [InlineEditor(InlineEditorModes.FullEditor)]
    [SerializeField] private BuildingStats buildingStats;

    // Public getters and private health tracking
    private int _currentHealth;
    public int CurrentHealth => _currentHealth;
    public int MaxHealth => buildingStats != null ? buildingStats.health : 0;
    public int Defense => buildingStats != null ? buildingStats.defense : 0;
    public int GoldGeneration => buildingStats != null ? buildingStats.goldGeneration : 0;
    public int GoldGenerationDelay => buildingStats != null ? buildingStats.goldGenerationDelay : 1;
    public int Garrison => buildingStats != null ? buildingStats.Garrison : 0;

    public TeamType Team => _team;

    // Event for building damage and destruction
    public delegate void BuildingHealthChangedHandler(Building building, int newHealth, int damage);
    public static event BuildingHealthChangedHandler OnBuildingDamaged;
    public static event System.Action<Building, Unit> OnBuildingAttackedByUnit; // Building attaqué, par quelle Unit

    public delegate void BuildingDestroyedHandler(Building building);
    public static event BuildingDestroyedHandler OnBuildingDestroyed;

    public delegate void BuildingTeamChangedHandler(Building building, TeamType oldTeam, TeamType newTeam);
    public static event BuildingTeamChangedHandler OnBuildingTeamChangedGlobal; // Événement global

    // Protected accessor for use in derived classes.
    protected BuildingStats Stats => buildingStats;

    protected virtual IEnumerator Start()
    {
        // Initialize health
        if (buildingStats != null)
        {
            _currentHealth = buildingStats.health;
            Debug.Log($"[BUILDING] {gameObject.name} initialized with {_currentHealth} health");
        }
        else
        {
            Debug.LogError($"[BUILDING] {gameObject.name} has no building stats assigned!");
        }

        Debug.Log($"[BUILDING] {gameObject.name} starting attachment process at position: {transform.position}");

        // Wait for the HexGridManager to initialize if needed
        while (HexGridManager.Instance == null)
        {
            yield return new WaitForSeconds(0.1f);
        }

        // Try to find and attach to the nearest tile
        while (!isAttached)
        {
            Tile nearestTile = HexGridManager.Instance.GetClosestTile(transform.position);
            if (nearestTile != null)
            {
                if (!nearestTile.IsOccupied)
                {
                    AttachToTile(nearestTile);
                    isAttached = true;
                    break;
                }
            }
            yield return new WaitForSeconds(0.2f);
        }
    }

    // Method to handle incoming damage
    public virtual void TakeDamage(int damage, Unit attacker = null)
    {
        // Calculate damage after defense
        int actualDamage = Mathf.Max(1, damage - Defense);
        _currentHealth -= actualDamage;

        if (debugBuildingCombat)
        {
            Debug.Log($"[BUILDING] {gameObject.name} took {actualDamage} damage (after {Defense} defense). Health: {_currentHealth}/{MaxHealth}");
            Debug.Log($"[BUILDING] Attacker: {attacker?.name ?? "None"}");  
        }

        // Trigger the damage event
        OnBuildingDamaged?.Invoke(this, _currentHealth, actualDamage);
        if (attacker != null)
        {
            OnBuildingAttackedByUnit?.Invoke(this, attacker);
        }
        // Check if building is destroyed
        if (_currentHealth <= 0)
        {
            Die();
        }
        
    }

    public virtual void SetTeam(TeamType newTeam)
    {
        if (_team != newTeam)
        {
            TeamType oldTeam = _team; // Stocker l'ancienne équipe
            _team = newTeam;
            OnTeamChanged(newTeam); // Appel à la méthode virtuelle pour la logique spécifique à la classe dérivée

            // Déclencher l'événement global de changement d'équipe
            OnBuildingTeamChangedGlobal?.Invoke(this, oldTeam, newTeam);
            if(debugBuildingCombat) Debug.Log($"[{gameObject.name}] Global Team Change Event Invoked: {oldTeam} -> {newTeam}");
        }
    }

    // Virtual method for team change events
    protected virtual void OnTeamChanged(TeamType newTeam)
    {
        // Override in derived classes if you need special behavior
        if (debugBuildingCombat)
        {
            Debug.Log($"[BUILDING] {gameObject.name} changed to team: {newTeam}");
        }
    }

    // Method for destruction logic
    protected virtual void Die()
    {
        if (debugBuildingCombat)
        {
            Debug.Log($"[BUILDING] {gameObject.name} has been destroyed!");
        }

        // Trigger the destroyed event
        OnBuildingDestroyed?.Invoke(this);

        // Play destruction VFX if assigned
        if (destructionVFXPrefab != null)
        {
            GameObject vfx = Instantiate(destructionVFXPrefab, transform.position, Quaternion.identity);
            Destroy(vfx, destructionVFXDuration); // Destroy the VFX object after the specified duration
        }

        // Destroy the gameObject
        Destroy(gameObject);
    }

    protected void AttachToTile(Tile tile)
    {
        occupiedTile = tile;

        // Teleport to the exact center of the tile first
        transform.position = tile.transform.position + new Vector3(0f, yOffset, 0f);

        // Then make it a child with zero local position (except for y offset)
        transform.SetParent(tile.transform, false);
        transform.localPosition = new Vector3(0f, yOffset, 0f);

        Debug.Log($"[BUILDING] {gameObject.name} final position after attachment: {transform.position}");

        // Assign this building to the tile
        tile.AssignBuilding(this);
    }

    public virtual void OnDestroy()
    {
        if (occupiedTile != null)
        {
            occupiedTile.RemoveBuilding();
        }
    }

    // Helper method to get the tile this building occupies
    public Tile GetOccupiedTile()
    {
        return occupiedTile;
    }

    protected void SetCurrentHealth(int newHealth)
    {
        int oldHealth = _currentHealth;
        _currentHealth = Mathf.Clamp(newHealth, 0, MaxHealth);

        // If health changed, invoke the damage event
        if (oldHealth != _currentHealth)
        {
            int difference = oldHealth - _currentHealth;
            if (difference > 0)
            {
                // Damage was taken
                OnBuildingDamaged?.Invoke(this, _currentHealth, difference);
            }

            // Check if building is destroyed
            if (_currentHealth <= 0)
            {
                Die();
            }
        }
    }

// Method to heal the building
    public virtual void Heal(int amount)
    {
        if (amount <= 0 || _currentHealth >= MaxHealth)
            return;

        int newHealth = Mathf.Min(_currentHealth + amount, MaxHealth);
        int actualHeal = newHealth - _currentHealth;

        if (debugBuildingCombat)
        {
            Debug.Log($"[BUILDING] {gameObject.name} healed for {actualHeal}. Health: {newHealth}/{MaxHealth}");
        }

        // Set the new health
        SetCurrentHealth(newHealth);
    }
}


// --- FILE: Scripts/Buildings/BuildingSelectionFeedback.cs ---
﻿using UnityEngine;

public enum OutlineState { Default, Hover, Selected }

public class BuildingSelectionFeedback : MonoBehaviour
{
    private OutlineState _currentState;
    public OutlineState CurrentState => _currentState;

    private Renderer _renderer;
    private MaterialPropertyBlock _propertyBlock;

    private Color _originalOutlineColor;
    private float _originalOutlineSize;

    private static readonly int OutlineColorID = Shader.PropertyToID("_OutlineColor");
    private static readonly int OutlineSizeID = Shader.PropertyToID("_OutlineSize");

    // Couleurs et valeurs pour les nouveaux états
    private static readonly Color HoverColor = Color.white;
    private static readonly Color SelectedColor = Color.red;
    private const float HighlightSize = 20f;

    void Awake()
    {
        _renderer = GetComponent<Renderer>();
        _propertyBlock = new MaterialPropertyBlock();
        _currentState = OutlineState.Default; // Initialiser l'état

        if (_renderer == null)
        {
            Debug.LogError("Aucun composant Renderer trouvé. L'outline ne fonctionnera pas.", this);
            enabled = false;
            return;
        }

        if (_renderer.sharedMaterial.HasProperty(OutlineColorID))
        {
            _originalOutlineColor = _renderer.sharedMaterial.GetColor(OutlineColorID);
            _originalOutlineSize = _renderer.sharedMaterial.GetFloat(OutlineSizeID);
        }
        else
        {
            Debug.LogWarning($"Le matériau sur {gameObject.name} n'a pas les propriétés d'outline.", this);
            _originalOutlineColor = Color.black;
            _originalOutlineSize = 0f;
        }
    }

    /// <summary>
    /// Méthode de contrôle unique pour changer l'état visuel de l'outline.
    /// C'est le seul point d'entrée pour modifier l'apparence depuis d'autres scripts.
    /// </summary>
    /// <param name="newState">Le nouvel état à appliquer.</param>
    public void SetOutlineState(OutlineState newState)
    {
        // Optimisation : ne rien faire si l'état demandé est déjà l'état actuel.
        if (newState == _currentState) return;

        _renderer.GetPropertyBlock(_propertyBlock);

        // Appliquer les bonnes propriétés en fonction de l'état demandé.
        switch (newState)
        {
            case OutlineState.Hover:
                _propertyBlock.SetColor(OutlineColorID, HoverColor);
                _propertyBlock.SetFloat(OutlineSizeID, HighlightSize);
                break;

            case OutlineState.Selected:
                _propertyBlock.SetColor(OutlineColorID, SelectedColor);
                _propertyBlock.SetFloat(OutlineSizeID, HighlightSize);
                break;

            case OutlineState.Default:
            default:
                _propertyBlock.SetColor(OutlineColorID, _originalOutlineColor);
                _propertyBlock.SetFloat(OutlineSizeID, _originalOutlineSize);
                break;
        }

        _renderer.SetPropertyBlock(_propertyBlock);
        _currentState = newState; // Mettre à jour l'état actuel
    }
}

// --- FILE: Scripts/Buildings/EnemyBuilding.cs ---
using UnityEngine;
using System.Collections;
using UnityEngine.UI;
using TMPro;

public class EnemyBuilding : Building
{
    [Header("Visual Feedback")]
    [SerializeField] private GameObject healthBarPrefab;
    [SerializeField] private float healthBarOffset = 1.5f;
    [SerializeField] private bool showHealthBar = true;

    // Health bar components
    private GameObject healthBarInstance;
    private Slider healthBarSlider;
    private TextMeshProUGUI healthText;

    // Override for targetability
    public override bool IsTargetable => true;

    // Effects for damage and destruction
    [Header("Effects")]
    [SerializeField] private GameObject damageVFXPrefab;
    [SerializeField] private AudioClip damageSound;
    [SerializeField] private AudioClip destructionSound;

    // Audio source for SFX
    private AudioSource audioSource;

    protected override IEnumerator Start()
    {
        // Set the team to Enemy right at the start
        SetTeam(TeamType.Enemy);

        // Rest of your existing start method
        audioSource = gameObject.AddComponent<AudioSource>();
        audioSource.spatialBlend = 1.0f; // 3D sound
        audioSource.rolloffMode = AudioRolloffMode.Linear;
        audioSource.maxDistance = 20f;

        // Setup health bar if needed
        if (showHealthBar && healthBarPrefab != null)
        {
            CreateHealthBar();
        }

        // Subscribe to the damage event
        Building.OnBuildingDamaged += OnAnyBuildingDamaged;

        // Call base implementation to handle tile attachment, etc.
        yield return StartCoroutine(base.Start());

        Debug.Log($"[ENEMY BUILDING] {gameObject.name} initialized as {Team} team and ready for combat!");
    }

// Also add this to visualize the team change
    protected override void OnTeamChanged(TeamType newTeam)
    {
        base.OnTeamChanged(newTeam);

        // Visual feedback for team change - you could update materials/colors here
        if (newTeam == TeamType.Enemy)
        {
            // For example, if you want to tint the building red for enemy team
            Renderer[] renderers = GetComponentsInChildren<Renderer>();
            foreach (Renderer renderer in renderers)
            {
                // Apply a slight red tint to materials
                foreach (Material material in renderer.materials)
                {
                    Color originalColor = material.color;
                    Color tintedColor = Color.Lerp(originalColor, Color.red, 0.3f);
                    material.color = tintedColor;
                }
            }
        }
    }

    private void CreateHealthBar()
    {
        // Instantiate the health bar
        healthBarInstance = Instantiate(healthBarPrefab, transform);
        healthBarInstance.transform.localPosition = Vector3.up * healthBarOffset;

        // Make the health bar face the camera
        healthBarInstance.transform.rotation = Quaternion.Euler(30, 0, 0);

        // Get the slider and text components
        healthBarSlider = healthBarInstance.GetComponentInChildren<Slider>();
        healthText = healthBarInstance.GetComponentInChildren<TextMeshProUGUI>();

        // Initialize the health bar values
        UpdateHealthBar();
    }

    private void UpdateHealthBar()
    {
        if (healthBarSlider != null)
        {
            healthBarSlider.maxValue = MaxHealth;
            healthBarSlider.value = CurrentHealth;
        }

        if (healthText != null)
        {
            healthText.text = $"{CurrentHealth}/{MaxHealth}";
        }
    }

    // Event handler for damage
    private void OnAnyBuildingDamaged(Building building, int newHealth, int damage)
    {
        // Only respond to events for this building
        if (building != this) return;

        // Update health bar
        UpdateHealthBar();

        // Play damage effects
        PlayDamageEffects(damage);
    }

    private void PlayDamageEffects(int damage)
    {
        // Play damage sound
        if (damageSound != null && audioSource != null)
        {
            audioSource.PlayOneShot(damageSound);
        }

        // Spawn damage VFX
        if (damageVFXPrefab != null)
        {
            GameObject vfx = Instantiate(
                damageVFXPrefab,
                transform.position + Vector3.up,
                Quaternion.identity
            );

            // Auto-destroy the VFX after 2 seconds
            Destroy(vfx, 2.0f);
        }

        // Optional: Show damage number as floating text
        ShowDamageNumber(damage);
    }

    private void ShowDamageNumber(int damage)
    {
        // You would implement floating damage text here
        // This is just a placeholder - you might want to create a custom component for this
        Debug.Log($"[ENEMY BUILDING] {gameObject.name} took {damage} damage!");
    }

    // Override die method to add special effects
    protected override void Die()
    {
        Debug.Log($"[ENEMY BUILDING] {gameObject.name} has been destroyed!");

        // Play destruction sound
        if (destructionSound != null && audioSource != null)
        {
            AudioSource.PlayClipAtPoint(destructionSound, transform.position);
        }
        // Call base implementation to handle destruction logic
        base.Die();
    }

    public override void OnDestroy()
    {
        // Unsubscribe from events
        Building.OnBuildingDamaged -= OnAnyBuildingDamaged;

        // Call base implementation
        base.OnDestroy();
    }
}

// --- FILE: Scripts/Buildings/EnnemyBuildingBlackboardInitializer.cs ---
﻿using UnityEngine;
using Unity.Behavior;

// S'assure que ce script s'exécute avant le Behavior Graph
[DefaultExecutionOrder(-100)] 
public class EnnemyBuildingBlackboardInitializer : MonoBehaviour
{
    // La clé que nous utiliserons dans le Blackboard. C'est plus propre que "SelfUnit".
    public const string BB_SELF_BUILDING = "SelfBuilding";

    void Awake()
    {
        var agent = GetComponent<BehaviorGraphAgent>();
        var building = GetComponent<Building>(); // On récupère le composant Building

        if (agent == null || agent.BlackboardReference == null || building == null)
        {
            Debug.LogError($"[{gameObject.name}] BuildingBlackboardInitializer: " +
                           "Composants critiques manquants (Agent, Blackboard ou Building)!", gameObject);
            return;
        }

        // On cherche la variable "SelfBuilding" de type Building dans le Blackboard
        if (agent.BlackboardReference.GetVariable(BB_SELF_BUILDING, out BlackboardVariable<Building> bbSelfBuilding))
        {
            // On lui assigne notre propre référence de bâtiment.
            bbSelfBuilding.Value = building;
            Debug.Log($"[{gameObject.name}] Initializer: Variable Blackboard '{BB_SELF_BUILDING}' initialisée avec succès.", gameObject);
        }
        else
        {
            Debug.LogError($"[{gameObject.name}] Initializer: La variable Blackboard '{BB_SELF_BUILDING}' " +
                           "(de type Building) est INTROUVABLE sur l'asset Blackboard. Veuillez la créer.", gameObject);
        }
    }
}

// --- FILE: Scripts/Buildings/NeutralBuilding.cs ---
// Fichier: Scripts/Buildings/NeutralBuilding.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class NeutralBuilding : Building
{
    [Header("Capture Settings")]
    [Tooltip("Can this building be captured?")]
    [SerializeField] private bool canBeCaptured = true;
    [Tooltip("Total 'beat efforts' required to capture this building.")]
    [SerializeField] private int beatsToCapture = 12;

    private float currentCaptureProgressPoints = 0f;
    private TeamType teamActuellementEnCapture = TeamType.Neutral;
    private HashSet<Unit> unitesQuiCapturentActuellement = new HashSet<Unit>();

    [Header("Effects (Optional)")]
    [SerializeField] private GameObject captureInProgressVFXPrefab;
    [SerializeField] private GameObject captureCompletedVFXPrefab; // Prefab for visual effect when capture is completed
    [SerializeField] private float captureCompletedVFXDuration = 3f; // Duration in seconds before the VFX is destroyed
    [Tooltip("Vertical offset for the capture completed VFX spawn position relative to the building")]
    [SerializeField] private float captureVFXYOffset = 2f;
    [SerializeField] private AudioClip captureProgressSound;
    [SerializeField] private AudioClip captureCompleteSound;

    [Header("Team Colors")]
    [SerializeField] private Color neutralColor = Color.grey;
    [SerializeField] private Color playerColor = new Color(0.8f, 0.2f, 0.2f);
    [SerializeField] private Color enemyColor = new Color(0.2f, 0.4f, 0.8f);
    [SerializeField] private float colorLerpSpeed = 2.0f;

    [Header("Visual Settings")]
    [SerializeField] private string roofMaterialName = "Roof";
    [SerializeField] private Transform roofObject;
    private Renderer roofRenderer;
    private Color currentColorDisplay;
    private Color targetColorDisplay;

    private AudioSource audioSource;
    private ParticleSystem captureInProgressParticlesInstance;

    public bool IsRecapturable => canBeCaptured;
    public bool IsBeingCaptured => teamActuellementEnCapture != TeamType.Neutral && teamActuellementEnCapture != this.Team;
    public TeamType CapturingInProgressByTeam => teamActuellementEnCapture;
    public float CaptureProgressNormalized => (beatsToCapture > 0) ? (currentCaptureProgressPoints / beatsToCapture) : 0f;
    public int BeatsToCaptureTotal => beatsToCapture;

    protected override IEnumerator Start()
    {
        FindRoofRenderer();
        targetColorDisplay = GetColorForTeam(this.Team);
        currentColorDisplay = targetColorDisplay;
        UpdateRoofColor(currentColorDisplay);

        if (GetComponent<AudioSource>() == null) audioSource = gameObject.AddComponent<AudioSource>();
        else audioSource = GetComponent<AudioSource>();
        audioSource.spatialBlend = 1.0f;
        audioSource.rolloffMode = AudioRolloffMode.Linear;
        audioSource.maxDistance = 20f;

        if (captureInProgressVFXPrefab != null)
        {
            GameObject vfxInstance = Instantiate(captureInProgressVFXPrefab, transform.position, Quaternion.identity, transform);
            captureInProgressParticlesInstance = vfxInstance.GetComponent<ParticleSystem>();
            if (captureInProgressParticlesInstance != null)
            {
                captureInProgressParticlesInstance.Stop();
            }
        }

        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat += HandleBeatLogic;
        }

        yield return StartCoroutine(base.Start());

        targetColorDisplay = GetColorForTeam(this.Team);
        currentColorDisplay = targetColorDisplay;
        UpdateRoofColor(currentColorDisplay);
    }

    private void Update()
    {
        if (currentColorDisplay != targetColorDisplay)
        {
            currentColorDisplay = Color.Lerp(currentColorDisplay, targetColorDisplay, Time.deltaTime * colorLerpSpeed);
            UpdateRoofColor(currentColorDisplay);
        }
    }

    public override void OnDestroy()
    {
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= HandleBeatLogic;
        }
        base.OnDestroy();
    }

    private void HandleBeatLogic(float beatDuration)
    {
        if (unitesQuiCapturentActuellement.Count > 0 && teamActuellementEnCapture != this.Team && teamActuellementEnCapture != TeamType.Neutral)
        {
            currentCaptureProgressPoints += unitesQuiCapturentActuellement.Count;

            if (captureProgressSound != null && audioSource != null)
            {
                audioSource.PlayOneShot(captureProgressSound);
            }

            foreach (Unit unit in unitesQuiCapturentActuellement.ToList())
            {
                unit?.OnCaptureBeat();
            }

            if (currentCaptureProgressPoints >= beatsToCapture)
            {
                CompleteCaptureProcess(teamActuellementEnCapture);
            }
        }
    }

    private void CompleteCaptureProcess(TeamType conqueringTeam)
    {
        TeamType oldTeam = this.Team;
        SetTeam(conqueringTeam);

        if (captureCompleteSound != null && audioSource != null) audioSource.PlayOneShot(captureCompleteSound);
        if (captureInProgressParticlesInstance != null) captureInProgressParticlesInstance.Stop();

        NotifyUnitsOfCaptureStop(unitesQuiCapturentActuellement.ToList());
        unitesQuiCapturentActuellement.Clear();

        currentCaptureProgressPoints = 0f;
        teamActuellementEnCapture = TeamType.Neutral;

        // --- NOUVEAU : Logique de gestion après la capture par le joueur ---
        if (conqueringTeam == TeamType.Player)
        {
            HandlePlayerCapture();
        }

        if (captureCompletedVFXPrefab != null)
        {
            GameObject completedVFXInstance = Instantiate(captureCompletedVFXPrefab, transform.position + Vector3.up * captureVFXYOffset, Quaternion.identity);
            Destroy(completedVFXInstance, captureCompletedVFXDuration);
        }
    }

    /// <summary>
    /// NOUVEAU : Gère les actions spécifiques à effectuer lorsque le joueur capture ce bâtiment.
    /// Désactive les colliders et réinitialise la bannière si elle est dessus.
    /// </summary>
    private void HandlePlayerCapture()
    {
        // Désactive le collider du bâtiment lui-même pour qu'il ne soit plus cliquable
        MeshCollider buildingCollider = GetComponent<MeshCollider>();
        if (buildingCollider != null)
        {
            buildingCollider.enabled = false;
        }

        // Désactive le collider de la tuile occupée pour libérer le passage
        if (occupiedTile != null)
        {
            MeshCollider tileCollider = occupiedTile.GetComponent<MeshCollider>();
            if (tileCollider != null)
            {
                tileCollider.enabled = false;
            }
        }

        // Si la bannière de ralliement était sur ce bâtiment, la renvoyer à la base
        if (BannerController.Exists && BannerController.Instance.CurrentBuilding == this)
        {
            Debug.Log($"[NeutralBuilding] Bâtiment {this.name} capturé par le joueur. Réinitialisation de la bannière.");
            BannerController.Instance.ClearBanner();
        }
    }

    #region Unchanged Code
    private void FindRoofRenderer()
    {
        if (roofObject != null) roofRenderer = roofObject.GetComponent<Renderer>();
        if (roofRenderer != null) return;
        Renderer[] renderers = GetComponentsInChildren<Renderer>();
        foreach (Renderer r in renderers)
        {
            if (r.gameObject.name.ToLower().Contains(roofMaterialName.ToLower())) { roofRenderer = r; return; }
            foreach (Material mat in r.materials)
                if (mat.name.ToLower().Contains(roofMaterialName.ToLower())) { roofRenderer = r; return; }
        }
        if (renderers.Length > 0) roofRenderer = renderers[0];
    }

    private Color GetColorForTeam(TeamType team)
    {
        switch (team)
        {
            case TeamType.Player: return playerColor;
            case TeamType.Enemy: return enemyColor;
            default: return neutralColor;
        }
    }

    private void UpdateRoofColor(Color color)
    {
        if (roofRenderer == null) return;
        roofRenderer.material.color = color;
        if (roofRenderer.material.HasProperty("_EmissionColor"))
        {
            roofRenderer.material.EnableKeyword("_EMISSION");
            roofRenderer.material.SetColor("_EmissionColor", color * 0.5f);
        }
    }

    public bool StartCapture(TeamType teamAttemptingCapture, Unit capturingUnit)
    {
        if (!canBeCaptured || teamAttemptingCapture == TeamType.Neutral) return false;
        if (this.Team == teamAttemptingCapture) return false;
        if (capturingUnit == null || !IsUnitInCaptureRange(capturingUnit)) return false;

        if (teamActuellementEnCapture != teamAttemptingCapture)
        {
            NotifyUnitsOfCaptureStop(unitesQuiCapturentActuellement.ToList());
            unitesQuiCapturentActuellement.Clear();
            currentCaptureProgressPoints = 0f;
            teamActuellementEnCapture = teamAttemptingCapture;
            targetColorDisplay = GetColorForTeam(teamAttemptingCapture);
            if (captureInProgressParticlesInstance != null)
            {
                var mainModule = captureInProgressParticlesInstance.main;
                mainModule.startColor = new ParticleSystem.MinMaxGradient(GetColorForTeam(teamAttemptingCapture));
                if (!captureInProgressParticlesInstance.isPlaying) captureInProgressParticlesInstance.Play();
            }
        }

        bool added = unitesQuiCapturentActuellement.Add(capturingUnit);
        return true;
    }

    public void StopCapturing(Unit unit)
    {
        if (unit == null) return;
        if (unitesQuiCapturentActuellement.Remove(unit))
        {
            if (unitesQuiCapturentActuellement.Count == 0 && teamActuellementEnCapture != TeamType.Neutral)
            {
                ResetCaptureAttemptVisuals();
            }
        }
    }

    private void NotifyUnitsOfCaptureStop(List<Unit> unitsToNotify)
    {
        foreach (Unit u in unitsToNotify)
        {
            u?.OnCaptureComplete();
        }
    }

    private void ResetCaptureAttemptVisuals()
    {
        teamActuellementEnCapture = TeamType.Neutral;
        if (captureInProgressParticlesInstance != null && captureInProgressParticlesInstance.isPlaying)
        {
            captureInProgressParticlesInstance.Stop();
        }
        targetColorDisplay = GetColorForTeam(this.Team);
    }

    protected override void OnTeamChanged(TeamType newTeam)
    {
        base.OnTeamChanged(newTeam);
        targetColorDisplay = GetColorForTeam(newTeam);
        if (ParticleController.Instance != null)
        {
            ParticleController.Instance.UpdateParticlesForBuilding(gameObject);
        }
    }
    
    private bool IsUnitInCaptureRange(Unit unit)
    {
        if (unit == null || unit.GetOccupiedTile() == null || this.occupiedTile == null || HexGridManager.Instance == null)
            return false;
        return HexGridManager.Instance.HexDistance(unit.GetOccupiedTile().column, unit.GetOccupiedTile().row, this.occupiedTile.column, this.occupiedTile.row) <= 1;
    }
    
    public override void TakeDamage(int damage,  Unit attacker = null)
    {
        if (!IsTargetable) return;
        if (IsRecapturable && this.Team != TeamType.Neutral)
        {
            return;
        }
        else
        {
            base.TakeDamage(damage);
        }
    }
    #endregion
}

// --- FILE: Scripts/Controllers/BannerController.cs ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Game.Observers;

/// <summary>
/// Central point for banner management, merging input logic and visual placement.
/// Can place the banner on a Building or a Unit via InputTargetingManager.
/// </summary>
public class BannerController : MonoBehaviour
{
    // --- Singleton Pattern ---
    public static bool Exists => instance != null;
    private static BannerController instance;
    public static BannerController Instance
    {
        get
        {
            if (instance == null)
            {
                instance = FindFirstObjectByType<BannerController>();
                if (instance == null)
                {
                    GameObject obj = new GameObject("BannerController");
                    instance = obj.AddComponent<BannerController>();
                }
            }
            return instance;
        }
    }

    [Header("State")]
    public Vector2Int CurrentBannerPosition { get; private set; }
    public bool HasActiveBanner { get; private set; }
    public Building CurrentBuilding { get; private set; }
    public Unit CurrentTargetedUnit { get; private set; }
    private Tile _currentTile;

    [Header("Visuals & Prefabs")]
    [SerializeField] private GameObject bannerPrefab;
    [SerializeField] private GameObject previewBannerPrefab;

    [Header("Debugging")]
    [SerializeField] private bool debugLogs = true;
    [SerializeField] private bool debugVisuals = true;
    [SerializeField] private Color previewDebugColor = new Color(0, 0, 1, 0.5f);
    [SerializeField] private Color bannerDebugColor = new Color(1, 0, 0, 0.5f);

    // --- Persistent Visual Objects ---
    private GameObject persistentBanner;
    private GameObject persistentPreviewBanner;
    private GameObject debugPreviewSphere;
    private GameObject debugBannerSphere;

    private readonly List<IBannerObserver> observers = new List<IBannerObserver>();

    #region Unity Lifecycle

    private void Awake()
    {
        if (instance != null && instance != this)
        {
            Destroy(gameObject);
            return;
        }
        instance = this;

        InitializePersistentPrefabs();
        if (debugVisuals) CreateDebugVisuals();
    }

    private void OnEnable()
    {
        InputTargetingManager.OnTargetHovered += HandleTargetHovered;
        InputTargetingManager.OnHoverEnded += HandleHoverEnded;
        InputTargetingManager.OnTargetSelected += HandleTargetSelected;

        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat += HandleBeat;
        }
    }

    private void Start()
    {
        // The initial placement on the base is handled by this coroutine
        StartCoroutine(InitializeBannerOnAllyBase());
    }

    private void OnDisable()
    {
        InputTargetingManager.OnTargetHovered -= HandleTargetHovered;
        InputTargetingManager.OnHoverEnded -= HandleHoverEnded;
        InputTargetingManager.OnTargetSelected -= HandleTargetSelected;

        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= HandleBeat;
        }

        if (CurrentTargetedUnit != null)
        {
            CurrentTargetedUnit.OnUnitDestroyed -= HandleTargetedUnitDestroyed;
        }

        HideVisual(persistentPreviewBanner, true);
        HideVisual(persistentBanner, false);
    }

    private void OnDestroy()
    {
        if (persistentPreviewBanner != null) Destroy(persistentPreviewBanner);
        if (persistentBanner != null) Destroy(persistentBanner);
        if (debugPreviewSphere != null) Destroy(debugPreviewSphere);
        if (debugBannerSphere != null) Destroy(debugBannerSphere);

        if (instance == this) instance = null;
    }

    #endregion

    #region Event Handlers

    private void HandleTargetHovered(GameObject targetObject)
    {
        if (targetObject == null) return;

        float topY = GetTopOfTarget(targetObject);
        ShowVisualAtPosition(persistentPreviewBanner, targetObject.transform.position, topY, true);
    }

    private void HandleHoverEnded()
    {
        HideVisual(persistentPreviewBanner, true);
    }

    private void HandleTargetSelected(GameObject targetObject)
    {
        HideVisual(persistentPreviewBanner, true);

        // Case 1: Clicked on empty space, reset banner to base.
        if (targetObject == null)
        {
            if (debugLogs) Debug.Log("[BannerController] Clicked on empty space. Resetting banner to base.");
            return;
        }

        // Case 2: A Building was selected.
        if (targetObject.TryGetComponent<Building>(out Building selectedBuilding))
        {
            if (HasActiveBanner && selectedBuilding == CurrentBuilding)
            {
                if(debugLogs) Debug.Log($"[BannerController] Same building selected. Resetting banner to base.");
                ClearBanner(); // Reset to base
            }
            else
            {
                if(debugLogs) Debug.Log($"[BannerController] New building selected ({selectedBuilding.name}). Placing banner.");
                PlaceBannerOnBuilding(selectedBuilding);
            }
        }
        // Case 3: A Unit was selected.
        else if (targetObject.TryGetComponent<Unit>(out Unit selectedUnit))
        {
            if (HasActiveBanner && selectedUnit == CurrentTargetedUnit)
            {
                 if(debugLogs) Debug.Log($"[BannerController] Same unit selected. Resetting banner to base.");
                 ClearBanner(); // Reset to base
            }
            else
            {
                if(debugLogs) Debug.Log($"[BannerController] New unit selected ({selectedUnit.name}). Placing banner.");
                PlaceBannerOnUnit(selectedUnit);
            }
        }
    }

    private void HandleBeat(float beatDuration)
    {
        if (!HasActiveBanner) return;

        Vector2Int positionToNotify;

        if (CurrentTargetedUnit != null)
        {
            Tile unitTile = CurrentTargetedUnit.GetOccupiedTile();
            if (unitTile != null)
            {
                positionToNotify = new Vector2Int(unitTile.column, unitTile.row);
                CurrentBannerPosition = positionToNotify;
                NotifyObservers(positionToNotify.x, positionToNotify.y);
            }
            else
            {
                if(debugLogs) Debug.LogWarning($"[BannerController] Target unit '{CurrentTargetedUnit.name}' has a banner but its tile is temporarily unavailable. Waiting for next beat.");
                return;
            }
        }
        else if (_currentTile != null)
        {
            positionToNotify = new Vector2Int(_currentTile.column, _currentTile.row);
            NotifyObservers(positionToNotify.x, positionToNotify.y);
        }
        else
        {
            if (debugLogs) Debug.LogError("[BannerController] Banner is active but has no valid target (Unit or Tile). Resetting to base as a fallback.");
            ClearBanner();
            return;
        }
    }

    private void HandleTargetedUnitDestroyed()
    {
        if (debugLogs) Debug.Log("[BannerController] Targeted unit was destroyed. Resetting banner to base.");
        ClearBanner(); // Reset to base
    }

    #endregion

    #region Banner Logic

    public bool PlaceBannerOnBuilding(Building building)
    {
        if (building == null) return false;
        Tile occupiedTile = building.GetOccupiedTile();
        if (occupiedTile == null || !building.IsTargetable) return false;

        // Clean up previous target state without deactivating the banner
        _CleanUpCurrentTarget();

        // Set new target state
        CurrentBuilding = building;
        _currentTile = occupiedTile;
        CurrentBannerPosition = new Vector2Int(occupiedTile.column, occupiedTile.row);
        HasActiveBanner = true;

        building.GetComponent<BuildingSelectionFeedback>()?.SetOutlineState(OutlineState.Selected);

        float topY = GetTopOfTarget(building.gameObject);
        ShowVisualAtPosition(persistentBanner, building.transform.position, topY, false);

        if(debugLogs) Debug.Log($"[BannerController] Banner placed on Building {building.name}. Notifying observers.");
        NotifyObservers(occupiedTile.column, occupiedTile.row);
        return true;
    }

    public bool PlaceBannerOnUnit(Unit unit)
    {
        if (unit == null) return false;

        // Clean up previous target state without deactivating the banner
        _CleanUpCurrentTarget();

        // Set new target state
        CurrentTargetedUnit = unit;
        HasActiveBanner = true;
        CurrentTargetedUnit.OnUnitDestroyed += HandleTargetedUnitDestroyed;

        ShowAndAttachVisualToUnit(persistentBanner, unit, false);

        Tile unitTile = unit.GetOccupiedTile();
        if (unitTile != null)
        {
            CurrentBannerPosition = new Vector2Int(unitTile.column, unitTile.row);
            if(debugLogs) Debug.Log($"[BannerController] Banner placed on Unit {unit.name}. Notifying observers.");
            NotifyObservers(unitTile.column, unitTile.row);
        }
        return true;
    }

    /// <summary>
    /// MODIFIED: This method no longer deactivates the banner. Instead, it resets it to the allied base.
    /// This is the new default state for the banner.
    /// </summary>
    public void ClearBanner()
    {
        if (debugLogs) Debug.Log("[BannerController] Clearing current target and resetting banner to ally base.");

        // First, reset the state of the current target
        _CleanUpCurrentTarget();

        // Then, find the ally base and place the banner there
        StartCoroutine(InitializeBannerOnAllyBase());
    }

    /// <summary>
    /// NEW: Private helper to clean up the current target's state without changing HasActiveBanner.
    /// This prevents recursion and separates responsibilities.
    /// </summary>
    private void _CleanUpCurrentTarget()
    {
        if (CurrentBuilding != null)
        {
            CurrentBuilding.GetComponent<BuildingSelectionFeedback>()?.SetOutlineState(OutlineState.Default);
        }
        if (CurrentTargetedUnit != null)
        {
            CurrentTargetedUnit.OnUnitDestroyed -= HandleTargetedUnitDestroyed;
        }

        CurrentBuilding = null;
        CurrentTargetedUnit = null;
        _currentTile = null;
    }


    #endregion

    #region Visuals Management

    private void InitializePersistentPrefabs()
    {
        if (bannerPrefab != null)
        {
            persistentBanner = Instantiate(bannerPrefab);
            persistentBanner.name = "Persistent_Banner_Visual";
            persistentBanner.SetActive(false);
        }

        GameObject prefabToUseForPreview = previewBannerPrefab != null ? previewBannerPrefab : bannerPrefab;
        if (prefabToUseForPreview != null)
        {
            persistentPreviewBanner = Instantiate(prefabToUseForPreview);
            persistentPreviewBanner.name = "Persistent_Preview_Visual";
            persistentPreviewBanner.SetActive(false);
        }
    }

    private void ShowVisualAtPosition(GameObject visual, Vector3 worldPosition, float topY, bool isPreview)
    {
        if (visual == null) return;

        visual.transform.SetParent(null);

        BannerMovement bannerMovement = visual.GetComponent<BannerMovement>();
        float heightOffset = bannerMovement != null ? bannerMovement.FinalHeightOffset : 1.0f;
        Vector3 bannerPosition = new Vector3(worldPosition.x, topY + heightOffset, worldPosition.z);

        visual.transform.position = bannerPosition;
        visual.SetActive(true);
        bannerMovement?.UpdatePosition(bannerPosition);

        UpdateDebugVisual(isPreview, bannerPosition, true);
    }

    private void ShowAndAttachVisualToUnit(GameObject visual, Unit unit, bool isPreview)
    {
        if (visual == null || unit == null) return;

        visual.transform.SetParent(unit.transform, true);
        visual.transform.localPosition = Vector3.zero;
        visual.SetActive(true);

        BannerMovement bannerMovement = visual.GetComponent<BannerMovement>();
        bannerMovement?.AttachToUnit(unit);

        UpdateDebugVisual(isPreview, visual.transform.position, true);
    }

    private void HideVisual(GameObject visualInstance, bool isPreview)
    {
        if (visualInstance != null)
        {
            visualInstance.SetActive(false);
            visualInstance.transform.SetParent(null);
        }
        UpdateDebugVisual(isPreview, Vector3.zero, false);
    }

    private float GetTopOfTarget(GameObject targetObject)
    {
        if (targetObject == null) return 0f;

        Renderer[] renderers = targetObject.GetComponentsInChildren<Renderer>();
        if (renderers.Length == 0) return targetObject.transform.position.y + 2f;

        Bounds combinedBounds = new Bounds();
        bool hasBounds = false;

        foreach (Renderer renderer in renderers)
        {
            if (renderer is ParticleSystemRenderer || renderer is TrailRenderer) continue;

            if (!hasBounds)
            {
                combinedBounds = renderer.bounds;
                hasBounds = true;
            }
            else
            {
                combinedBounds.Encapsulate(renderer.bounds);
            }
        }

        return hasBounds ? combinedBounds.max.y : targetObject.transform.position.y + 2f;
    }

    #endregion

    #region Observer Pattern & Helpers

    /// <summary>
    /// Finds the player's base and places the banner on it.
    /// This is used for initialization and for resetting the banner.
    /// </summary>
    private IEnumerator InitializeBannerOnAllyBase()
    {
        // A short delay can prevent issues during scene loading
        yield return new WaitForSeconds(0.1f);

        PlayerBuilding allyBase = FindFirstObjectByType<PlayerBuilding>();
        if (allyBase != null)
        {
            if (debugLogs) Debug.Log($"[BannerController] Auto-placing/Resetting banner on ally base: {allyBase.name}");
            PlaceBannerOnBuilding(allyBase);
        }
        else
        {
            if (debugLogs) Debug.LogError("[BannerController] Could not find an ally base to place the banner!");
            // If no base, truly deactivate the banner
            _CleanUpCurrentTarget();
            HasActiveBanner = false;
            HideVisual(persistentBanner, false);
            NotifyObservers(-1, -1);
        }
    }

    public void AddObserver(IBannerObserver observer)
    {
        if (observer != null && !observers.Contains(observer))
        {
            observers.Add(observer);
        }
    }

    public void RemoveObserver(IBannerObserver observer)
    {
        if (observer != null) observers.Remove(observer);
    }

    private void NotifyObservers(int column, int row)
    {
        foreach (var observer in new List<IBannerObserver>(observers))
        {
            observer?.OnBannerPlaced(column, row);
        }
    }

    #endregion

    #region Debugging
    private void CreateDebugVisuals()
    {
        debugPreviewSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        debugPreviewSphere.name = "DebugPreviewSphere";
        debugPreviewSphere.transform.localScale = Vector3.one * 0.5f;
        debugPreviewSphere.GetComponent<Renderer>().material.color = previewDebugColor;
        Destroy(debugPreviewSphere.GetComponent<Collider>());
        debugPreviewSphere.SetActive(false);

        debugBannerSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        debugBannerSphere.name = "DebugBannerSphere";
        debugBannerSphere.transform.localScale = Vector3.one * 0.5f;
        debugBannerSphere.GetComponent<Renderer>().material.color = bannerDebugColor;
        Destroy(debugBannerSphere.GetComponent<Collider>());
        debugBannerSphere.SetActive(false);
    }

    private void UpdateDebugVisual(bool isPreview, Vector3 position, bool shouldShow)
    {
        if (!debugVisuals) return;
        GameObject sphere = isPreview ? debugPreviewSphere : debugBannerSphere;
        if (sphere != null)
        {
            sphere.transform.position = position;
            sphere.SetActive(shouldShow);
        }
    }
    #endregion
}

// --- FILE: Scripts/Controllers/CameraController.cs ---
using UnityEngine;
using Sirenix.OdinInspector;
using System.Collections;
using UnityEngine.InputSystem;

/// <summary>
/// Camera controller for a rhythm game that supports right-click drag panning in 3D space,
/// arrow key movement, mouse wheel zooming, and gamepad targeting with lock mode.
/// Handles both Orthographic and Perspective camera projections.
/// </summary>
public class RhythmGameCameraController : MonoBehaviour
{
    [TitleGroup("Movement Settings")]
    [Tooltip("Speed of camera panning with arrow keys")]
    [SerializeField] private float keyboardMoveSpeed = 10f;

    [Tooltip("Speed of camera panning with right-click drag")]
    [SerializeField] private float mousePanSpeed = 1.5f;

    [Tooltip("Whether to invert mouse panning direction")]
    [SerializeField] private bool invertMousePan = false;

    [TitleGroup("Zoom Settings")]
    [Tooltip("Speed of camera zooming with mouse wheel or gamepad")]
    [SerializeField] private float zoomSpeed = 5f;

    [Tooltip("Minimum allowed zoom level (Orthographic Size or Perspective Y Position)")]
    [SerializeField] private float minZoom = 2f;

    [Tooltip("Maximum allowed zoom level (Orthographic Size or Perspective Y Position)")]
    [SerializeField] private float maxZoom = 20f;

    [Tooltip("Whether to invert mouse wheel zoom direction")]
    [SerializeField] private bool invertZoom = false;

    [TitleGroup("Bounds Settings")]
    [Tooltip("Whether to restrict camera movement within bounds")]
    [SerializeField] private bool useBounds = false;

    [ShowIf("useBounds")]
    [Tooltip("Minimum X position the camera can move to")]
    [SerializeField] private float minX = -50f;

    [ShowIf("useBounds")]
    [Tooltip("Maximum X position the camera can move to")]
    [SerializeField] private float maxX = 50f;

    [ShowIf("useBounds")]
    [Tooltip("Minimum Z position the camera can move to")]
    [SerializeField] private float minZ = -50f;

    [ShowIf("useBounds")]
    [Tooltip("Maximum Z position the camera can move to")]
    [SerializeField] private float maxZ = 50f;
    
    // MODIFIÉ : Renommage de minY/maxY pour plus de clarté, car ils sont maintenant utilisés pour le zoom en perspective.
    [ShowIf("useBounds")]
    [Tooltip("Minimum Y position (zoom) for perspective camera")]
    [SerializeField] private float perspectiveMinY = 2f;

    [ShowIf("useBounds")]
    [Tooltip("Maximum Y position (zoom) for perspective camera")]
    [SerializeField] private float perspectiveMaxY = 50f;

    [TitleGroup("Debug")]
    [ReadOnly]
    [SerializeField] private bool isDragging = false;

    [TitleGroup("Lock Mode Settings")]
    [SerializeField] private float lockFollowSpeed = 5f;
    [SerializeField] private float lockDistance = 10f;
    [SerializeField] private float lockHeightOffset = 5f;
    [SerializeField] private float unlockAnimationDuration = 0.4f;
    [SerializeField] private float lockMoveSmoothTime = 0.2f;
    private Vector3 _cameraVelocity = Vector3.zero;

    [TitleGroup("Locking Mechanism")]
    [ReadOnly]
    [SerializeField] public bool controlsLocked = false;
    [ReadOnly]
    [SerializeField] private bool zoomLocked = false;
    [ReadOnly]
    [SerializeField] private bool isCameraLocked = false;

    private Vector3 initialPosition;
    private Quaternion initialRotation;
    private float initialZoomValue;

    private Camera cameraComponent;
    private bool isOrthographic;

    private Coroutine _zoomCoroutine;
    private Transform currentTarget;
    public static event System.Action OnToggleCameraLockRequested;
    private Vector3 _preLockPosition;
    private Quaternion _preLockRotation;
    private Coroutine _cameraAnimationCoroutine;
    
    private void Awake()
    {
        cameraComponent = GetComponent<Camera>();
        if (cameraComponent == null)
        {
            Debug.LogError("No Camera component found on this GameObject!");
            enabled = false;
            return;
        }

        isOrthographic = cameraComponent.orthographic;
        
        initialPosition = transform.position;
        initialRotation = transform.rotation; 

        if (isOrthographic)
        {
            initialZoomValue = cameraComponent.orthographicSize;
        }
        else
        {
            // En perspective, le "zoom" initial est sa position Y.
            initialZoomValue = transform.position.y; 
        }
    }

    private void OnEnable()
    {
        if (InputManager.Instance != null)
        {
            InputManager.Instance.GameplayActions.ToggleCameraLock.performed += OnToggleCameraLockPressed;
        }
    }

    private void OnDisable()
    {
        if (InputManager.Instance != null)
        {
            InputManager.Instance.GameplayActions.ToggleCameraLock.performed -= OnToggleCameraLockPressed;
        }
    }

    private void Update()
    {
        if (controlsLocked) return;

        if (isCameraLocked)
        {
            HandleLockedCameraMovement();
        }
        else
        {
            HandleMouseInput();
            HandleKeyboardInput();
        }
        
        HandleZoomInput();
    }

    private void OnToggleCameraLockPressed(InputAction.CallbackContext context)
    {
        OnToggleCameraLockRequested?.Invoke();
    }

    private void HandleMouseInput()
    {
        Vector2 cameraPanInput = InputManager.Instance.GameplayActions.CameraPan.ReadValue<Vector2>();
        bool isCurrentlyDragging = cameraPanInput.sqrMagnitude > 0.1f;
        
        if (isCurrentlyDragging)
        {
            isDragging = true;

            float horizontalMovement = -cameraPanInput.x * mousePanSpeed * 0.01f;
            float verticalMovement = -cameraPanInput.y * mousePanSpeed * 0.01f;

            if (invertMousePan)
            {
                horizontalMovement = -horizontalMovement;
                verticalMovement = -verticalMovement;
            }

            Vector3 right = transform.right;
            Vector3 forward = Vector3.Cross(transform.right, Vector3.up);

            // MODIFIÉ : On calcule la nouvelle position et on la clamp AVANT de l'assigner pour éviter le "glissement".
            Vector3 newPosition = transform.position + (right * horizontalMovement + forward * verticalMovement);
            transform.position = ClampPositionToBounds(newPosition);
        }
        else
        {
            isDragging = false;
        }
    }
    
    private void HandleKeyboardInput()
    {
        Vector2 moveInput = InputManager.Instance.GameplayActions.CameraMove.ReadValue<Vector2>();

        if (moveInput.sqrMagnitude > 0.1f)
        {
            float moveSpeed = keyboardMoveSpeed * Time.deltaTime;
            Vector3 movement = new Vector3(moveInput.x, 0, moveInput.y).normalized * moveSpeed;
            Vector3 forward = Vector3.ProjectOnPlane(transform.forward, Vector3.up).normalized;
            if (forward.sqrMagnitude < 0.001f) forward = transform.up;
            Vector3 right = Vector3.Cross(Vector3.up, forward).normalized;
            Vector3 moveDirection = right * movement.x + forward * movement.z;

            // MODIFIÉ : On calcule la nouvelle position et on la clamp AVANT de l'assigner.
            Vector3 newPosition = transform.position + moveDirection;
            transform.position = ClampPositionToBounds(newPosition);
        }
    }

    private void HandleZoomInput()
    {
        if (zoomLocked || controlsLocked) return;

        float zoomInput = InputManager.Instance.GameplayActions.CameraZoom.ReadValue<float>();

        if (Mathf.Abs(zoomInput) > 0.01f)
        {
            if (invertZoom)
            {
                zoomInput = -zoomInput;
            }

            if (isOrthographic)
            {
                cameraComponent.orthographicSize = Mathf.Clamp(
                    cameraComponent.orthographicSize - zoomInput * zoomSpeed,
                    minZoom,
                    maxZoom
                );
            }
            else
            {
                // MODIFIÉ : En perspective, le zoom change la hauteur (Y) de la caméra.
                Vector3 pos = transform.position;
                float newY = pos.y - (zoomInput * (zoomSpeed / 2f)); // On divise pour une sensation moins rapide
                pos.y = Mathf.Clamp(newY, perspectiveMinY, perspectiveMaxY);
                transform.position = pos;
            }
        }
    }
    
    // MODIFIÉ : Anciennement EnforceBounds. Cette fonction s'assure que la position reste dans les limites.
    private Vector3 ClampPositionToBounds(Vector3 position)
    {
        if (!useBounds) return position;

        position.x = Mathf.Clamp(position.x, minX, maxX);
        position.z = Mathf.Clamp(position.z, minZ, maxZ);
        // La hauteur (Y) est déjà gérée par le zoom, on s'assure juste qu'elle ne sorte pas des clous.
        if (!isOrthographic)
        {
            position.y = Mathf.Clamp(position.y, perspectiveMinY, perspectiveMaxY);
        }
        
        return position;
    }

    public void ZoomOutToMaxAndLockZoomOnly(bool animate = true, float animationDuration = 1.0f)
    {
        zoomLocked = true;
        Debug.Log("[RhythmGameCameraController] Zoom locked. Zooming out to maximum.");

        if (_zoomCoroutine != null) StopCoroutine(_zoomCoroutine);

        if (animate && animationDuration > 0)
        {
            _zoomCoroutine = StartCoroutine(AnimateZoomOutCoroutine(animationDuration));
        }
        else
        {
            ApplyMaxZoomInstantly();
        }
    }
    
    private void ApplyMaxZoomInstantly()
    {
        if (isOrthographic)
        {
            cameraComponent.orthographicSize = maxZoom;
        }
        else
        {
            Vector3 targetPos = transform.position;
            if (useBounds)
            {
                targetPos.x = (minX + maxX) / 2f;
                targetPos.z = (minZ + maxZ) / 2f;
                targetPos.y = perspectiveMaxY;
            }
            else
            {
                // Si pas de limites, on se contente de monter
                targetPos.y = perspectiveMaxY;
            }
            transform.position = targetPos;
        }
    }

    private IEnumerator AnimateZoomOutCoroutine(float duration)
    {
        float elapsedTime = 0f;
        Vector3 startPosition = transform.position;
        
        if (isOrthographic)
        {
            float startSize = cameraComponent.orthographicSize;
            float targetSize = maxZoom;
            while (elapsedTime < duration)
            {
                elapsedTime += Time.unscaledDeltaTime;
                float t = Mathf.Clamp01(elapsedTime / duration);
                cameraComponent.orthographicSize = Mathf.Lerp(startSize, targetSize, Mathf.SmoothStep(0f, 1f, t));
                yield return null;
            }
            cameraComponent.orthographicSize = targetSize;
        }
        else
        {
            // MODIFIÉ : On calcule une position cible centrée pour une belle vue d'ensemble.
            Vector3 targetPosition = startPosition;
            if (useBounds)
            {
                targetPosition.x = (minX + maxX) / 2f;
                targetPosition.z = (minZ + maxZ) / 2f;
                targetPosition.y = perspectiveMaxY;
            }
            else
            {
                Debug.LogWarning("Animated max zoom for perspective camera without 'useBounds' is not recommended.");
                targetPosition.y = perspectiveMaxY;
            }

            while (elapsedTime < duration)
            {
                elapsedTime += Time.unscaledDeltaTime;
                float t = Mathf.Clamp01(elapsedTime / duration);
                transform.position = Vector3.Lerp(startPosition, targetPosition, Mathf.SmoothStep(0f, 1f, t));
                yield return null;
            }
            transform.position = targetPosition;
        }
        _zoomCoroutine = null;
    }

    // --- Le reste du script reste globalement identique, le voici pour la complétude ---

    public void ResetCameraToInitialState()
    {
        if (_zoomCoroutine != null) StopCoroutine(_zoomCoroutine);
        if (_cameraAnimationCoroutine != null) StopCoroutine(_cameraAnimationCoroutine);
        
        transform.position = initialPosition;
        transform.rotation = initialRotation; 

        if (isOrthographic)
        {
            cameraComponent.orthographicSize = initialZoomValue;
        }
        // Pas besoin de 'else', la position Y est déjà dans initialPosition
        
        Debug.Log("[RhythmGameCameraController] Camera reset to initial state.");
    }
    
    public void UnlockZoomOnly()
    {
        zoomLocked = false;
        Debug.Log("[RhythmGameCameraController] Zoom controls unlocked.");
    }

    public void LockOnTarget(Transform newTarget)
    {
        if (newTarget == null) return;
        if (!isCameraLocked)
        {
            _preLockPosition = transform.position;
            _preLockRotation = transform.rotation;
        }
        
        currentTarget = newTarget;
        isCameraLocked = true;
    }

    public void UnlockCamera()
    {
        if (!isCameraLocked) return;

        isCameraLocked = false;
        currentTarget = null;
        
        if (_cameraAnimationCoroutine != null) StopCoroutine(_cameraAnimationCoroutine);
        _cameraAnimationCoroutine = StartCoroutine(AnimateToStateCoroutine(_preLockPosition, _preLockRotation, unlockAnimationDuration));
    }

    private void HandleLockedCameraMovement()
    {
        if (currentTarget == null) return;

        Vector3 desiredPosition = currentTarget.position - (transform.forward * lockDistance);
        desiredPosition.y = currentTarget.position.y + lockHeightOffset;

        transform.position = Vector3.SmoothDamp(transform.position, desiredPosition, ref _cameraVelocity, lockMoveSmoothTime);

        Quaternion targetRotation = Quaternion.LookRotation(currentTarget.position - transform.position);
        transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, lockFollowSpeed * Time.deltaTime);
    }
    
    private IEnumerator AnimateToStateCoroutine(Vector3 targetPosition, Quaternion targetRotation, float duration)
    {
        controlsLocked = true; 
        float elapsedTime = 0f;
        Vector3 startPosition = transform.position;
        Quaternion startRotation = transform.rotation;

        while (elapsedTime < duration)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.SmoothStep(0, 1, elapsedTime / duration);
            transform.position = Vector3.Lerp(startPosition, targetPosition, t);
            transform.rotation = Quaternion.Slerp(startRotation, targetRotation, t);
            yield return null;
        }

        transform.position = targetPosition;
        transform.rotation = targetRotation;
        controlsLocked = false;
        _cameraAnimationCoroutine = null;
    }

    public bool IsLocked => isCameraLocked;
}

// --- FILE: Scripts/Controllers/ComboController.cs ---
using UnityEngine;
using System.Collections.Generic;
using System;
using Game.Observers;

public class ComboController : MonoBehaviour
{
    // La définition du Singleton et les autres variables restent les mêmes
    private static ComboController instance;
    public static ComboController Instance
    {
        get
        {
            if (instance == null)
            {
                instance = FindFirstObjectByType<ComboController>();
            }
            return instance;
        }
    }

    public int comboCount { get; private set; } = 0;
    public int maxCombo { get; private set; } = 0;

    private readonly List<IComboObserver> observers = new List<IComboObserver>();

    private void Awake()
    {
        if (instance != null && instance != this)
        {
            Debug.LogWarning("Multiple ComboController instances detected. Destroying duplicate.");
            Destroy(gameObject);
            return;
        }
        instance = this;
    }

    private void OnEnable()
    {
        // --- MODIFIÉ ICI ---
        // On s'abonne à chaque touche correcte, pas seulement à la séquence réussie.
        SequenceController.OnSequenceKeyPressed += HandleCorrectInput;
        
        // On garde la réinitialisation du combo en cas d'échec
        SequenceController.OnSequenceFail += ResetCombo;
    }

    private void OnDisable()
    {
        // --- MODIFIÉ ICI ---
        // On se désabonne du même événement.
        SequenceController.OnSequenceKeyPressed -= HandleCorrectInput;
        SequenceController.OnSequenceFail -= ResetCombo;
    }

    private void OnDestroy()
    {
        if (instance == this)
        {
            instance = null;
        }
    }

    // --- NOUVELLE MÉTHODE ---
    /// <summary>
    /// Gère un input correct et incrémente le combo.
    /// La signature correspond à l'événement OnSequenceKeyPressed.
    /// </summary>
    private void HandleCorrectInput(string key, Color timingColor)
    {
        IncrementCombo();
    }
    
    // La logique de ces méthodes reste la même
    private void IncrementCombo()
    {
        comboCount++;
        maxCombo = Mathf.Max(maxCombo, comboCount);
        NotifyObservers();
    }

    private void ResetCombo()
    {
        // On ne réinitialise que si le combo était supérieur à 0, pour ne pas notifier inutilement.
        if (comboCount > 0)
        {
            comboCount = 0;
            NotifyComboReset();
        }
    }
    
    // Les méthodes d'observateur restent les mêmes
    public void AddObserver(IComboObserver observer)
    {
        if (!observers.Contains(observer))
        {
            observers.Add(observer);
            observer.OnComboUpdated(comboCount);
        }
    }

    public void RemoveObserver(IComboObserver observer)
    {
        observers.Remove(observer);
    }

    private void NotifyObservers()
    {
        foreach (var observer in observers.ToArray()) // Utiliser ToArray pour éviter les problèmes si un observer se retire pendant la notification
        {
            if (observer != null)
            {
                observer.OnComboUpdated(comboCount);
            }
        }
        observers.RemoveAll(o => o == null);
    }

    private void NotifyComboReset()
    {
        foreach (var observer in observers.ToArray())
        {
            if (observer != null)
            {
                observer.OnComboReset();
            }
        }
        observers.RemoveAll(o => o == null);
    }

    private void OnApplicationQuit()
    {
        instance = null;
    }
}

// --- FILE: Scripts/Controllers/EnemyUnitManager.cs ---
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Manages enemy unit coordination to prevent multiple units from targeting the same tile.
/// Acts as a central registry for planned destinations.
/// </summary>
public class EnemyUnitManager : MonoBehaviour
{
    // Singleton instance
    public static EnemyUnitManager Instance { get; private set; }

    // Dictionary mapping tile positions to the units targeting them
    private Dictionary<Vector2Int, EnemyUnit> plannedDestinations = new Dictionary<Vector2Int, EnemyUnit>();

    // Debug setting
    [SerializeField] private bool enableDebugLogging = false;

    private void Awake()
    {
        // Singleton pattern
        if (Instance == null)
        {
            Instance = this;
        }
        else if (Instance != this)
        {
            Destroy(gameObject);
            Debug.LogWarning("[EnemyUnitManager] Multiple instances detected. Destroying duplicate.", gameObject);
        }
    }

    /// <summary>
    /// Registers a planned destination for an enemy unit
    /// </summary>
    /// <param name="unit">The enemy unit</param>
    /// <param name="position">The target position</param>
    /// <returns>True if registration was successful, false if already reserved</returns>
    public static bool RegisterPlannedDestination(EnemyUnit unit, Vector2Int position)
    {
        if (Instance == null)
        {
            // Create instance if none exists
            new GameObject("EnemyUnitManager").AddComponent<EnemyUnitManager>();
        }

        // Check if position is already reserved by another unit
        if (Instance.plannedDestinations.TryGetValue(position, out EnemyUnit existingUnit))
        {
            if (existingUnit != unit && existingUnit != null)
            {
                if (Instance.enableDebugLogging)
                {
                    Debug.Log($"Position ({position.x}, {position.y}) already reserved by {existingUnit.name}");
                }
                return false;
            }
        }

        // Unregister any previous targets for this unit
        UnregisterUnit(unit);

        // Register the new target
        Instance.plannedDestinations[position] = unit;

        if (Instance.enableDebugLogging)
        {
            Debug.Log($"{unit.name} registered target at ({position.x}, {position.y})");
        }

        return true;
    }

    /// <summary>
    /// Unregisters a planned destination for an enemy unit
    /// </summary>
    /// <param name="unit">The enemy unit</param>
    /// <param name="position">The target position</param>
    public static void UnregisterPlannedDestination(EnemyUnit unit, Vector2Int position)
    {
        if (Instance == null)
            return;

        // Only remove if this unit is the one that registered it
        if (Instance.plannedDestinations.TryGetValue(position, out EnemyUnit existingUnit) && existingUnit == unit)
        {
            Instance.plannedDestinations.Remove(position);

            if (Instance.enableDebugLogging)
            {
                Debug.Log($"{unit.name} unregistered target at ({position.x}, {position.y})");
            }
        }
    }

    /// <summary>
    /// Unregisters all destinations for a specific unit
    /// </summary>
    /// <param name="unit">The enemy unit</param>
    public static void UnregisterUnit(EnemyUnit unit)
    {
        if (Instance == null)
            return;

        List<Vector2Int> keysToRemove = new List<Vector2Int>();

        // Find all positions registered by this unit
        foreach (var kvp in Instance.plannedDestinations)
        {
            if (kvp.Value == unit)
            {
                keysToRemove.Add(kvp.Key);
            }
        }

        // Remove them all
        foreach (var key in keysToRemove)
        {
            Instance.plannedDestinations.Remove(key);

            if (Instance.enableDebugLogging)
            {
                Debug.Log($"{unit.name} unregistered target at ({key.x}, {key.y})");
            }
        }
    }

    /// <summary>
    /// Checks if a position is reserved by any enemy unit
    /// </summary>
    /// <param name="position">The position to check</param>
    /// <param name="excludeUnit">Optional unit to exclude from the check</param>
    /// <returns>True if the position is reserved, false otherwise</returns>
    public static bool IsTileReserved(Vector2Int position, EnemyUnit excludeUnit = null)
    {
        if (Instance == null)
            return false;

        if (Instance.plannedDestinations.TryGetValue(position, out EnemyUnit unit))
        {
            // Position is reserved by a different unit
            return unit != null && unit != excludeUnit;
        }

        return false;
    }

    /// <summary>
    /// Gets all currently reserved positions for debugging
    /// </summary>
    /// <returns>Dictionary of positions and units</returns>
    public static Dictionary<Vector2Int, EnemyUnit> GetAllReservedPositions()
    {
        if (Instance == null)
            return new Dictionary<Vector2Int, EnemyUnit>();

        return new Dictionary<Vector2Int, EnemyUnit>(Instance.plannedDestinations);
    }

    /// <summary>
    /// Clears all reservations (useful when changing scenes or resetting)
    /// </summary>
    public static void ClearAllReservations()
    {
        if (Instance == null)
            return;

        Instance.plannedDestinations.Clear();

        if (Instance.enableDebugLogging)
        {
            Debug.Log("Cleared all enemy unit reservations");
        }
    }

    // Cleanup on destroy
    private void OnDestroy()
    {
        if (Instance == this)
        {
            Instance = null;
        }
    }
}

// --- FILE: Scripts/Controllers/FeverManager.cs ---
﻿using UnityEngine;
using System;
using Game.Observers;

public class FeverManager : MonoBehaviour
{
    public static FeverManager Instance { get; private set; }

    [Header("Configuration")]
    [Tooltip("Nombre de combos par palier de Fever (ex: 10 = paliers à 10, 20, 30, etc.)")]
    [SerializeField]
    private int combosPerFeverLevel = 10;
    
    [Tooltip("Nombre maximum de paliers de Fever (0-based, donc 3 = 4 niveaux : 0, 1, 2, 3)")]
    [SerializeField]
    private int maxFeverLevel = 3;
    public int MaxFeverLevel => maxFeverLevel; // Rendre le niveau max accessible publiquement

    [Header("État (lecture seule)")]
    [SerializeField]
    private int _currentFeverLevel = 0;
    public int CurrentFeverLevel => _currentFeverLevel;
    
    [SerializeField]
    private bool _isFeverActive = false;
    public bool IsFeverActive => _isFeverActive;

    [Header("Audio")]
    [Tooltip("Son à jouer quand le combo est brisé (optionnel)")]
    [SerializeField]
    private AK.Wwise.Event comboBrokenSound;

    // Événements
    public event Action<bool> OnFeverStateChanged;
    public event Action<int> OnFeverLevelChanged; // Nouveau : notifie le changement de niveau

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void OnEnable()
    {
        // S'abonner aux événements du ComboController
        if (ComboController.Instance != null)
        {
            ComboController.Instance.AddObserver(new FeverComboObserver(this));
        }
        else
        {
            Debug.LogError("[FeverManager] ComboController.Instance est introuvable ! Le Mode Fever ne fonctionnera pas.");
        }

        // S'abonner aux changements d'état musical pour réappliquer le Fever
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnMusicStateChanged += OnMusicStateChanged;
        }
    }

    private void OnDisable()
    {
        // Se désabonner des événements pour éviter les fuites mémoire
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnMusicStateChanged -= OnMusicStateChanged;
        }
    }

    private void OnMusicStateChanged(string newMusicState)
    {
        Debug.Log($"[FeverManager] Transition musicale détectée : {newMusicState}. Réapplication de l'intensité Fever.");
        
        // Réappliquer l'intensité Fever actuelle après la transition
        float rtpcValue = CalculateRTPCValue(_currentFeverLevel);
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.SetFeverIntensity(rtpcValue);
        }
    }

    private void HandleComboUpdated(int newComboCount)
    {
        // Calculer le niveau de Fever basé sur le combo actuel
        int newFeverLevel = CalculateFeverLevel(newComboCount);
        
        // Si le niveau a changé, mettre à jour
        if (newFeverLevel != _currentFeverLevel)
        {
            UpdateFeverLevel(newFeverLevel);
        }
        
        // Gérer l'activation/désactivation du mode Fever
        bool shouldBeActive = newFeverLevel > 0;
        if (shouldBeActive != _isFeverActive)
        {
            ActivateFeverMode(shouldBeActive);
        }
        
        // on veut que tout les observateurs soient notifiés du changement de niveau
        
    }

    private void HandleComboBroken()
    {
        Debug.Log("[FeverManager] Combo brisé ! Réinitialisation du Mode Fever.");
        
        // Jouer le son de combo brisé si configuré
        if (comboBrokenSound != null && comboBrokenSound.IsValid())
        {
            comboBrokenSound.Post(gameObject);
        }
        
        // Réinitialiser le niveau et désactiver le mode Fever
        if (_currentFeverLevel > 0)
        {
            UpdateFeverLevel(0);
        }
        
        if (_isFeverActive)
        {
            ActivateFeverMode(false);
        }
    }

    private int CalculateFeverLevel(int comboCount)
    {
        if (combosPerFeverLevel <= 0) return 0;
        
        // Calculer le niveau basé sur le combo
        int level = comboCount / combosPerFeverLevel;
        
        // Limiter au niveau maximum
        return Mathf.Clamp(level, 0, maxFeverLevel);
    }

    private void UpdateFeverLevel(int newLevel)
    {
        if (_currentFeverLevel == newLevel) return;
        
        int previousLevel = _currentFeverLevel;
        _currentFeverLevel = newLevel;
        
        Debug.Log($"[FeverManager] Niveau de Fever : {previousLevel} → {_currentFeverLevel}");
        
        // Calculer l'intensité RTPC (0-100)
        float rtpcValue = CalculateRTPCValue(_currentFeverLevel);
        
        // Mettre à jour le RTPC dans Wwise
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.SetFeverIntensity(rtpcValue);
        }
        
        // Notifier les observateurs du changement de niveau
        OnFeverLevelChanged?.Invoke(_currentFeverLevel);
        // Notifier l'état du mode Fever
        
    }

    private float CalculateRTPCValue(int feverLevel)
    {
        // Convertir le niveau (0-maxLevel) en valeur RTPC (0-100)
        if (maxFeverLevel <= 0) return 0f;
        
        float normalizedLevel = (float)feverLevel / maxFeverLevel;
        return normalizedLevel * 100f;
    }

    private void ActivateFeverMode(bool activate)
    {
        if (_isFeverActive == activate) return;

        _isFeverActive = activate;
        Debug.Log($"[FeverManager] Mode Fever {(activate ? "ACTIVÉ" : "DÉSACTIVÉ")} !");

        // Notifier tous les observateurs (unités, UI, etc.)
        OnFeverStateChanged?.Invoke(_isFeverActive);
    }

    // Méthode publique pour obtenir l'intensité actuelle (0-1)
    public float GetCurrentIntensity()
    {
        if (maxFeverLevel <= 0) return 0f;
        return (float)_currentFeverLevel / maxFeverLevel;
    }

    // Classe interne pour implémenter l'interface IComboObserver
    private class FeverComboObserver : IComboObserver
    {
        private readonly FeverManager _manager;

        public FeverComboObserver(FeverManager manager)
        {
            _manager = manager;
        }

        public void OnComboUpdated(int newCombo)
        {
            _manager.HandleComboUpdated(newCombo);
        }

        public void OnComboReset()
        {
            _manager.HandleComboBroken();
            
        }
    }
}

// --- FILE: Scripts/Controllers/GameStateManager.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#region Gameplay Integration

/// <summary>
/// Gère les transitions d'état de jeu et leur impact sur la musique
/// </summary>
public class GameStateManager : MonoBehaviour
{
    public enum GameState 
    { 
        Exploration, 
        Combat, 
        Boss 
    }

    [SerializeField] private GameState currentState = GameState.Exploration;

    public GameState CurrentState
    {
        get => currentState;
        set => currentState = value;
    }
    
    [SerializeField] private KeyCode explorationKey = KeyCode.Alpha1;
    [SerializeField] private KeyCode combatKey = KeyCode.Alpha2;
    [SerializeField] private KeyCode bossKey = KeyCode.Alpha3;

    private void Start()
    {
        // Initialiser l'état de départ
        UpdateGameState(currentState);
    }
    private void OnEnable()
    {
        // S'abonner à l'événement du nouveau registre
        EnemyRegistry.OnBossSpawned += HandleBossSpawn;
    }
    
    private void HandleBossSpawn(EnemyUnit bossUnit)
    {
        Debug.Log($"[GameStateManager] Événement OnBossSpawned reçu pour '{bossUnit.name}'. Changement d'état vers Boss.");
        UpdateGameState(GameState.Boss);
    }
    private void Update()
    {
        // Debug controls
        if (Input.GetKeyDown(explorationKey)) //
            UpdateMusicBasedOnDebugKey("Exploration"); //
        else if (Input.GetKeyDown(combatKey)) //
            UpdateMusicBasedOnDebugKey("Combat"); //
        else if (Input.GetKeyDown(bossKey)) //
            UpdateMusicBasedOnDebugKey("Boss"); //
    }

    public void UpdateGameState(GameState newState, bool immediateTransition = false)
    {
        if (currentState != newState)
        {
            currentState = newState;
            MusicManager.Instance.SetMusicState(newState.ToString(), immediateTransition);
        }
    }

     public void UpdateMusicBasedOnDebugKey(string musicState, bool immediateTransition = false)
    {
        if (MusicManager.Instance != null)
        {
            // Le booléen 'immediateTransition' dans SetMusicState est maintenant moins critique
            MusicManager.Instance.SetMusicState(musicState, immediateTransition);
            Debug.Log($"[GameStateManager_Debug] Musique changée vers : {musicState}");
        }
        else
        {
            Debug.LogWarning("[GameStateManager_Debug] MusicManager.Instance est null.");
        }
    }
}

#endregion


// --- FILE: Scripts/Controllers/GoldController.cs ---
using UnityEngine;
using System.Collections.Generic;
using System;
using Game.Observers;

[DefaultExecutionOrder(-100)]
public class GoldController : MonoBehaviour
{
    public static GoldController Instance { get; private set; }

    [SerializeField] private int initialGold = 100; 

    private int _currentGold;
    private readonly List<IGoldObserver> _observers = new List<IGoldObserver>();

    public event Action<int> OnGoldAdded;
    public event Action<int> OnGoldRemoved;


    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;

        InitializeGold();
    }


    private void OnEnable()
    {
        //SequenceController.OnSequenceExecuted += OnSequenceExecuted;
    }

    private void OnDisable()
    {
      //  SequenceController.OnSequenceExecuted -= OnSequenceExecuted;
    }

    #region Observer Pattern Methods
    public void AddObserver(IGoldObserver observer)
    {
        if (observer == null)
        {
            Debug.LogError($"[{nameof(GoldController)}] Attempt to add a null observer.");
            return;
        }
        if (!_observers.Contains(observer))
        {
            _observers.Add(observer);
            observer.OnGoldUpdated(_currentGold);
        }
    }

    public void RemoveObserver(IGoldObserver observer)
    {
        if (observer == null) return;
        _observers.Remove(observer);
    }

    private void NotifyObservers()
    {
        for (int i = _observers.Count - 1; i >= 0; i--)
        {
            if (_observers[i] != null)
            {
                _observers[i].OnGoldUpdated(_currentGold);
            }
        }
    }
    #endregion

    #region Gold Management Methods
    private void InitializeGold()
    {
        _currentGold = Mathf.Max(0, initialGold);
        NotifyObservers();
    }

    public void AddGold(int amount)
    {
        if (amount < 0)
        {
            Debug.LogError($"[{nameof(GoldController)}] Attempt to add negative gold ({amount}).");
            return;
        }
        if (amount == 0) return;
        _currentGold += amount;
        NotifyObservers();
        OnGoldAdded?.Invoke(amount);
    }

    public void RemoveGold(int amount)
    {
        if (amount < 0)
        {
            Debug.LogError($"[{nameof(GoldController)}] Attempt to remove negative gold ({amount}).");
            return;
        }
        if (amount == 0) return;
        int clampedAmount = Mathf.Min(amount, _currentGold);
        _currentGold -= clampedAmount;
        NotifyObservers();
        OnGoldRemoved?.Invoke(clampedAmount);
        if (clampedAmount != amount)
        {
            Debug.LogWarning($"[{nameof(GoldController)}] Attempted to remove {amount} gold but only {clampedAmount} was available.");
        }
    }

    

    // Helper method to compare two sequences
    private bool AreSequencesEqual(List<KeyCode> seq1, List<KeyCode> seq2)
    {
        if (seq1.Count != seq2.Count) return false;
        for (int i = 0; i < seq1.Count; i++)
        {
            if (seq1[i] != seq2[i])
                return false;
        }
        return true;
    }

    public int GetCurrentGold() => _currentGold;
    #endregion
}

// --- FILE: Scripts/Controllers/HexGridManager.cs ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class HexGridManager : MonoBehaviour
{
    [Header("Grid Logical Settings")] // MODIFIÉ: Titre de section
    [Tooltip("La coordonnée de colonne logique la plus à gauche (peut être négative).")]
    public int minColumn = 0; // NOUVEAU
    [Tooltip("La coordonnée de colonne logique la plus à droite.")]
    public int maxColumn = 9; // ANCIENNEMENT 'columns', renommé pour clarté
    [Tooltip("La coordonnée de ligne logique la plus en bas (peut être négative).")]
    public int minRow = 0;    // NOUVEAU
    [Tooltip("La coordonnée de ligne logique la plus en haut.")]
    public int maxRow = 9;    // ANCIENNEMENT 'rows', renommé pour clarté

    [Header("Tile Physical Settings")] // MODIFIÉ: Titre de section
    public float tileWidth = 1f;
    public float tileHeight = 1f;

    [Tooltip("If true, will use tile's existing row/column values from editor instead of calculating them based on world position.")]
    public bool respectExistingCoordinates = true;

    [Header("Debug Options")]
    [SerializeField] private bool showPathfindingLogs = false;

    public static HexGridManager Instance { get; private set; }

    private List<Tile> allTilesInScene = new List<Tile>();
    private List<IMapObserver> mapObservers = new List<IMapObserver>();

    private Tile[,] tileGrid; // Le tableau interne reste basé sur 0
    private int gridArrayWidth;  // NOUVEAU: Largeur réelle du tableau
    private int gridArrayHeight; // NOUVEAU: Hauteur réelle du tableau

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // NOUVEAU: Calculer les dimensions réelles du tableau
        gridArrayWidth = maxColumn - minColumn + 1;
        gridArrayHeight = maxRow - minRow + 1;

        if (gridArrayWidth <= 0 || gridArrayHeight <= 0)
        {
            Debug.LogError("[HexGridManager] Grid dimensions (maxColumn/maxRow - minColumn/minRow + 1) result in non-positive size. Check your min/max coordinate settings!", this);
            enabled = false;
            return;
        }
        tileGrid = new Tile[gridArrayWidth, gridArrayHeight];
        if (showPathfindingLogs) Debug.Log($"[HexGridManager] Awake: tileGrid initialized with array dimensions {gridArrayWidth}x{gridArrayHeight} to cover logical cols [{minColumn}..{maxColumn}] and rows [{minRow}..{maxRow}].");
    }

    private void Start()
    {
        InitializeExistingTiles();
        SetupNeighborsForAllTiles();
        InitializeTileStatesAfterSetup();
    }

    // NOUVEAU: Méthode pour convertir les coordonnées logiques en indices de tableau
    private Vector2Int ToArrayIndex(int logicalColumn, int logicalRow)
    {
        return new Vector2Int(logicalColumn - minColumn, logicalRow - minRow);
    }

    // NOUVEAU: Vérifie si les coordonnées logiques sont dans les limites définies
    private bool IsLogicalCoordInBounds(int logicalColumn, int logicalRow)
    {
        return logicalColumn >= minColumn && logicalColumn <= maxColumn &&
               logicalRow >= minRow && logicalRow <= maxRow;
    }

    private void InitializeExistingTiles()
    {
        // Correction de l'avertissement CS0618
        Tile[] sceneTilesArray = FindObjectsByType<Tile>(FindObjectsSortMode.None);
        allTilesInScene.AddRange(sceneTilesArray);

        if (allTilesInScene.Count == 0)
        {
            Debug.LogWarning("[HexGridManager] No Tile objects found in the scene during InitializeExistingTiles.");
            return;
        }

        int validTilesInitialized = 0; // NOUVEAU: Compteur pour le log

        foreach (Tile tile in allTilesInScene)
        {
            if (tile.gameObject.activeInHierarchy)
            {
                tile.SetGridManager(this);

                if (!respectExistingCoordinates)
                {
                    AssignGridCoordinatesFromWorldPosition(tile);
                    // Rappel: AssignGridCoordinatesFromWorldPosition doit être revu si vous utilisez
                    // des grilles hexagonales complexes ou des origines de monde arbitraires.
                    // Il doit assigner des tile.column et tile.row LOGIQUES.
                }

                // MODIFIÉ: Valider par rapport aux limites logiques min/max
                if (!IsLogicalCoordInBounds(tile.column, tile.row))
                {
                    Debug.LogWarning($"[HexGridManager] Tile '{tile.name}' at ({tile.transform.position}) has out-of-bounds logical coordinates ({tile.column},{tile.row}). It will be ignored. Logical Bounds: Cols [{minColumn}..{maxColumn}], Rows [{minRow}..{maxRow}]", tile.gameObject);
                    continue; // Ignorer cette tuile si elle est hors des limites logiques définies
                }

                // MODIFIÉ: Utiliser ToArrayIndex pour stocker dans tileGrid
                Vector2Int arrayIndices = ToArrayIndex(tile.column, tile.row);

                if (tileGrid[arrayIndices.x, arrayIndices.y] != null && tileGrid[arrayIndices.x, arrayIndices.y] != tile)
                {
                    Debug.LogWarning($"[HexGridManager] Multiple tiles assigned to logical grid position ({tile.column},{tile.row}) which maps to array index ({arrayIndices.x},{arrayIndices.y}). Overwriting '{tileGrid[arrayIndices.x, arrayIndices.y].name}' with '{tile.name}'. Check tile coordinate setup.", tile.gameObject);
                }
                tileGrid[arrayIndices.x, arrayIndices.y] = tile;
                validTilesInitialized++; // NOUVEAU
            }
        }
        // MODIFIÉ: Log de fin
        if(showPathfindingLogs) Debug.Log($"[HexGridManager] InitializeExistingTiles: Processed {allTilesInScene.Count} tiles from scene. Initialized {validTilesInitialized} valid tiles within logical bounds. Array size: {gridArrayWidth}x{gridArrayHeight}. Logical bounds: Col({minColumn} to {maxColumn}), Row({minRow} to {maxRow}).");
    }

    // IMPORTANT: Cette méthode doit assigner des coordonnées LOGIQUES à tile.column et tile.row.
    // La logique actuelle est très basique et pourrait ne pas fonctionner correctement pour des grilles hexagonales
    // complexes ou si l'origine de votre monde n'est pas (0,0) pour la tuile (minColumn, minRow).
    // Vous devrez peut-être implémenter un algorithme de conversion de coordonnées monde vers axial/cube puis vers offset logique.
    private void AssignGridCoordinatesFromWorldPosition(Tile tile)
    {
        // Exemple simplifié (POINTY-TOPPED, origine de la grille logique (minColumn, minRow) à l'origine du monde (0,0,0) )
        // CECI EST UN PSEUDO-CODE APPROXIMATIF ET DEVRA ÊTRE ADAPTÉ À VOTRE GÉOMÉTRIE EXACTE.
        float approxHexWidth = tileWidth * 0.75f; // Espacement horizontal pour pointy-topped
        float worldX = tile.transform.position.x;
        float worldZ = tile.transform.position.z;

        // Conversion grossière en coordonnées "offset" logiques.
        // Vous aurez besoin d'une conversion plus robuste pour les hexagones.
        // Par exemple, en utilisant des coordonnées axiales ou cubiques comme intermédiaires.
        // Pour l'instant, cela ressemble plus à une grille carrée.

        // Exemple:
        // int q = Mathf.RoundToInt((worldX * Mathf.Sqrt(3)/3 - worldZ / 3) / (tileWidth/2)); // Conversion vers axial q
        // int r = Mathf.RoundToInt((worldZ * 2/3) / (tileHeight/2)); // Conversion vers axial r
        // tile.column = q; // Ou une conversion q,r vers offset si vous préférez les offsets logiques
        // tile.row = r;    // (ce qui est le cas ici avec minColumn, minRow)

        // Placeholder (ancienne logique, à remplacer par une vraie conversion hex vers logique):
        int col = minColumn + Mathf.RoundToInt(worldX / approxHexWidth);
        int r = minRow + Mathf.RoundToInt(worldZ / tileHeight);
        // La logique ci-dessus est très probablement incorrecte pour une grille hexagonale.
        // Vous DEVEZ la remplacer par un algorithme correct de conversion world-to-hex-offset.

        tile.column = col;
        tile.row = r;

        // Debug.Log($"[HexGridManager] AssignGridCoordinatesFromWorldPosition: Assigned logical coords ({col},{r}) to tile {tile.name} at world pos {tile.transform.position}");
    }


    private void SetupNeighborsForAllTiles()
    {
        foreach (Tile tile in allTilesInScene)
        {
            // MODIFIÉ: S'assurer que la tuile est dans les limites avant de chercher des voisins
            if (tile != null && IsLogicalCoordInBounds(tile.column, tile.row))
            {
                // S'assurer aussi que c'est bien CETTE tuile qui est enregistrée aux bonnes coordonnées
                Vector2Int arrayIndices = ToArrayIndex(tile.column, tile.row);
                if (tileGrid[arrayIndices.x, arrayIndices.y] == tile)
                {
                    List<Tile> neighbors = FindNeighborsForTile(tile.column, tile.row);
                    tile.SetNeighbors(neighbors);
                }
            }
        }
    }

    public List<Tile> GetAdjacentTiles(Tile centerTile)
    {
        if (centerTile == null || !IsLogicalCoordInBounds(centerTile.column, centerTile.row)) return new List<Tile>();
        return FindNeighborsForTile(centerTile.column, centerTile.row);
    }

    // Les paramètres logicalCol et logicalRow sont des coordonnées logiques
    private List<Tile> FindNeighborsForTile(int logicalCol, int logicalRow)
    {
        List<Tile> neighbors = new List<Tile>();
        // Directions pour pointy-topped (basées sur les coordonnées logiques)
        int[][] directions = (logicalCol % 2 == 0) ? // Ou parité de (logicalCol - minColumn) si la structure offset dépend de l'index 0 du tableau
            new int[][] { new int[]{0, -1}, new int[]{1, -1}, new int[]{1, 0}, new int[]{0, 1}, new int[]{-1, 0}, new int[]{-1, -1} } :
            new int[][] { new int[]{0, -1}, new int[]{1, 0}, new int[]{1, 1}, new int[]{0, 1}, new int[]{-1, 1}, new int[]{-1, 0} };

        foreach (int[] dir in directions)
        {
            int neighborLogicalCol = logicalCol + dir[0];
            int neighborLogicalRow = logicalRow + dir[1];

            // MODIFIÉ: Valider les coordonnées logiques du voisin et utiliser GetTileAt
            Tile neighbor = GetTileAt(neighborLogicalCol, neighborLogicalRow); // GetTileAt gère la conversion et les limites
            if (neighbor != null)
            {
                neighbors.Add(neighbor);
            }
        }
        return neighbors;
    }

    // FindNeighborsForTile_FlatTop_OddQ serait à adapter de la même manière si vous l'utilisez.

    private void InitializeTileStatesAfterSetup()
    {
        StartCoroutine(DelayedTileInitialization());
    }

    private IEnumerator DelayedTileInitialization()
    {
        yield return new WaitForEndOfFrame();
        foreach (Tile tile in allTilesInScene)
        {
            // MODIFIÉ: Vérifier si la tuile est valide et à sa place dans la grille logique
            if (tile != null && IsLogicalCoordInBounds(tile.column, tile.row))
            {
                Vector2Int arrayIndices = ToArrayIndex(tile.column, tile.row);
                if (tileGrid[arrayIndices.x, arrayIndices.y] == tile)
                {
                    MusicReactiveTile musicTile = tile as MusicReactiveTile;
                    if (musicTile != null)
                    {
                        musicTile.InitializeReactiveVisualState(); // Nom de méthode corrigé
                    }
                }
            }
        }
    }

    public Tile GetClosestTile(Vector3 position)
    {
        Tile closest = null;
        float minDistSq = Mathf.Infinity;
        foreach (Tile tile in allTilesInScene)
        {
            if (tile == null || !tile.gameObject.activeInHierarchy) continue;
            // NOUVEAU: S'assurer que la tuile est dans les limites logiques avant de la considérer
            if (!IsLogicalCoordInBounds(tile.column, tile.row)) continue;

            float distSq = (tile.transform.position - position).sqrMagnitude;
            if (distSq < minDistSq)
            {
                minDistSq = distSq;
                closest = tile;
            }
        }
        if (closest == null && allTilesInScene.Count > 0 && showPathfindingLogs) {
             Debug.LogWarning($"[HexGridManager] GetClosestTile to {position} returned null, but there are tiles in scene. Check tile states and logical bounds setup.");
        }
        return closest;
    }

    // Les paramètres currentCol, currentRow, targetCol, targetRow sont LOGIQUES
    public Tile GetNextNeighborTowardsTarget(int currentCol, int currentRow, int targetCol, int targetRow, Unit requestingUnit = null)
    {
        // La logique interne de cette méthode (A*, distances, etc.) devrait déjà fonctionner avec
        // des coordonnées logiques (positives ou négatives).
        // Il faut juste s'assurer que tous les appels à GetTileAt et les accès aux voisins
        // utilisent bien des coordonnées logiques et que les bornes sont respectées.

        if (showPathfindingLogs)
            Debug.Log($"[HexGridManager] Pathfinding: From logical ({currentCol},{currentRow}) to logical ({targetCol},{targetRow}) for unit '{requestingUnit?.name ?? "N/A"}'");

        if (currentCol == targetCol && currentRow == targetRow)
        {
            if (showPathfindingLogs) Debug.Log("[HexGridManager] Pathfinding: Already at target.");
            return null;
        }

        Tile currentTile = GetTileAt(currentCol, currentRow); // Utilise la version modifiée
        if (currentTile == null)
        {
            Debug.LogError($"[HexGridManager] Pathfinding: Current tile at logical ({currentCol},{currentRow}) is null!", this);
            return null;
        }

        List<Tile> neighbors = currentTile.Neighbors; // Neighbors sont déjà des objets Tile valides
        if (neighbors.Count == 0)
        {
            if (showPathfindingLogs) Debug.LogWarning($"[HexGridManager] Pathfinding: Tile logical ({currentCol},{currentRow}) has no neighbors.");
            return null;
        }

        Tile bestCandidate = null;
        float minDistanceToTarget = float.MaxValue;

        foreach (Tile neighbor in neighbors) // neighbor.column et neighbor.row sont déjà logiques
        {
            if (neighbor.column == targetCol && neighbor.row == targetRow)
            {
                if (!neighbor.IsOccupied &&
                    (TileReservationController.Instance == null || !TileReservationController.Instance.IsTileReservedByOtherUnit(new Vector2Int(neighbor.column, neighbor.row), requestingUnit)))
                {
                    if (showPathfindingLogs) Debug.Log($"[HexGridManager] Pathfinding: Target logical ({targetCol},{targetRow}) is a direct, available neighbor.");
                    return neighbor;
                }
                else
                {
                    if (showPathfindingLogs) Debug.Log($"[HexGridManager] Pathfinding: Target logical ({targetCol},{targetRow}) is a neighbor but occupied/reserved.");
                }
                break;
            }
        }

        foreach (Tile neighbor in neighbors)
        {
            if (neighbor.IsOccupied || (TileReservationController.Instance != null && TileReservationController.Instance.IsTileReservedByOtherUnit(new Vector2Int(neighbor.column, neighbor.row), requestingUnit)))
            {
                if (showPathfindingLogs) Debug.Log($"[HexGridManager] Pathfinding: Neighbor logical ({neighbor.column},{neighbor.row}) is occupied or reserved by other. Skipping.");
                continue;
            }

            float distance = HexDistance(neighbor.column, neighbor.row, targetCol, targetRow); // HexDistance utilise des coords logiques
            if (distance < minDistanceToTarget)
            {
                minDistanceToTarget = distance;
                bestCandidate = neighbor;
            }
            else if (distance == minDistanceToTarget && bestCandidate != null)
            {
                if (neighbor.column < bestCandidate.column || (neighbor.column == bestCandidate.column && neighbor.row < bestCandidate.row))
                {
                    bestCandidate = neighbor;
                }
            }
        }

        if (bestCandidate != null)
        {
            if (showPathfindingLogs) Debug.Log($"[HexGridManager] Pathfinding: Best next step is logical ({bestCandidate.column},{bestCandidate.row}), dist to target: {minDistanceToTarget}.");
        }
        else
        {
            if (showPathfindingLogs) Debug.LogWarning($"[HexGridManager] Pathfinding: No available (unoccupied/unreserved by others) neighbor found to move towards target.");
        }
        return bestCandidate;
    }

    public Tile GetNeighborAwayFromTarget(int startCol, int startRow, int targetCol, int targetRow)
    {
        Tile startTile = GetTileAt(startCol, startRow);
        if (startTile == null) return null;

        Tile farthestNeighbor = null;
        float maxDistSq = -1;

        foreach (var neighbor in startTile.Neighbors)
        {
            if (neighbor == null) continue;

            float distSq = (new Vector2(neighbor.column, neighbor.row) - new Vector2(targetCol, targetRow)).sqrMagnitude;
            if (distSq > maxDistSq)
            {
                maxDistSq = distSq;
                farthestNeighbor = neighbor;
            }
        }
        return farthestNeighbor;
    }

    // ConvertOffsetToCube_OddQ et HexDistance devraient fonctionner correctement avec des coordonnées logiques négatives
    // car les maths sous-jacentes des coordonnées cubiques le permettent.
    private Vector3Int ConvertOffsetToCube_OddQ(int col, int row)
    {
        int cube_x = col;
        int cube_z = row - (col - (col & 1)) / 2;
        int cube_y = -cube_x - cube_z;
        return new Vector3Int(cube_x, cube_y, cube_z);
    }

    public int HexDistance(int col1, int row1, int col2, int row2)
    {
        Vector3Int cube1 = ConvertOffsetToCube_OddQ(col1, row1);
        Vector3Int cube2 = ConvertOffsetToCube_OddQ(col2, row2);
        return (Mathf.Abs(cube1.x - cube2.x) + Mathf.Abs(cube1.y - cube2.y) + Mathf.Abs(cube1.z - cube2.z)) / 2;
    }

    // MODIFIÉ: Les paramètres logicalColumn, logicalRow sont des coordonnées logiques
    public Tile GetTileAt(int logicalColumn, int logicalRow)
    {
        // MODIFIÉ: Valider par rapport aux limites logiques et convertir en indices de tableau
        if (IsLogicalCoordInBounds(logicalColumn, logicalRow))
        {
            Vector2Int arrayIndices = ToArrayIndex(logicalColumn, logicalRow);
            return tileGrid[arrayIndices.x, arrayIndices.y];
        }
        // Optionnel: Log verbeux pour les accès hors limites
        // if (showPathfindingLogs) Debug.LogWarning($"[HexGridManager] Attempted to get tile at logical ({logicalColumn},{logicalRow}) which is out of defined logical bounds: Cols [{minColumn}..{maxColumn}], Rows [{minRow}..{maxRow}]");
        return null;
    }

    // Les paramètres centerColumn, centerRow sont LOGIQUES
    public List<Tile> GetTilesWithinRange(int centerLogicalColumn, int centerLogicalRow, int range)
    {
        List<Tile> tilesInRange = new List<Tile>();
        if (range < 0) { Debug.LogError("Range must be non-negative."); return tilesInRange; }

        Tile centerTile = GetTileAt(centerLogicalColumn, centerLogicalRow); // Utilise la version modifiée
        if (centerTile == null)
        {
            // MODIFIÉ: Log si la tuile centrale n'est pas trouvée avec des coordonnées logiques
            Debug.LogError($"[HexGridManager] Center tile at logical ({centerLogicalColumn},{centerLogicalRow}) not found for GetTilesWithinRange.");
            return tilesInRange;
        }

        if (range == 0) {
            tilesInRange.Add(centerTile);
            return tilesInRange;
        }

        Queue<Tile> queue = new Queue<Tile>();
        HashSet<Tile> visited = new HashSet<Tile>();
        Dictionary<Tile, int> distances = new Dictionary<Tile, int>();

        queue.Enqueue(centerTile);
        visited.Add(centerTile);
        distances[centerTile] = 0;
        tilesInRange.Add(centerTile);

        while (queue.Count > 0)
        {
            Tile current = queue.Dequeue();
            int currentDist = distances[current];

            if (currentDist >= range) continue;

            foreach (Tile neighbor in current.Neighbors) // Les voisins sont déjà des tuiles valides
            {
                if (neighbor != null && !visited.Contains(neighbor))
                {
                    visited.Add(neighbor);
                    distances[neighbor] = currentDist + 1;
                    tilesInRange.Add(neighbor);
                    queue.Enqueue(neighbor);
                }
            }
        }
        return tilesInRange;
    }

    #region Observer Pattern Management
    public void RegisterObserver(IMapObserver observer)
    {
        if (!mapObservers.Contains(observer)) mapObservers.Add(observer);
    }

    public void UnregisterObserver(IMapObserver observer)
    {
        mapObservers.Remove(observer);
    }

    public void NotifyTileChanged(Tile tile)
    {
        foreach (var observer in mapObservers)
        {
            observer.OnTileStateChanged(tile);
        }
    }

    public int GetTilesCount() => allTilesInScene.Count(t => t != null && IsLogicalCoordInBounds(t.column, t.row)); // Compte seulement les tuiles valides
    #endregion
}

// --- FILE: Scripts/Controllers/InputTargetingManager.cs ---
using UnityEngine;
using UnityEngine.InputSystem;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Gère la détection des cibles via la souris ou la manette.
/// Lance des événements pour notifier les autres systèmes (comme le BannerController)
/// des intentions du joueur (survol, sélection) sans gérer lui-même la logique de jeu.
/// Ce script remplace la partie "détection" de l'ancien MouseManager.
/// </summary>
public class InputTargetingManager : MonoBehaviour
{
    public static InputTargetingManager Instance { get; private set; }

    // --- Événements Publics ---
    // MODIFIED: Events now pass a generic GameObject, which can be a building or a unit.
    public static event System.Action<GameObject> OnTargetHovered;
    public static event System.Action OnHoverEnded;
    public static event System.Action<GameObject> OnTargetSelected;

    [Header("Raycast Settings")]
    [SerializeField] private LayerMask tileLayerMask;
    [SerializeField] private LayerMask buildingLayerMask;
    [SerializeField] private LayerMask unitLayerMask; // NEW: Layer mask for your targetable units.
    [SerializeField] private float raycastDistance = 100f;

    [Header("Mouse Settings")]
    [SerializeField] private float clickCooldown = 0.2f;
    [SerializeField] private Texture2D defaultCursorTexture;
    [SerializeField] private Texture2D hoverCursorTexture;
    [SerializeField] private Vector2 cursorHotspot = Vector2.zero;

    [Header("Gamepad Targeting")]
    [SerializeField] private bool isTargetingMode = false;
    // MODIFIED: The list now holds GameObjects. Note: Gamepad cycling will only find Buildings by default.
    private List<GameObject> targetableObjects = new List<GameObject>();
    private int currentTargetIndex = 0;

    [Header("Debugging")]
    [SerializeField] private bool debugLogs = true;

    private float lastClickTime;
    // MODIFIED: The currently hovered object is now a GameObject.
    private GameObject currentlyHoveredObject;
    private BuildingSelectionFeedback currentFeedback;

    void Awake()
    {
        // --- Singleton Initialisation ---
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    private void Start()
    {
        lastClickTime = -clickCooldown;
        SetCursor(defaultCursorTexture);
    }

    private void OnEnable()
    {
        if (InputManager.Instance != null)
        {
            InputManager.Instance.GameplayActions.PlaceBanner.performed += OnSelectPerformed;
            InputManager.Instance.GameplayActions.CycleTarget.performed += OnCycleTargetPressed;
        }
        RhythmGameCameraController.OnToggleCameraLockRequested += HandleToggleCameraLockRequest;
    }

    private void OnDisable()
    {
        if (InputManager.Instance != null)
        {
            InputManager.Instance.GameplayActions.PlaceBanner.performed -= OnSelectPerformed;
            InputManager.Instance.GameplayActions.CycleTarget.performed -= OnCycleTargetPressed;
        }
        RhythmGameCameraController.OnToggleCameraLockRequested -= HandleToggleCameraLockRequest;

        UpdateHoveredTarget(null);
        SetCursor(defaultCursorTexture);
    }

    void Update()
    {
        // La détection à la souris a la priorité si la souris bouge.
        if (Input.GetAxis("Mouse X") != 0 || Input.GetAxis("Mouse Y") != 0 || isTargetingMode == false)
        {
            HandleMouseTargeting();
        }
    }

    /// <summary>
    /// Gère la sélection via clic de souris. La sélection via manette est gérée par OnSelectPerformed.
    /// </summary>
    private void HandleMouseTargeting()
    {
        if (isTargetingMode) return;

        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        // MODIFIED: Method now finds any targetable GameObject.
        GameObject foundTarget = GetTargetableFromRay(ray);
        UpdateHoveredTarget(foundTarget);

        // Gestion du clic pour la sélection
        if (Input.GetMouseButtonDown(0) && Time.time - lastClickTime > clickCooldown)
        {
            lastClickTime = Time.time;
            if (currentlyHoveredObject != null)
            {
                 if(debugLogs) Debug.Log($"[InputTargetingManager] Mouse click selection: {currentlyHoveredObject.name}");
                 OnTargetSelected?.Invoke(currentlyHoveredObject); // MODIFIED: Pass the GameObject
            }
            else
            {
                 // Clic dans le vide, on notifie aussi pour que les systèmes puissent réagir (ex: enlever la bannière)
                 if(debugLogs) Debug.Log($"[InputTargetingManager] Mouse click on empty space.");
                 OnTargetSelected?.Invoke(null); // MODIFIED: Pass null
            }
        }
    }

    /// <summary>
    /// Met à jour le bâtiment actuellement survolé et déclenche les événements et la surbrillance.
    /// </summary>
    private void UpdateHoveredTarget(GameObject newTarget) // MODIFIED: Parameter is a GameObject
    {
        if (newTarget != currentlyHoveredObject)
        {
            // 1. Nettoyer l'ancien bâtiment
            if (currentlyHoveredObject != null)
            {
                if(debugLogs) Debug.Log($"[InputTargetingManager] Hover ended on {currentlyHoveredObject.name}");
                OnHoverEnded?.Invoke();

                if (currentFeedback != null && currentFeedback.CurrentState == OutlineState.Hover)
                {
                    currentFeedback.SetOutlineState(OutlineState.Default);
                }
            }

            // 2. Mettre à jour avec le nouveau bâtiment
            currentlyHoveredObject = newTarget;

            if (currentlyHoveredObject != null)
            {
                if(debugLogs) Debug.Log($"[InputTargetingManager] Hover started on {currentlyHoveredObject.name}");
                OnTargetHovered?.Invoke(currentlyHoveredObject); // MODIFIED: Pass the GameObject

                // Gérer l'outline (will only work if the hovered object has this component)
                currentFeedback = currentlyHoveredObject.GetComponent<BuildingSelectionFeedback>();
                if (currentFeedback != null && currentFeedback.CurrentState == OutlineState.Default)
                {
                    currentFeedback.SetOutlineState(OutlineState.Hover);
                }
                SetCursor(hoverCursorTexture);
            }
            else
            {
                // Pas de nouveau bâtiment
                currentFeedback = null;
                SetCursor(defaultCursorTexture);
            }
        }
    }

    private void SetCursor(Texture2D cursorTexture)
    {
        if (cursorTexture != null)
        {
            Cursor.SetCursor(cursorTexture, cursorHotspot, CursorMode.Auto);
        }
    }

    #region Gamepad Targeting

    private void HandleToggleCameraLockRequest()
    {
        if (isTargetingMode) ExitTargetingMode();
        else EnterTargetingMode();
    }

    private void EnterTargetingMode()
    {
        if (debugLogs) Debug.Log("[InputTargetingManager] Entering targeting mode WITH camera lock.");
        ScanForTargetableObjects();
        if (targetableObjects.Count == 0) return;

        isTargetingMode = true;
        SelectClosestTargetAsDefault();
        UpdateGamepadTarget();

        var cameraController = FindFirstObjectByType<RhythmGameCameraController>();
        if (cameraController != null && targetableObjects.Count > 0)
        {
            cameraController.LockOnTarget(targetableObjects[currentTargetIndex].transform);
        }
    }

    private void ExitTargetingMode()
    {
        if (debugLogs) Debug.Log("[InputTargetingManager] Exiting targeting mode.");
        isTargetingMode = false;
        UpdateHoveredTarget(null); // Clear hover state

        var cameraController = FindFirstObjectByType<RhythmGameCameraController>();
        if (cameraController != null) cameraController.UnlockCamera();

        targetableObjects.Clear();
    }

    private void OnCycleTargetPressed(InputAction.CallbackContext context)
    {
        if (!isTargetingMode)
        {
            InitializeTargetingWithoutCameraLock();
            return;
        }

        if (targetableObjects.Count <= 1) return;

        float axisValue = context.ReadValue<float>();
        if (Mathf.Abs(axisValue) < 0.5f) return;

        if (axisValue > 0) currentTargetIndex = (currentTargetIndex + 1) % targetableObjects.Count;
        else currentTargetIndex = (currentTargetIndex - 1 + targetableObjects.Count) % targetableObjects.Count;

        UpdateGamepadTarget();
    }

    private void InitializeTargetingWithoutCameraLock()
    {
        if (debugLogs) Debug.Log("[InputTargetingManager] Initializing targeting mode without camera lock.");
        ScanForTargetableObjects();
        if (targetableObjects.Count == 0) return;

        isTargetingMode = true;
        SelectClosestTargetAsDefault();

        if (targetableObjects.Count > 0)
        {
            GameObject targetObject = targetableObjects[currentTargetIndex];
            UpdateHoveredTarget(targetObject);
        }
    }

    private void OnSelectPerformed(InputAction.CallbackContext context)
    {
        if (!isTargetingMode || currentlyHoveredObject == null) return;

        if (debugLogs) Debug.Log($"[InputTargetingManager] Gamepad selection: {currentlyHoveredObject.name}");
        OnTargetSelected?.Invoke(currentlyHoveredObject);
    }

    private void UpdateGamepadTarget()
    {
        CleanupDestroyedTargets();

        if (targetableObjects.Count == 0)
        {
            ExitTargetingMode();
            return;
        }

        if (currentTargetIndex >= targetableObjects.Count)
        {
            currentTargetIndex = 0;
        }

        GameObject targetObject = targetableObjects[currentTargetIndex];
        UpdateHoveredTarget(targetObject);

        var cameraController = FindFirstObjectByType<RhythmGameCameraController>();
        if (cameraController != null && cameraController.IsLocked)
        {
            cameraController.LockOnTarget(targetObject.transform);
        }
    }

    private void CleanupDestroyedTargets()
    {
        int originalCount = targetableObjects.Count;
        targetableObjects.RemoveAll(obj => obj == null);

        if (originalCount != targetableObjects.Count && debugLogs)
        {
            Debug.Log($"[InputTargetingManager] Cleaned up {originalCount - targetableObjects.Count} destroyed objects. Remaining: {targetableObjects.Count}");
        }
    }

    private void ScanForTargetableObjects()
    {
        // NOTE: This scan only finds 'Building' objects for gamepad cycling.
        // To include units, you would need to find them and add their GameObjects to the list.
        // For example:
        // var units = FindObjectsOfType<YourUnitScript>().Select(u => u.gameObject);
        // targetableObjects.AddRange(units);
        targetableObjects.Clear();
        var buildings = FindObjectsOfType<Building>()
            .Where(b => b != null && b.IsTargetable)
            .Select(b => b.gameObject); // Select the GameObject

        targetableObjects.AddRange(buildings);

        targetableObjects = targetableObjects
            .OrderBy(b => b.transform.position.x)
            .ThenBy(b => b.transform.position.z)
            .ToList();

        if(debugLogs) Debug.Log($"[InputTargetingManager] Found {targetableObjects.Count} targetable objects for gamepad cycling.");
    }

    private void SelectClosestTargetAsDefault()
    {
        if (targetableObjects.Count == 0) return;
        var cameraPos = Camera.main.transform.position;
        float closestDist = float.MaxValue;

        for (int i = 0; i < targetableObjects.Count; i++)
        {
            float dist = Vector3.Distance(cameraPos, targetableObjects[i].transform.position);
            if (dist < closestDist)
            {
                closestDist = dist;
                currentTargetIndex = i;
            }
        }
    }

    #endregion

    #region Utility

    /// <summary>
    /// Lance un rayon et retourne le GameObject trouvé, que ce soit un bâtiment ou une unité.
    /// </summary>
    private GameObject GetTargetableFromRay(Ray ray)
    {
        // MODIFIED: Combine building and unit layers for the raycast.
        LayerMask combinedMask = buildingLayerMask | unitLayerMask;

        // Priority 1: Toucher directement un collider sur le bâtiment ou une unité.
        if (Physics.Raycast(ray, out RaycastHit hitInfo, raycastDistance, combinedMask))
        {
            // Check if the hit object is a Building first
            Building building = hitInfo.collider.GetComponentInParent<Building>();
            if (building != null)
            {
                return building.gameObject;
            }

            // If not a building, return the GameObject directly. This will be your unit.
            return hitInfo.collider.gameObject;
        }

        // Priority 2: Toucher une tuile qui contient un bâtiment
        if (Physics.Raycast(ray, out hitInfo, raycastDistance, tileLayerMask))
        {
            Tile tile = hitInfo.collider.GetComponent<Tile>();
            if (tile != null && tile.currentBuilding != null)
            {
                return tile.currentBuilding.gameObject;
            }
        }

        return null; // Rien n'a été trouvé
    }

    #endregion
}

// --- FILE: Scripts/Controllers/MomentumManager.cs ---
﻿using System;
using Gameplay;
using UnityEngine;

/// <summary>
/// Gère la ressource de Momentum du joueur.
/// Le Momentum est gagné par des actions réussies et se dégrade avec le temps.
/// Il est divisé en charges qui peuvent être dépensées pour des actions puissantes.
/// </summary>
public class MomentumManager : MonoBehaviour
{
    public static MomentumManager Instance { get; private set; }

    // --- CONSTANTES ---
    private const float MAX_MOMENTUM = 3.0f;
    private const int DECAY_THRESHOLD_BEATS = 24; // Nombre de beats d'inactivité avant que la dégradation ne commence.
    private const float DECAY_AMOUNT_PER_BEAT = 0.05f; // Vitesse de la dégradation.

    // --- ÉVÉNEMENTS ---
    public event Action<int, float> OnMomentumChanged; // Notifie l'UI. int: charges, float: valeur brute.

    // --- PROPRIÉTÉS PUBLIQUES ---
    public int CurrentCharges { get; private set; }
    public float CurrentMomentumValue => _currentMomentum;

    // --- ÉTAT INTERNE ---
    private float _currentMomentum;
    private int _lastBeatCountWithoutGain;
    private MusicManager _musicManager;
    private AllyUnitRegistry _allyUnitRegistry;

    private bool _momentumGainFlag = false;

    protected void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Debug.LogWarning("[MomentumManager] Multiple instances detected. Destroying duplicate.", gameObject);
            Destroy(gameObject);
            return;
        }
        // Initialisation de l'état
        _currentMomentum = 0f;
        CurrentCharges = 0;
        _lastBeatCountWithoutGain = 0;
        _momentumGainFlag = false;
    }

    private void Start()
    {
        // Récupération de la référence au MusicManager, source de vérité du rythme.
        _musicManager = MusicManager.Instance;
        if (_musicManager == null)
        {
            Debug.LogError("MusicManager not found! MomentumManager requires it to function.");
            enabled = false;
            return;
        }
        
        // Abonnement à l'événement de battement.
        _musicManager.OnBeat += HandleBeat;
        _allyUnitRegistry = FindFirstObjectByType<AllyUnitRegistry>(); // Alternative: passer par un manager central si existant
        if (_allyUnitRegistry != null)
        {
            _allyUnitRegistry.OnDefensiveKillConfirmed += HandleDefensiveKill;
        }
    }

    private void OnDestroy()
    {
        // Se désabonner pour éviter les fuites de mémoire.
        if (_musicManager != null)
        {
            _musicManager.OnBeat -= HandleBeat;
        }
        if (_allyUnitRegistry != null)
        {
            _allyUnitRegistry.OnDefensiveKillConfirmed -= HandleDefensiveKill;
        }
    }
    private void HandleDefensiveKill(AllyUnit defensiveKiller)
    {
        if (defensiveKiller.MomentumGainOnObjectiveComplete > 0)
        {
            AddMomentum(defensiveKiller.MomentumGainOnObjectiveComplete);
        }
    }
    /// <summary>
    /// Ajoute du Momentum à la jauge. Appelé par des actions de jeu réussies.
    /// </summary>
    /// <param name="amount">La quantité de momentum à ajouter (fraction de charge).</param>
    public void AddMomentum(float amount)
    {
        _momentumGainFlag = true;
        
        float previousMomentum = _currentMomentum;
        _currentMomentum = Mathf.Clamp(_currentMomentum + amount, 0f, MAX_MOMENTUM);
        Debug.Log($"[MomentumManager] Ajout de {amount} de momentum. Valeur actuelle: {_currentMomentum}");
        if (_currentMomentum != previousMomentum)
        {
            UpdateChargesAndNotify();
        }
    }

    /// <summary>
    /// Tente de dépenser un certain nombre de charges de Momentum.
    /// </summary>
    /// <param name="chargeCost">Le nombre de charges requises.</param>
    /// <returns>True si le joueur a assez de charges et qu'elles ont été dépensées, False sinon.</returns>
    public bool TrySpendMomentum(int chargeCost)
    {
        if (chargeCost <= 0) return true; // Pas de coût, toujours un succès.
        if (CurrentCharges < chargeCost) return false; // Pas assez de charges.

        _currentMomentum -= chargeCost;
        UpdateChargesAndNotify();
        return true;
    }

    /// <summary>
    /// Gère la logique de décroissance à chaque battement de la musique.
    /// </summary>
    private void HandleBeat(float beatDuration)
    {
        if (_momentumGainFlag)
        {
            _lastBeatCountWithoutGain = 0;
            _momentumGainFlag = false;
            Debug.Log("[MomentumManager] Gain de Momentum détecté. Compteur d'inactivité réinitialisé.");
        }

        _lastBeatCountWithoutGain++;
        Debug.Log($"[MomentumManager] Compteur d'inactivité: {_lastBeatCountWithoutGain} beats.");
        if (_lastBeatCountWithoutGain > DECAY_THRESHOLD_BEATS)
        {
            float momentumAvantCalcul = _currentMomentum;

            if (momentumAvantCalcul <= 0)
            {
                return;
            }
            
            Debug.LogWarning($"[HandleBeat] Début de la DÉCROISSANCE. Compteur: {_lastBeatCountWithoutGain}, Momentum actuel: {momentumAvantCalcul}");

            float palier = Mathf.Floor(momentumAvantCalcul);
            float momentumApresSoustraction = momentumAvantCalcul - DECAY_AMOUNT_PER_BEAT;
            float momentumFinal = Mathf.Max(momentumApresSoustraction, palier);

            _currentMomentum = momentumFinal;
        
            if (_currentMomentum != momentumAvantCalcul)
            {
                Debug.LogWarning($"[HandleBeat] Changement appliqué ! Nouvelle valeur : {_currentMomentum}");
                UpdateChargesAndNotify();
            }
        }
        
    }

    /// <summary>
    /// Met à jour les charges, la valeur brute et notifie les observateurs.
    /// </summary>
    private void UpdateChargesAndNotify()
    {
        CurrentCharges = Mathf.FloorToInt(_currentMomentum);
        OnMomentumChanged?.Invoke(CurrentCharges, _currentMomentum);
    }
}

// --- FILE: Scripts/Controllers/MusicManager.cs ---
using UnityEngine;
using System;
using System.Collections;
using AK.Wwise; // Wwise Unity namespace

public class MusicManager : MonoBehaviour
{
    public static MusicManager Instance { get; private set; }

    [Header("Wwise Configuration")]
    [Tooltip("Event Wwise pour démarrer la lecture du Music Switch Container principal (ex: Play_Level_Music).")]
    [SerializeField] private AK.Wwise.Event playMusicEvent;

    [Header("Music Switches (doivent correspondre au groupe 'MusicState' dans Wwise)")]
    public AK.Wwise.Switch explorationSwitch;
    public AK.Wwise.Switch combatSwitch;
    public AK.Wwise.Switch bossSwitch;
    public AK.Wwise.Switch silenceSwitch;
    
    [Tooltip("Switch Wwise pour la musique du menu principal.")]
    public AK.Wwise.Switch mainMenuSwitch;
    [Tooltip("Switch Wwise pour la musique du Hub.")]
    public AK.Wwise.Switch hubSwitch; 
    [Tooltip("Switch Wwise pour l'état de fin de partie (victoire/défaite).")]
    public AK.Wwise.Switch endGameSwitch;

    [Header("Wwise RTPCs")]
    [Tooltip("RTPC pour l'intensité du mode Fever.")]
    [SerializeField] private AK.Wwise.RTPC feverIntensityRTPC;
    
    
    [Header("Settings")]
    [SerializeField] private float minTimeBetweenBeats = 0.1f;
    [SerializeField] private string initialMusicState = "Exploration";

    // --- ÉVÉNEMENTS PUBLICS ---
    /// <summary>
    /// Événement principal déclenché à chaque battement de la musique Wwise.
    /// Fournit la durée exacte de ce battement en secondes.
    /// </summary>
    public event Action<float> OnBeat;
    public event Action<string> OnMusicStateChanged;


    // --- PROPRIÉTÉS PUBLIQUES (POUR COMPATIBILITÉ) ---
    /// <summary>
    /// Propriété indiquant si le dernier battement a été traité. Utile pour les coroutines attendant un beat.
    /// </summary>
    public static bool LastBeatWasProcessed { get; private set; }

    /// <summary>
    /// Propriété publique pour obtenir la durée du battement actuel en secondes.
    /// </summary>
    public float BeatDuration => currentBeatDuration;

    // --- VARIABLES PRIVÉES ---
    private string currentMusicState;
    private uint playingID_MusicEvent = AkUnitySoundEngine.AK_INVALID_PLAYING_ID;
    private float currentBeatDuration = 0.5f;
    public int PublicBeatCount { get; private set; } = 0;
    private bool musicPlaying = false;
    private float lastBeatTime;
    private bool beatOccurredThisFrame = false; // Flag interne pour LastBeatWasProcessed

    public string CurrentWwiseMusicState => currentMusicState;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            if (transform.parent != null)
            {
                transform.SetParent(null);
            }
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
            return;
        }
    }

    private void Start()
    {
        if (AkUnitySoundEngine.IsInitialized())
        {
         
            InitializeMusicAndSetState(initialMusicState);
        }
        else
        {
            Debug.LogError("[MusicManager] Wwise n'est pas initialisé au Start ! La musique ne démarrera pas.");
        }
    }

    private void Update()
    {
        if (AkUnitySoundEngine.IsInitialized())
        {
            AkUnitySoundEngine.RenderAudio();
        }
    }

    // Mis dans LateUpdate pour s'assurer qu'il est réinitialisé après que tous les Update des autres scripts aient eu lieu.
    private void LateUpdate()
    {
        LastBeatWasProcessed = beatOccurredThisFrame;
        beatOccurredThisFrame = false; // Réinitialiser pour la prochaine frame
    }

    private void InitializeMusicAndSetState(string targetState)
    {
        if (!AkUnitySoundEngine.IsInitialized())
        {
            Debug.LogError($"[MusicManager] InitializeMusicAndSetState({targetState}) appelé mais Wwise n'est pas prêt.");
            musicPlaying = false;
            return;
        }

        if (playMusicEvent == null || !playMusicEvent.IsValid())
        {
            Debug.LogError("[MusicManager] 'playMusicEvent' n'est pas assigné ou n'est pas valide !");
            musicPlaying = false;
            return;
        }

        if (playingID_MusicEvent == AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
        {
            playingID_MusicEvent = playMusicEvent.Post(
                gameObject,
                (uint)(AkCallbackType.AK_MusicSyncBeat | AkCallbackType.AK_EnableGetMusicPlayPosition | AkCallbackType.AK_EndOfEvent),
                OnMusicCallback,
                null
            );

            if (playingID_MusicEvent == AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
            {
                Debug.LogError($"[MusicManager] Échec du Post de playMusicEvent '{playMusicEvent.Name}'.");
                musicPlaying = false;
                return;
            }
            Debug.Log($"[MusicManager] Music Event '{playMusicEvent.Name}' NOUVELLEMENT posté. ID: {playingID_MusicEvent}");
        }

        musicPlaying = true;

        string previousLogicalState = currentMusicState;
        currentMusicState = "";
        SetMusicState(targetState, true);
    }


    private void OnMusicCallback(object in_cookie, AkCallbackType in_type, AkCallbackInfo in_info)
    {
        if (!AkUnitySoundEngine.IsInitialized()) return;

        if (in_type == AkCallbackType.AK_MusicSyncBeat)
        {
            if (playingID_MusicEvent != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
            {
                AkMusicSyncCallbackInfo musicInfo = in_info as AkMusicSyncCallbackInfo;
                if (musicInfo != null && (Time.time - lastBeatTime >= minTimeBetweenBeats || lastBeatTime == 0f))
                {
                    currentBeatDuration = musicInfo.segmentInfo_fBeatDuration;
                    lastBeatTime = Time.time;
                    PublicBeatCount++;
                    
                    // Déclenchement de l'événement statique avec la durée du beat
                    OnBeat?.Invoke(currentBeatDuration);

                    // Mise à jour du flag pour LastBeatWasProcessed
                    beatOccurredThisFrame = true;
                }
            }
        }
        else if (in_type == AkCallbackType.AK_EndOfEvent)
        {
            AkEventCallbackInfo eventInfo = in_info as AkEventCallbackInfo;
            if (eventInfo != null && eventInfo.playingID == playingID_MusicEvent)
            {
                Debug.LogWarning($"[MusicManager OnMusicCallback] AK_EndOfEvent reçu pour playingID {playingID_MusicEvent} ({playMusicEvent?.Name}). musicPlaying mis à false.");
                musicPlaying = false;
                playingID_MusicEvent = AkUnitySoundEngine.AK_INVALID_PLAYING_ID;
            }
        }
    }

    public void SetMusicState(string newState, bool immediate = false)
    {
        if (!AkUnitySoundEngine.IsInitialized())
        {
            Debug.LogError($"[MusicManager] SetMusicState({newState}) appelé mais Wwise n'est pas prêt.");
            return;
        }

        string lowerNewState = newState.ToLower();

        if (currentMusicState == newState && musicPlaying && playingID_MusicEvent != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
        {
            return;
        }

        ApplyMusicSwitch(newState);

        bool needsWwiseEventToPlay = lowerNewState != "silence";

        if (needsWwiseEventToPlay && (!musicPlaying || playingID_MusicEvent == AkUnitySoundEngine.AK_INVALID_PLAYING_ID))
        {
            Debug.Log($"[MusicManager] L'état '{newState}' nécessite que l'événement Wwise joue, et il ne joue pas (ou ID invalide). Appel de InitializeMusicAndSetState pour '{newState}'.");
            InitializeMusicAndSetState(newState);
        }
        else if (lowerNewState == "silence" && musicPlaying && playingID_MusicEvent != AkUnitySoundEngine.AK_INVALID_PLAYING_ID)
        {
            Debug.Log($"[MusicManager] État cible est 'Silence'. Arrêt de l'event musical ID: {playingID_MusicEvent}.");
            AkUnitySoundEngine.StopPlayingID(playingID_MusicEvent);
            musicPlaying = false;
            playingID_MusicEvent = AkUnitySoundEngine.AK_INVALID_PLAYING_ID;
        }

        if (currentMusicState != newState)
        {
            currentMusicState = newState;
            OnMusicStateChanged?.Invoke(newState);
        }
    }

    private void ApplyMusicSwitch(string stateName)
    {
        AK.Wwise.Switch targetSwitch = null;

        switch (stateName.ToLower())
        {
            case "exploration": targetSwitch = explorationSwitch; break;
            case "combat": targetSwitch = combatSwitch; break;
            case "boss": targetSwitch = bossSwitch; break;
            case "silence": targetSwitch = silenceSwitch; break;
            case "mainmenu": targetSwitch = mainMenuSwitch; break;
            case "hub": targetSwitch = hubSwitch; break;
            case "endgame":
                targetSwitch = endGameSwitch;
                if (endGameSwitch == null || !endGameSwitch.IsValid()) {
                    Debug.LogError($"[MusicManager] ApplyMusicSwitch: Switch 'endGameSwitch' non assigné ou invalide pour l'état '{stateName}'.");
                }
                break;
            default:
                Debug.LogWarning($"[MusicManager] ApplyMusicSwitch: État musical Switch Wwise inconnu : '{stateName}'.");
                return;
        }

        if (targetSwitch != null && targetSwitch.IsValid())
        {
            targetSwitch.SetValue(this.gameObject);
        }
        else if (stateName.ToLower() != "endgame")
        {
             Debug.LogError($"[MusicManager] ApplyMusicSwitch: Le Switch Wwise pour l'état '{stateName}' est null ou invalide !");
        }
    }

    // --- MÉTHODES DE COMPATIBILITÉ ---

    /// <summary>
    /// (Déprécié) Tente de définir le BPM. Le BPM réel est maintenant contrôlé par Wwise.
    /// </summary>
    public void SetBPM(float newBPM)
    {
        Debug.LogWarning($"[MusicManager] L'appel à SetBPM({newBPM}) est déprécié. Le BPM est maintenant contrôlé par le segment musical joué dans Wwise.");
        // On ne change rien à la logique interne.
    }

    /// <summary>
    /// Méthode pour retourner la durée d'un battement en secondes.
    /// </summary>
    public float GetBeatDuration()
    {
        return (musicPlaying && playingID_MusicEvent != AkUnitySoundEngine.AK_INVALID_PLAYING_ID) ? currentBeatDuration : 0.5f;
    }
    
    public float GetNextBeatTime() {
        if (!musicPlaying || playingID_MusicEvent == AkUnitySoundEngine.AK_INVALID_PLAYING_ID || currentBeatDuration <= 0)
            return Time.time + 0.5f;
        float timeSinceLastBeat = Time.time - lastBeatTime;
        float timeUntilNextBeat = currentBeatDuration - (timeSinceLastBeat % currentBeatDuration);
        return Time.time + timeUntilNextBeat;
    }

    public float GetTimeUntilNextBeat()
    {
         if (!this.enabled || !Application.isPlaying || !musicPlaying) return float.MaxValue;
         return Mathf.Max(0, GetNextBeatTime() - Time.time);
    }
    
    public float GetBeatProgress() {
        if (!musicPlaying || playingID_MusicEvent == AkUnitySoundEngine.AK_INVALID_PLAYING_ID || currentBeatDuration <= 0) return 0;
        float timeSinceLastBeat = Time.time - lastBeatTime;
        return Mathf.Clamp01((timeSinceLastBeat % currentBeatDuration) / currentBeatDuration);
    }

    private void OnDestroy()
    {
        if (Instance == this) Instance = null;

        if (playingID_MusicEvent != AkUnitySoundEngine.AK_INVALID_PLAYING_ID && AkUnitySoundEngine.IsInitialized())
        {
            AkUnitySoundEngine.StopPlayingID(playingID_MusicEvent);
            playingID_MusicEvent = AkUnitySoundEngine.AK_INVALID_PLAYING_ID;
        }
    }
    
    /// <summary>
    /// Met à jour l'intensité du Mode Fever dans Wwise via un RTPC.
    /// </summary>
    /// <param name="intensity">Valeur d'intensité entre 0 et 100</param>
    public void SetFeverIntensity(float intensity)
    {
        // Clamp la valeur entre 0 et 100 pour sécurité
        intensity = Mathf.Clamp(intensity, 0f, 100f);
        // Vérifier que le paramètre RTPC est configuré
        if (feverIntensityRTPC == null || !feverIntensityRTPC.IsValid())
        {
            Debug.LogWarning("[MusicManager] Le paramètre RTPC pour le Mode Fever n'est pas configuré.");
            return;
        }

        // Appliquer la valeur RTPC à Wwise
		feverIntensityRTPC.SetGlobalValue(intensity);

    
        Debug.Log($"[MusicManager] Intensité Fever mise à jour : {intensity:F1}%");
    }

public void UpdateWwiseListener(GameObject newListener)
{
    if (newListener == null)
    {
        Debug.LogWarning("[MusicManager] Tentative de mise à jour de l'auditeur avec un objet null.");
        return;
    }

    if (AkUnitySoundEngine.IsInitialized())
    {
        // On récupère l'ID Wwise du nouvel auditeur (la nouvelle caméra)
        ulong listenerId = AkUnitySoundEngine.GetAkGameObjectID(newListener);
        if (listenerId != AkUnitySoundEngine.AK_INVALID_GAME_OBJECT)
        {
            // On définit ce nouvel auditeur comme l'unique auditeur pour ce GameObject
            AkUnitySoundEngine.SetListeners(gameObject, new ulong[] { listenerId }, 1);
            Debug.Log($"[MusicManager] L'auditeur Wwise a été mis à jour avec succès vers : {newListener.name}");
        }
        else
        {
            Debug.LogWarning($"[MusicManager] L'objet {newListener.name} ne semble pas avoir d'AkAudioListener valide.");
        }
    }
}
}

// --- FILE: Scripts/Controllers/ParticleController.cs ---
using UnityEngine;
using System;
using System.Collections.Generic;

public class ParticleController : MonoBehaviour
{
    public static ParticleController Instance;

    [Header("Debug Settings")]
    [SerializeField]
    private bool debugLogging = true;

    [Serializable]
    public class ParticleEffectEntry
    {
        public string Tag;
        public GameObject ParticlePrefab;
    }

    [Serializable]
    public class TeamParticleEffectEntry
    {
        public string Tag;
        public GameObject NeutralParticlePrefab;
        public GameObject PlayerParticlePrefab;
        public GameObject EnemyParticlePrefab;
        public float YPosition = 0.0f;
    }

    [SerializeField]
    private List<ParticleEffectEntry> particleEffects = new List<ParticleEffectEntry>();

    [Header("Team-Based Effects for NeutralBuildings")]
    [SerializeField]
    private List<TeamParticleEffectEntry> teamParticleEffects = new List<TeamParticleEffectEntry>();

    private Dictionary<ParticleEffectEntry, Dictionary<GameObject, GameObject>> effectInstances
        = new Dictionary<ParticleEffectEntry, Dictionary<GameObject, GameObject>>();

    private Dictionary<TeamParticleEffectEntry, Dictionary<GameObject, GameObject>> teamEffectInstances
        = new Dictionary<TeamParticleEffectEntry, Dictionary<GameObject, GameObject>>();

    private void Awake()
    {
        if (Instance == null)
            Instance = this;
        else
            Destroy(gameObject);

        foreach (var entry in particleEffects)
        {
            effectInstances[entry] = new Dictionary<GameObject, GameObject>();
        }

        foreach (var entry in teamParticleEffects)
        {
            teamEffectInstances[entry] = new Dictionary<GameObject, GameObject>();
        }
    }

    private void Start()
    {
        // --- MODIFICATION : Utilisation de MusicManager.Instance ---
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat += UpdateParticleEffects;
        }

        // Initial update to place effects
        UpdateParticleEffects(0); // On peut passer 0 car la durée n'est pas utilisée ici
    }

    private void OnDestroy()
    {
        // --- MODIFICATION : Utilisation de MusicManager.Instance ---
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= UpdateParticleEffects;
        }
    }

    // --- MODIFICATION : Signature de la méthode mise à jour ---
    public void UpdateParticleEffects(float beatDuration)
    {
        if (debugLogging)
            Debug.Log("[ParticleController] Beginning UpdateParticleEffects");

        // Handle standard particle effects
        foreach (var entry in particleEffects)
        {
            GameObject[] targets = GameObject.FindGameObjectsWithTag(entry.Tag);
            HashSet<GameObject> currentTargets = new HashSet<GameObject>(targets);

            if (debugLogging)
                Debug.Log($"[ParticleController] Found {targets.Length} objects with tag '{entry.Tag}'");

            foreach (GameObject target in targets)
            {
                if (!effectInstances[entry].ContainsKey(target))
                {
                    GameObject effectInstance = Instantiate(entry.ParticlePrefab, target.transform);
                    effectInstance.transform.localPosition = Vector3.zero;
                    effectInstances[entry][target] = effectInstance;

                    if (debugLogging)
                        Debug.Log($"[ParticleController] Created standard effect '{entry.ParticlePrefab.name}' at {target.name}, position: {target.transform.position}, local position: {Vector3.zero}");
                }
            }

            List<GameObject> toRemove = new List<GameObject>();
            foreach (var kvp in effectInstances[entry])
            {
                GameObject trackedTarget = kvp.Key;
                if (!currentTargets.Contains(trackedTarget))
                {
                    if (kvp.Value != null)
                    {
                        Destroy(kvp.Value);
                        if (debugLogging)
                            Debug.Log($"[ParticleController] Removed standard effect from missing object with tag '{entry.Tag}'");
                    }
                    toRemove.Add(trackedTarget);
                }
            }
            foreach (GameObject target in toRemove)
            {
                effectInstances[entry].Remove(target);
            }
        }

        // Handle team-based particle effects for NeutralBuildings
        foreach (var entry in teamParticleEffects)
        {
            GameObject[] targets = GameObject.FindGameObjectsWithTag(entry.Tag);
            HashSet<GameObject> currentTargets = new HashSet<GameObject>(targets);

            if (debugLogging)
                Debug.Log($"[ParticleController] Found {targets.Length} objects with tag '{entry.Tag}' for team effects");

            foreach (GameObject target in targets)
            {
                NeutralBuilding building = target.GetComponent<NeutralBuilding>();
                if (building == null)
                    continue;

                GameObject prefabToUse = null;
                string teamName = "";
                switch (building.Team)
                {
                    case TeamType.Neutral:
                        prefabToUse = entry.NeutralParticlePrefab;
                        teamName = "Neutral";
                        break;
                    case TeamType.Player:
                        prefabToUse = entry.PlayerParticlePrefab;
                        teamName = "Player";
                        break;
                    case TeamType.Enemy:
                        prefabToUse = entry.EnemyParticlePrefab;
                        teamName = "Enemy";
                        break;
                }

                if (prefabToUse == null)
                    continue;

                Vector3 auraPosition = CalculateAuraPosition(target, entry.YPosition);

                if (teamEffectInstances[entry].ContainsKey(target))
                {
                    GameObject existingEffect = teamEffectInstances[entry][target];

                    if (existingEffect == null || existingEffect.name != prefabToUse.name + "(Clone)")
                    {
                        if (existingEffect != null)
                        {
                            if (debugLogging)
                                Debug.Log($"[ParticleController] Replacing team effect on {target.name} from {existingEffect.name} to {prefabToUse.name} (team: {teamName})");

                            Destroy(existingEffect);
                        }
                        
                        GameObject newEffect = Instantiate(prefabToUse);
                        newEffect.transform.position = auraPosition;
                        newEffect.transform.localScale = prefabToUse.transform.localScale;
                        ParticleFollower follower = newEffect.AddComponent<ParticleFollower>();
                        follower.SetTarget(target, entry.YPosition);
                        teamEffectInstances[entry][target] = newEffect;

                        if (debugLogging)
                            Debug.Log($"[ParticleController] Created team effect '{prefabToUse.name}' for team {teamName} at world pos: {auraPosition}, target: {target.name}");
                    }
                    else
                    {
                        existingEffect.transform.position = auraPosition;
                        ParticleFollower follower = existingEffect.GetComponent<ParticleFollower>();
                        if (follower != null)
                        {
                            follower.SetTarget(target, entry.YPosition);
                        }
                    }
                }
                else
                {
                    GameObject effectInstance = Instantiate(prefabToUse);
                    effectInstance.transform.position = auraPosition;
                    effectInstance.transform.localScale = prefabToUse.transform.localScale;
                    ParticleFollower follower = effectInstance.AddComponent<ParticleFollower>();
                    follower.SetTarget(target, entry.YPosition);
                    teamEffectInstances[entry][target] = effectInstance;

                    if (debugLogging)
                        Debug.Log($"[ParticleController] Created new team effect '{prefabToUse.name}' for team {teamName} at world pos: {auraPosition}, target: {target.name}");
                }
            }

            List<GameObject> toRemove = new List<GameObject>();
            foreach (var kvp in teamEffectInstances[entry])
            {
                GameObject trackedTarget = kvp.Key;
                if (!currentTargets.Contains(trackedTarget))
                {
                    if (kvp.Value != null)
                    {
                        Destroy(kvp.Value);
                        if (debugLogging)
                            Debug.Log($"[ParticleController] Removed team effect from missing object with tag '{entry.Tag}'");
                    }
                    toRemove.Add(trackedTarget);
                }
            }
            foreach (GameObject target in toRemove)
            {
                teamEffectInstances[entry].Remove(target);
            }
        }
    }

    public void UpdateParticlesForBuilding(GameObject building)
    {
        if (building == null)
            return;

        if (debugLogging)
            Debug.Log($"[ParticleController] UpdateParticlesForBuilding called for {building.name}");

        foreach (var entry in teamParticleEffects)
        {
            if (building.CompareTag(entry.Tag))
            {
                NeutralBuilding neutralBuilding = building.GetComponent<NeutralBuilding>();
                if (neutralBuilding == null)
                    continue;

                GameObject prefabToUse = null;
                string teamName = "";
                switch (neutralBuilding.Team)
                {
                    case TeamType.Neutral:
                        prefabToUse = entry.NeutralParticlePrefab;
                        teamName = "Neutral";
                        break;
                    case TeamType.Player:
                        prefabToUse = entry.PlayerParticlePrefab;
                        teamName = "Player";
                        break;
                    case TeamType.Enemy:
                        prefabToUse = entry.EnemyParticlePrefab;
                        teamName = "Enemy";
                        break;
                }

                if (prefabToUse == null)
                {
                    if (debugLogging)
                        Debug.LogWarning($"[ParticleController] No prefab found for team {teamName} on {building.name}");
                    continue;
                }

                Vector3 auraPosition = CalculateAuraPosition(building, entry.YPosition);

                if (teamEffectInstances[entry].ContainsKey(building))
                {
                    GameObject existingEffect = teamEffectInstances[entry][building];
                    if (existingEffect == null || existingEffect.name != prefabToUse.name + "(Clone)")
                    {
                        if (existingEffect != null)
                        {
                            if (debugLogging)
                                Debug.Log($"[ParticleController] Replacing specific building effect on {building.name} from {existingEffect.name} to {prefabToUse.name} (team: {teamName})");
                            Destroy(existingEffect);
                        }

                        GameObject newEffect = Instantiate(prefabToUse);
                        newEffect.transform.position = auraPosition;
                        newEffect.transform.localScale = prefabToUse.transform.localScale;
                        ParticleFollower follower = newEffect.AddComponent<ParticleFollower>();
                        follower.SetTarget(building, entry.YPosition);
                        teamEffectInstances[entry][building] = newEffect;

                        if (debugLogging)
                            Debug.Log($"[ParticleController] Created specific building effect '{prefabToUse.name}' for team {teamName} at world pos: {auraPosition}, target: {building.name}");
                    }
                    else
                    {
                        existingEffect.transform.position = auraPosition;
                        ParticleFollower follower = existingEffect.GetComponent<ParticleFollower>();
                        if (follower != null)
                        {
                            follower.SetTarget(building, entry.YPosition);
                        }
                    }
                }
                else
                {
                    GameObject effectInstance = Instantiate(prefabToUse);
                    effectInstance.transform.position = auraPosition;
                    effectInstance.transform.localScale = prefabToUse.transform.localScale;
                    ParticleFollower follower = effectInstance.AddComponent<ParticleFollower>();
                    follower.SetTarget(building, entry.YPosition);
                    teamEffectInstances[entry][building] = effectInstance;

                    if (debugLogging)
                        Debug.Log($"[ParticleController] Created new building-specific effect '{prefabToUse.name}' for team {teamName} at world pos: {auraPosition}, target: {building.name}");
                }
                break;
            }
        }
    }

    private Vector3 CalculateAuraPosition(GameObject target, float yOffset)
    {
        Bounds buildingBounds = GetBuildingBounds(target);
        Vector3 basePosition = new Vector3(
            buildingBounds.center.x,
            buildingBounds.min.y + yOffset,
            buildingBounds.center.z
        );

        if (debugLogging)
            Debug.Log($"[ParticleController] Calculated aura position for {target.name}: {basePosition}, bounds: min={buildingBounds.min}, max={buildingBounds.max}, center={buildingBounds.center}");

        return basePosition;
    }

    private Bounds GetBuildingBounds(GameObject target)
    {
        Renderer[] renderers = target.GetComponents<Renderer>();

        if (renderers.Length == 0)
        {
            List<Renderer> firstLevelRenderers = new List<Renderer>();
            foreach (Transform child in target.transform)
            {
                Renderer childRenderer = child.GetComponent<Renderer>();
                if (childRenderer != null)
                {
                    firstLevelRenderers.Add(childRenderer);
                }
            }
            if (firstLevelRenderers.Count > 0)
            {
                renderers = firstLevelRenderers.ToArray();
            }
            else
            {
                if (debugLogging)
                    Debug.LogWarning($"[ParticleController] No direct renderers found for {target.name}, falling back to all child renderers");
                renderers = target.GetComponentsInChildren<Renderer>();
            }
        }

        if (renderers.Length == 0)
        {
            if (debugLogging)
                Debug.LogWarning($"[ParticleController] No renderers found for {target.name}, using transform position");
            Vector3 position = target.transform.position;
            Bounds fallbackBounds = new Bounds(position, Vector3.one);
            return fallbackBounds;
        }

        Bounds resultBounds = renderers[0].bounds;
        for (int i = 1; i < renderers.Length; i++)
        {
            resultBounds.Encapsulate(renderers[i].bounds);
        }

        return resultBounds;
    }
}



// Helper component to make particles follow a target object
public class ParticleFollower : MonoBehaviour
{
    private GameObject target;
    private float yOffset;

    public void SetTarget(GameObject newTarget, float newYOffset)
    {
        target = newTarget;
        yOffset = newYOffset;
    }

    private void LateUpdate()
    {
        if (target != null)
        {
            // Get the target's renderer bounds
            Bounds targetBounds = GetBuildingBounds(target);

            // Update position to follow the target
            transform.position = new Vector3(
                targetBounds.center.x,
                targetBounds.min.y + yOffset,
                targetBounds.center.z
            );
        }
    }

    private Bounds GetBuildingBounds(GameObject target)
    {
        // Option 1: Only use renderers directly on the parent object
        Renderer[] renderers = target.GetComponents<Renderer>();

        // If the parent has no renderers, we need to find the main renderers while avoiding sub-prefabs
        if (renderers.Length == 0)
        {
            // Find only first-level children with renderers
            List<Renderer> firstLevelRenderers = new List<Renderer>();

            foreach (Transform child in target.transform)
            {
                Renderer childRenderer = child.GetComponent<Renderer>();
                if (childRenderer != null)
                {
                    firstLevelRenderers.Add(childRenderer);
                }
            }

            // If we found first-level renderers, use those
            if (firstLevelRenderers.Count > 0)
            {
                renderers = firstLevelRenderers.ToArray();
            }
            else
            {
                renderers = target.GetComponentsInChildren<Renderer>();
            }
        }

        if (renderers.Length == 0)
        {
            Vector3 position = target.transform.position;
            Bounds fallbackBounds = new Bounds(position, Vector3.one);
            return fallbackBounds;
        }

        // Start with the first renderer's bounds
        Bounds resultBounds = renderers[0].bounds;

        // Expand to include all other renderers
        for (int i = 1; i < renderers.Length; i++)
        {
            resultBounds.Encapsulate(renderers[i].bounds);
        }

        return resultBounds;
    }
}

// --- FILE: Scripts/Controllers/ParticlePositionStabilizer.cs ---
using UnityEngine;

// Add this component to particle effects to ensure they maintain their correct local position
// This helps prevent position drift in team-based particle effects on NeutralBuildings
public class ParticlePositionStabilizer : MonoBehaviour
{
    private Vector3 initialLocalPosition;
    private Vector3 initialLocalScale;

    private void Start()
    {
        // Store the initial local position and scale
        initialLocalPosition = transform.localPosition;
        initialLocalScale = transform.localScale;
    }

    private void LateUpdate()
    {
        // Check if the position or scale has changed, and reset if needed
        if (transform.localPosition != initialLocalPosition)
        {
            transform.localPosition = initialLocalPosition;
        }

        if (transform.localScale != initialLocalScale)
        {
            transform.localScale = initialLocalScale;
        }
    }
}

// --- FILE: Scripts/Controllers/PlayerHapticsInitializer.cs ---
﻿using UnityEngine;

// Ce script doit être placé sur le même GameObject que votre SequenceController.
public class PlayerHapticsInitializer : MonoBehaviour
{
    [Tooltip("Optionnel : Assignez manuellement l'objet qui sert de Listener Wwise. Si laissé vide, le script cherchera la caméra principale.")]
    public GameObject wwiseListenerObject;

    void Start()
    {
        // 1. Déterminer quel GameObject est le Listener principal.
        if (wwiseListenerObject == null)
        {
            if (Camera.main != null)
            {
                // Par défaut, le listener est souvent sur la caméra principale.
                wwiseListenerObject = Camera.main.gameObject;
                Debug.Log("[PlayerHapticsInitializer] Listener Wwise trouvé sur la caméra principale.");
            }
            else
            {
                Debug.LogError("[PlayerHapticsInitializer] Aucun Listener Wwise assigné et la caméra principale est introuvable. L'haptique risque de ne pas fonctionner.");
                return;
            }
        }

        // 2. Obtenir l'ID unique du GameObject Listener pour Wwise.
        ulong listenerId = AkUnitySoundEngine.GetAkGameObjectID(wwiseListenerObject);
        if (listenerId == AkUnitySoundEngine.AK_INVALID_GAME_OBJECT)
        {
            Debug.LogError("[PlayerHapticsInitializer] Le GameObject Listener n'est pas valide ou enregistré auprès de Wwise. Assurez-vous qu'il possède un composant AkGameObj.");
            return;
        }

        // 3. Préparer le tableau des listeners. Ici, un seul.
        ulong[] listenerIds = new ulong[] { listenerId };
        uint numberOfListeners = (uint)listenerIds.Length;

        // 4. Lier ce GameObject (l'émetteur de son/haptique) au listener spécifié.
        // C'est l'étape clé. On utilise AkUnitySoundEngine et la bonne surcharge de la méthode SetListeners.
        AKRESULT result = AkUnitySoundEngine.SetListeners(this.gameObject, listenerIds, numberOfListeners);

        if (result == AKRESULT.AK_Success)
        {
            Debug.Log($"[PlayerHapticsInitializer] Le lien entre l'émetteur '{this.gameObject.name}' et le listener '{wwiseListenerObject.name}' a été établi avec succès pour l'haptique.");
        }
        else
        {
            Debug.LogError($"[PlayerHapticsInitializer] Échec de la liaison avec le listener. Code d'erreur Wwise : {result}");
        }
    }
}

// --- FILE: Scripts/Controllers/RhythmManager.cs ---


// --- FILE: Scripts/Controllers/SequenceController.cs ---
using UnityEngine;
using TMPro;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Linq;
using ScriptableObjects;
using UnityEngine.InputSystem; // Ajout important pour le nouveau système d'input

// Ces classes sérialisées restent identiques
[System.Serializable]
public class InputSoundVariants
{
    public AK.Wwise.Switch goodSwitch;
    public AK.Wwise.Switch perfectSwitch;
    public AK.Wwise.Switch failedSwitch;
}

[System.Serializable]
public class InputSoundVariantsKey
{
    public AK.Wwise.Switch XSwitch;
    public AK.Wwise.Switch CSwitch;
    public AK.Wwise.Switch VSwitch;
}

public class SequenceController : MonoBehaviour
{
    // --- Variables de Séquence et de Timing (inchangées) ---
    private List<CharacterData_SO> availablePlayerCharactersInTeam = new List<CharacterData_SO>();
    private List<GlobalSpellData_SO> availableGlobalSpells = new List<GlobalSpellData_SO>();

    private List<KeyCode> currentSequence = new List<KeyCode>();
    public IReadOnlyList<KeyCode> CurrentSequence => currentSequence.AsReadOnly();

    private int perfectCount = 0;

    [Tooltip("Tolérance en % de la durée du beat pour un input 'Perfect'. Ex: 0.2 = 20% de la durée du beat.")]
    [Range(0, 1)]
    public float perfectTolerancePercent = 0.2f;

    [Tooltip("Tolérance en % de la durée du beat pour un input 'Good'. Ex: 0.4 = 40% de la durée du beat.")]
    [Range(0, 1)]
    public float goodTolerancePercent = 0.4f;

    private bool _hasInputForCurrentBeat = false;
    private bool isSequenceActive = false;
    private float lastBeatTime;
    private float _currentBeatDuration = 1f;
    private bool isResponding = false;

    // --- Dépendances et Événements (inchangés) ---
    private MusicManager musicManager;
    public InputSoundVariants inputSounds;
    public InputSoundVariantsKey inputSoundsKey;
    public AK.Wwise.Event playSwitchContainerEvent;
    [SerializeField] private TextMeshProUGUI sequenceDisplay;

    public static event Action<string, Color> OnSequenceKeyPressed;
    public static event Action OnSequenceDisplayCleared;
    public static event Action<CharacterData_SO, int> OnCharacterInvocationSequenceComplete;
    public static event Action<GlobalSpellData_SO, int> OnGlobalSpellSequenceComplete;
    public static event Action OnSequenceSuccess;
    public static event Action OnSequenceFail;

    #region Initialisation et Cycle de Vie

    private void Awake()
    {
        availablePlayerCharactersInTeam = new List<CharacterData_SO>();
        availableGlobalSpells = new List<GlobalSpellData_SO>();
    }

    // --- MISE À JOUR MAJEURE : Abonnement au nouveau Input System ---
    private void OnEnable()
    {
        // On s'abonne directement aux actions du InputManager
        if (InputManager.Instance != null)
        {
            InputManager.Instance.GameplayActions.RhythmInput_Left.performed += OnRhythmInput_Left;
            InputManager.Instance.GameplayActions.RhythmInput_Down.performed += OnRhythmInput_Down;
            InputManager.Instance.GameplayActions.RhythmInput_Right.performed += OnRhythmInput_Right;
        }
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat += HandleBeat;
        }
    }

    // --- MISE À JOUR MAJEURE : Se désabonner proprement ---
    private void OnDisable()
    {
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= HandleBeat;
        }
        if (InputManager.Instance != null)
        {
            InputManager.Instance.GameplayActions.RhythmInput_Left.performed -= OnRhythmInput_Left;
            InputManager.Instance.GameplayActions.RhythmInput_Down.performed -= OnRhythmInput_Down;
            InputManager.Instance.GameplayActions.RhythmInput_Right.performed -= OnRhythmInput_Right;
        }
    }

    private void Start()
    {
        // Utilisation du singleton pour plus de robustesse
        musicManager = MusicManager.Instance;
        if (musicManager == null)
        {
            Debug.LogError("No MusicManager found in the scene!");
        }
        OnSequenceDisplayCleared?.Invoke();
    }

    public void InitializeWithPlayerTeamAndSpells(List<CharacterData_SO> activeTeam, List<GlobalSpellData_SO> globalSpells)
    {
        availablePlayerCharactersInTeam = activeTeam ?? new List<CharacterData_SO>();
        availableGlobalSpells = globalSpells ?? new List<GlobalSpellData_SO>();
        Debug.Log($"[SequenceController] Initialized with {availablePlayerCharactersInTeam.Count} character(s) in team and {availableGlobalSpells.Count} global spell(s).");
    }

    // SUPPRIMÉ : La méthode Update() n'est plus utilisée pour les inputs.

    #endregion

    #region Gestion des Inputs

    // --- NOUVEAU : Méthodes de rappel pour le nouveau Input System ---
    private void OnRhythmInput_Left(InputAction.CallbackContext context)
    {
        ProcessInput(KeyCode.X);
    }

    private void OnRhythmInput_Down(InputAction.CallbackContext context)
    {
        ProcessInput(KeyCode.C);
    }

    private void OnRhythmInput_Right(InputAction.CallbackContext context)
    {
        ProcessInput(KeyCode.V);
    }

    // --- AMÉLIORATION : ProcessInput intègre maintenant la logique audio Wwise ---
    private void ProcessInput(KeyCode key)
    {
        if (isResponding) return;

        // Vérification de robustesse
        if (musicManager == null) {
             SetSwitchAndPlay(inputSounds.failedSwitch, "Failed (No MusicManager)", playSwitchContainerEvent, GetKeySwitch(key));
             OnSequenceFail?.Invoke();
             ResetSequence();
             return;
        }

        // Logique anti-spam
        if (_hasInputForCurrentBeat)
        {
            Debug.Log("[SequenceController] Input registered before next beat window. Combo Reset!");
            SetSwitchAndPlay(inputSounds.failedSwitch, "Failed (Spam)", playSwitchContainerEvent, GetKeySwitch(key));
            OnSequenceFail?.Invoke();
            ResetSequence();
            return;
        }

        // Calcul du timing (inchangé, mais maintenant utilisé pour le son)
        float currentTime = Time.time;
        float timeSinceLastBeat = Mathf.Abs(currentTime - lastBeatTime);
        float timeUntilNextBeat = musicManager.GetTimeUntilNextBeat();
        float timeToClosestBeat = Mathf.Min(timeSinceLastBeat, timeUntilNextBeat);

        AK.Wwise.Switch keySwitch = GetKeySwitch(key);
        float perfectToleranceInSeconds = _currentBeatDuration * perfectTolerancePercent;
        float goodToleranceInSeconds = _currentBeatDuration * goodTolerancePercent;

        if (timeToClosestBeat <= perfectToleranceInSeconds)
        {
            isSequenceActive = true;
            _hasInputForCurrentBeat = true;
            perfectCount++;
            SetSwitchAndPlay(inputSounds.perfectSwitch, "Perfect", playSwitchContainerEvent, keySwitch); // Appel audio
            currentSequence.Add(key);
            OnSequenceKeyPressed?.Invoke(key.ToString(), Color.green); // Feedback visuel
        }
        else if (timeToClosestBeat <= goodToleranceInSeconds)
        {
            isSequenceActive = true;
            _hasInputForCurrentBeat = true;
            SetSwitchAndPlay(inputSounds.goodSwitch, "Good", playSwitchContainerEvent, keySwitch); // Appel audio
            currentSequence.Add(key);
            OnSequenceKeyPressed?.Invoke(key.ToString(), Color.yellow); // Feedback visuel
        }
        else
        {
            SetSwitchAndPlay(inputSounds.failedSwitch, "Failed (Off-beat)", playSwitchContainerEvent, keySwitch); // Appel audio
            OnSequenceFail?.Invoke();
            ResetSequence();
            return;
        }

        ValidateSequence();
    }

    #endregion

    #region Logique de Séquence et Audio (avec améliorations)

    private void ValidateSequence()
    {
        // La longueur de la séquence peut varier, donc on vérifie après chaque touche
        // si une séquence valide est complétée.
        bool sequenceMatched = false;

        foreach (CharacterData_SO characterData in availablePlayerCharactersInTeam)
        {
            if (characterData?.InvocationSequence != null &&
                CompareKeySequence(currentSequence, characterData.InvocationSequence.Select(input => ConvertInputTypeToKeyCode(input)).ToList()))
            {
                Debug.Log($"[SequenceController] Character Invocation Sequence Matched: {characterData.DisplayName}");
                StartCoroutine(HandleSuccessfulSequence(() => OnCharacterInvocationSequenceComplete?.Invoke(characterData, perfectCount), currentSequence.Count));
                sequenceMatched = true;
                break; // Sortir de la boucle dès qu'une correspondance est trouvée
            }
        }

        if (!sequenceMatched)
        {
            foreach (GlobalSpellData_SO spellData in availableGlobalSpells)
            {
                if (spellData?.SpellSequence != null &&
                    CompareKeySequence(currentSequence, spellData.SpellSequence.Select(input => ConvertInputTypeToKeyCode(input)).ToList()))
                {
                    Debug.Log($"[SequenceController] Global Spell Sequence Matched: {spellData.DisplayName}");
                    StartCoroutine(HandleSuccessfulSequence(() => OnGlobalSpellSequenceComplete?.Invoke(spellData, perfectCount), currentSequence.Count));
                    sequenceMatched = true;
                    break;
                }
            }
        }

        // Si la séquence atteint 4 et ne correspond à rien, c'est un échec.
        if (!sequenceMatched && currentSequence.Count >= 4)
        {
            Debug.LogWarning($"[SequenceController] Sequence of 4+ inputs did not match any known sequence: {string.Join("-", currentSequence)}");
            OnSequenceFail?.Invoke();
            ResetSequence();
        }
    }

    private bool CompareKeySequence(List<KeyCode> inputSequence, List<KeyCode> targetSequence)
    {
        // Cette comparaison simple fonctionne pour les séquences de même longueur.
        return inputSequence.SequenceEqual(targetSequence);
    }

    private KeyCode ConvertInputTypeToKeyCode(InputType inputType)
    {
        switch (inputType)
        {
            case InputType.X: return KeyCode.X;
            case InputType.C: return KeyCode.C;
            case InputType.V: return KeyCode.V;
            default: return KeyCode.None;
        }
    }

    private IEnumerator HandleSuccessfulSequence(Action specificEventCallback, int sequenceLength)
    {
        isResponding = true;
        OnSequenceSuccess?.Invoke();
        specificEventCallback?.Invoke();

        float responseDuration = musicManager != null ? musicManager.GetBeatDuration() * sequenceLength : 0.5f;
        yield return new WaitForSeconds(Mathf.Max(responseDuration, 0.1f));

        isResponding = false;
        ResetSequence();
    }

    private void ResetSequence()
    {
        isSequenceActive = false;
        perfectCount = 0;
        currentSequence.Clear();
        OnSequenceDisplayCleared?.Invoke();
    }

    private void HandleBeat(float beatDuration)
    {
        lastBeatTime = Time.time;
        _hasInputForCurrentBeat = false;
        _currentBeatDuration = beatDuration;
    }

    private AK.Wwise.Switch GetKeySwitch(KeyCode key)
    {
        if (key == KeyCode.X) return inputSoundsKey.XSwitch;
        if (key == KeyCode.C) return inputSoundsKey.CSwitch;
        if (key == KeyCode.V) return inputSoundsKey.VSwitch;
        return null;
    }

    // --- AMÉLIORATION : Logique audio complète et robuste ---
    private void SetSwitchAndPlay(AK.Wwise.Switch switchState, string switchName, AK.Wwise.Event playEvent, AK.Wwise.Switch keySwitch)
    {
        if (switchState != null && switchState.IsValid() && keySwitch != null && keySwitch.IsValid())
        {
            switchState.SetValue(gameObject);
            keySwitch.SetValue(gameObject);
            if (playEvent != null && playEvent.IsValid())
            {
                playEvent.Post(gameObject);
            }
        }
        else
        {
            // Logs de débogage pour aider à configurer Wwise dans Unity
            if (switchState == null) Debug.LogWarning($"[SequenceController] Wwise timing switch '{switchName}' not assigned in Inspector.");
            if (keySwitch == null) Debug.LogWarning($"[SequenceController] Wwise key switch for the pressed key not assigned in Inspector.");
        }
    }

    #endregion
}

// --- FILE: Scripts/Controllers/TileReservationController.cs ---
using System;
using System.Collections.Generic;
using UnityEngine;

// Interface for observers that need tile reservation updates
public interface ITileReservationObserver
{
    void OnTileReservationChanged(Vector2Int tilePos, Unit reservingUnit, bool isReserved);
}

public class TileReservationController : MonoBehaviour
{
    // Singleton instance
    public static TileReservationController Instance { get; private set; }

    // Map of tile positions to their reserving units
    public Dictionary<Vector2Int, Unit> reservations = new Dictionary<Vector2Int, Unit>();

    // List of observers
    public List<ITileReservationObserver> observers = new List<ITileReservationObserver>();

    // Debug flag
    [SerializeField] private bool enableDebugLogs = false;

    private void Awake()
    {
        // Singleton setup
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
        DontDestroyOnLoad(gameObject);

        if (enableDebugLogs)
            Debug.Log("TileReservationController initialized");
    }

    // Register an observer
    public void AddObserver(ITileReservationObserver observer)
    {
        if (!observers.Contains(observer))
        {
            observers.Add(observer);
            if (enableDebugLogs)
                Debug.Log($"Observer added: {observer}");
        }
    }

    // Unregister an observer
    public void RemoveObserver(ITileReservationObserver observer)
    {
        if (observers.Contains(observer))
        {
            observers.Remove(observer);
        }
    }

    // Notify all observers of reservation changes
    private void NotifyObservers(Vector2Int tilePos, Unit reservingUnit, bool isReserved)
    {
        foreach (var observer in observers)
        {
            observer.OnTileReservationChanged(tilePos, reservingUnit, isReserved);
        }
    }

    // Try to reserve a tile for a unit
    public bool TryReserveTile(Vector2Int tilePos, Unit requestingUnit)
    {
        // If tile is already reserved, check if it's by the same unit
        if (reservations.TryGetValue(tilePos, out Unit existingUnit))
        {
            if (existingUnit == requestingUnit)
            {
                // Already reserved by this unit
                return true;
            }

            if (enableDebugLogs)
                Debug.Log($"Tile at ({tilePos.x}, {tilePos.y}) already reserved by {existingUnit.name}, " +
                          $"denied for {requestingUnit.name}");

            return false;
        }

        // Reserve the tile
        reservations[tilePos] = requestingUnit;

        if (enableDebugLogs)
            Debug.Log($"Tile at ({tilePos.x}, {tilePos.y}) reserved by {requestingUnit.name}");

        // Notify observers
        NotifyObservers(tilePos, requestingUnit, true);

        return true;
    }

    // Release a tile reservation
    public void ReleaseTileReservation(Vector2Int tilePos, Unit releasingUnit)
    {
        if (reservations.TryGetValue(tilePos, out Unit existingUnit))
        {
            // Only allow the reserving unit to release the reservation
            if (existingUnit == releasingUnit)
            {
                reservations.Remove(tilePos);

                if (enableDebugLogs)
                    Debug.Log($"Tile at ({tilePos.x}, {tilePos.y}) reservation released by {releasingUnit.name}");

                // Notify observers
                NotifyObservers(tilePos, releasingUnit, false);
            }
            else if (enableDebugLogs)
            {
                Debug.LogWarning($"Unit {releasingUnit.name} attempted to release tile ({tilePos.x}, {tilePos.y}) " +
                                 $"reserved by {existingUnit.name}");
            }
        }
    }

    // Check if a tile is reserved
    public bool IsTileReserved(Vector2Int tilePos)
    {
        return reservations.ContainsKey(tilePos);
    }

    // Check if a tile is reserved by a specific unit
    public bool IsTileReservedBy(Vector2Int tilePos, Unit unit)
    {
        return reservations.TryGetValue(tilePos, out Unit reservingUnit) && reservingUnit == unit;
    }

    // Check if a tile is reserved by another unit
    public bool IsTileReservedByOtherUnit(Vector2Int tilePos, Unit requestingUnit)
    {
        return reservations.TryGetValue(tilePos, out Unit reservingUnit) && reservingUnit != requestingUnit;
    }

    // Get the unit that reserved a tile
    public Unit GetReservingUnit(Vector2Int tilePos)
    {
        reservations.TryGetValue(tilePos, out Unit reservingUnit);
        return reservingUnit;
    }

    // Get all current reservations
    public Dictionary<Vector2Int, Unit> GetAllReservations()
    {
        return new Dictionary<Vector2Int, Unit>(reservations);
    }

    // Clear all reservations (e.g., when restarting level)
    public void ClearAllReservations()
    {
        if (enableDebugLogs)
            Debug.Log("Clearing all tile reservations");

        // Store the reservations to notify about
        var oldReservations = new Dictionary<Vector2Int, Unit>(reservations);

        // Clear the dictionary
        reservations.Clear();

        // Notify about each cleared reservation
        foreach (var kvp in oldReservations)
        {
            NotifyObservers(kvp.Key, kvp.Value, false);
        }
    }
}

// --- FILE: Scripts/Controllers/WinLoseController.cs ---
using UnityEngine;
using UnityEngine.UI;
using Unity.Behavior.GraphFramework;
using ScriptableObjects;
using System.Linq;
using System.Collections;
using System.Collections.Generic;

public class WinLoseController : MonoBehaviour
{
    public static WinLoseController Instance { get; private set; }

    [Header("Débogage")]
    [SerializeField] private KeyCode winDebugKey = KeyCode.F10;
    [SerializeField] private KeyCode loseDebugKey = KeyCode.F11;

    [Header("Références UI (Assignées via l'Inspecteur)")]
    [Tooltip("Le panel qui s'affiche en fin de partie (contient les bannières Win/Lose).")]
    [SerializeField] private GameObject gameOverOverlayPanel;
    [Tooltip("L'objet spécifique à la bannière de victoire.")]
    [SerializeField] private GameObject winBannerObject;
    [Tooltip("L'objet spécifique à la bannière de défaite.")]
    [SerializeField] private GameObject loseBannerObject;
    [Tooltip("Le Canvas racine de l'interface en jeu (pour le désactiver).")]
    [SerializeField] private GameObject inGameUiCanvas;
    [Tooltip("Le panneau pour retourner au Hub/Lobby.")]
    [SerializeField] private GameObject lobbyBoardObject;
    [Tooltip("Le support du panneau Lobby.")]
    [SerializeField] private GameObject lobbyBoardSleeveObject;
    [Tooltip("Le panneau pour le niveau suivant.")]
    [SerializeField] private GameObject nextLevelBoardObject;
    [Tooltip("Le support du panneau pour le niveau suivant.")]
    [SerializeField] private GameObject nextLevelBoardSleeveObject;

    [Header("Dépendances")]
    [SerializeField] private RhythmGameCameraController gameCameraController;

    public static bool IsGameOverScreenActive { get; private set; } = false;
    private bool isGameOverInstance = false;
    public bool IsGameOver => isGameOverInstance;

    [Header("UI Navigation")]
    [SerializeField] private GameObject defaultButtonOnWin; // Assign "Next Level" button
    [SerializeField] private GameObject defaultButtonOnLose; // Assign "Lobby" button

    private readonly List<GameObject> _deactivatedAllyUnits = new List<GameObject>();
    private readonly List<GameObject> _deactivatedEnemyUnits = new List<GameObject>();

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
        }
        else
        {
            Instance = this;
        }
    }

    private void Start()
    {
        // Les abonnements aux événements sont gérés par GameManager ou d'autres managers au besoin.
        // L'état initial est défini par ResetGameConditionState, appelé par GameManager.
    }

    private void SetInitialScreenState()
    {
        Debug.Log($"[{gameObject.name}] Réinitialisation de l'état de l'écran de fin de partie.", this);

        // Désactiver tous les panneaux de fin de partie en utilisant les références directes
        if (gameOverOverlayPanel != null) gameOverOverlayPanel.SetActive(false);
        if (winBannerObject != null) winBannerObject.SetActive(false);
        if (loseBannerObject != null) loseBannerObject.SetActive(false);
        if (lobbyBoardObject != null) lobbyBoardObject.SetActive(false);
        if (lobbyBoardSleeveObject != null) lobbyBoardSleeveObject.SetActive(false);
        if (nextLevelBoardObject != null) nextLevelBoardObject.SetActive(false);
        if (nextLevelBoardSleeveObject != null) nextLevelBoardSleeveObject.SetActive(false);

        // Activer l'interface de jeu
        if (inGameUiCanvas != null) inGameUiCanvas.SetActive(true);

        isGameOverInstance = false;
        IsGameOverScreenActive = false;

        _deactivatedAllyUnits.Clear();
        _deactivatedEnemyUnits.Clear();
    }

    private void Update()
    {
        if (isGameOverInstance) return;
        if (Input.GetKeyDown(winDebugKey)) TriggerWinCondition();
        if (Input.GetKeyDown(loseDebugKey)) TriggerLoseCondition();
    }

    public void TriggerWinCondition()
    {
        if (isGameOverInstance) return;
        isGameOverInstance = true;
        IsGameOverScreenActive = true;

        Debug.Log("[WinLoseController] CONDITIONS DE VICTOIRE REMPLIES !", this);
        
        // NEW: Disable targeting system and unlock camera before game over sequence
        DisableTargetingSystemOnGameOver();
        
        HandleRewards();

        DeactivateAllUnitGameObjects();

        if (winBannerObject != null) winBannerObject.SetActive(true);
        if (lobbyBoardObject != null) lobbyBoardObject.SetActive(true);
        if (lobbyBoardSleeveObject != null) lobbyBoardSleeveObject.SetActive(true);
        if (nextLevelBoardObject != null) nextLevelBoardObject.SetActive(true);
        if (nextLevelBoardSleeveObject != null) nextLevelBoardSleeveObject.SetActive(true);

        ActivateGameOverSequence("VICTOIRE !");
    }

    public void TriggerLoseCondition()
    {
        if (isGameOverInstance) return;
        isGameOverInstance = true;
        IsGameOverScreenActive = true;

        Debug.Log("[WinLoseController] CONDITIONS DE DÉFAITE REMPLIES !", this);

        // NEW: Disable targeting system and unlock camera before game over sequence
        DisableTargetingSystemOnGameOver();

        DeactivateAllUnitGameObjects();

        if (loseBannerObject != null) loseBannerObject.SetActive(true);
        if (lobbyBoardObject != null) lobbyBoardObject.SetActive(true);
        if (lobbyBoardSleeveObject != null) lobbyBoardSleeveObject.SetActive(true);
        if (nextLevelBoardObject != null) nextLevelBoardObject.SetActive(false);
        if (nextLevelBoardSleeveObject != null) nextLevelBoardSleeveObject.SetActive(false);

        ActivateGameOverSequence("DÉFAITE !");
    }

    /// <summary>
    /// NEW: Properly disables the targeting system and unlocks camera when game ends
    /// </summary>
    private void DisableTargetingSystemOnGameOver()
    {
        // Disable targeting system in BannerController
        if (BannerController.Exists)
        {
            var bannerController = BannerController.Instance;
            // Force exit targeting mode by calling the private method through reflection or add a public method
            // For now, we'll use a simple approach by clearing the banner which should reset the state
            bannerController.ClearBanner();
            Debug.Log("[WinLoseController] BannerController targeting system disabled");
        }

        // Unlock camera completely
        if (gameCameraController != null)
        {
            gameCameraController.UnlockCamera(); // This unlocks targeting mode
            Debug.Log("[WinLoseController] Camera targeting unlocked");
        }
    }

    private void HandleRewards()
    {
        if (GameManager.Instance == null || PlayerDataManager.Instance == null || TeamManager.Instance == null)
        {
            Debug.LogError("[WinLoseController] Un manager requis est manquant. Impossible d'accorder les récompenses.");
            return;
        }

        LevelData_SO completedLevel = GameManager.CurrentLevelToLoad;
        if (completedLevel == null)
        {
            Debug.LogWarning("[WinLoseController] GameManager.CurrentLevelToLoad est null. Impossible d'accorder les récompenses.");
            return;
        }

        PlayerDataManager.Instance.CompleteLevel(completedLevel.LevelID, 1);
        if (completedLevel.ExperienceReward > 0)
        {
            var activeTeam = TeamManager.Instance.ActiveTeam;
            foreach (var character in activeTeam.Where(c => c != null))
            {
                PlayerDataManager.Instance.AddXPToCharacter(character.CharacterID, completedLevel.ExperienceReward);
            }
        }
        if (completedLevel.CurrencyReward > 0)
        {
            PlayerDataManager.Instance.AddCurrency(completedLevel.CurrencyReward);
        }
        if (completedLevel.ItemRewards != null && completedLevel.ItemRewards.Count > 0)
        {
            PlayerDataManager.Instance.UnlockMultipleEquipment(completedLevel.ItemRewards.Select(item => item.EquipmentID).ToList());
        }
        if (completedLevel.CharacterUnlockReward != null)
        {
            PlayerDataManager.Instance.UnlockCharacter(completedLevel.CharacterUnlockReward.CharacterID);
        }
        PlayerDataManager.Instance.SaveData();
    }

    private void ActivateGameOverSequence(string message)
    {
        Debug.Log($"[WinLoseController] Activation de la séquence de fin de partie : {message}", this);
        if (GameManager.Instance != null)
        {
            GameManager.Instance.SetState(GameState.EndGame);
        }
        if (inGameUiCanvas != null) inGameUiCanvas.SetActive(false);
        if (gameCameraController != null) gameCameraController.ZoomOutToMaxAndLockZoomOnly(true, 1.5f);
        if (gameOverOverlayPanel != null) gameOverOverlayPanel.SetActive(true);
        StartCoroutine(SelectDefaultButtonDelayed(isGameOverInstance ? defaultButtonOnWin : defaultButtonOnLose));
    }

    private IEnumerator SelectDefaultButtonDelayed(GameObject buttonToSelect)
    {
        // Wait for animations to start
        yield return new WaitForSecondsRealtime(0.5f);
    
        if (buttonToSelect != null && UnityEngine.EventSystems.EventSystem.current != null)
        {
            UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(buttonToSelect);
            Debug.Log($"[WinLoseController] Default button selected: {buttonToSelect.name}");
        }
    }


    private void DeactivateAllUnitGameObjects()
    {
        _deactivatedAllyUnits.Clear();
        _deactivatedEnemyUnits.Clear();
        foreach (GameObject unitGO in GameObject.FindGameObjectsWithTag("AllyUnit"))
        {
            if (unitGO.activeSelf)
            {
                unitGO.SetActive(false);
                _deactivatedAllyUnits.Add(unitGO);
            }
        }
        foreach (GameObject unitGO in GameObject.FindGameObjectsWithTag("Enemy"))
        {
            if (unitGO.activeSelf)
            {
                unitGO.SetActive(false);
                _deactivatedEnemyUnits.Add(unitGO);
            }
        }
    }

    private void ReactivateAllUnitGameObjects()
    {
        foreach (GameObject unitGO in _deactivatedAllyUnits)
        {
            if (unitGO != null) unitGO.SetActive(true);
        }
        _deactivatedAllyUnits.Clear();

        foreach (GameObject unitGO in _deactivatedEnemyUnits)
        {
            if (unitGO != null) unitGO.SetActive(true);
        }
        _deactivatedEnemyUnits.Clear();
    }

    public void ResetGameConditionState()
    {
        Debug.Log($"[WinLoseController] ResetGameConditionState appelé.", this);
        SetInitialScreenState();
        ReactivateAllUnitGameObjects();
        if (gameCameraController != null)
        {
            gameCameraController.UnlockZoomOnly();
            gameCameraController.ResetCameraToInitialState();
        }
    }

    private void OnDestroy()
    {
        if (Instance == this)
        {
            Instance = null;
        }
    }
}

// --- FILE: Scripts/Core/GameManager.cs ---
using UnityEngine;
using UnityEngine.SceneManagement;
using System;
using System.Collections;
using System.Collections.Generic;
using ScriptableObjects;

public enum GameState { Boot, MainMenu, Hub, Loading, InLevel, EndGame }

public enum InputMode { UI, Gameplay, Disabled }

[System.Serializable]
public class GameStateConfig
{
    public string musicState;
    public bool immediateTransition;
    public InputMode inputMode;

    public GameStateConfig(string musicState, bool immediateTransition, InputMode inputMode)
    {
        this.musicState = musicState;
        this.immediateTransition = immediateTransition;
        this.inputMode = inputMode;
    }
}

public class GameManager : SingletonPersistent<GameManager>
{
    public static event Action<GameState> OnGameStateChanged;

    public GameState CurrentState { get; private set; } = GameState.Boot;

    private string _currentActiveSceneName = "";
    private Coroutine _loadSceneCoroutine;

    [Header("Scene Data")]
    [SerializeField] private LevelData_SO mainMenuSceneData;
    [SerializeField] private LevelData_SO hubSceneData;
    public static LevelData_SO CurrentLevelToLoad { get; private set; }

    // Configuration des états du jeu
    private static readonly Dictionary<GameState, GameStateConfig> _gameStateConfigs = new Dictionary<GameState, GameStateConfig>
    {
        { GameState.Boot, new GameStateConfig("", false, InputMode.Disabled) },
        { GameState.Loading, new GameStateConfig("Silence", false, InputMode.UI) },
        { GameState.MainMenu, new GameStateConfig("MainMenu", true, InputMode.UI) },
        { GameState.Hub, new GameStateConfig("Hub", false, InputMode.UI) },
        { GameState.InLevel, new GameStateConfig("Exploration", false, InputMode.Gameplay) },
        { GameState.EndGame, new GameStateConfig("EndGame", false, InputMode.UI) } // EndGame music géré par WinLoseController
    };

    protected override void Awake()
    {
        base.Awake();
    }

    private void Start()
    {
        bool launchedFromDebug = PlayerPrefs.GetInt("DebugMode_LaunchedFromDebug", 0) == 1;

        if (launchedFromDebug)
        {
            Debug.Log("[GameManager] Lancement en mode DEBUG détecté.");

            // Récupérer l'ID du niveau à charger
            string levelIDToLoad = PlayerPrefs.GetString("DebugMode_SelectedLevelID", "");

            // Nettoyer les PlayerPrefs immédiatement
            PlayerPrefs.DeleteKey("DebugMode_LaunchedFromDebug");
            PlayerPrefs.DeleteKey("DebugMode_SelectedLevelID");
            PlayerPrefs.Save();

            if (string.IsNullOrEmpty(levelIDToLoad))
            {
                Debug.LogError("[GameManager] Mode debug détecté, mais aucun ID de niveau trouvé. Chargement du menu principal.");
                LoadMainMenu();
                return;
            }

            // --- ÉTAPE CLÉ : Retrouver l'asset LevelData_SO à partir de son ID ---
            LevelData_SO levelToLoad = FindLevelDataByID(levelIDToLoad);

            if (levelToLoad != null)
            {
                Debug.Log($"[GameManager] LevelData '{levelToLoad.DisplayName}' trouvé. Lancement du niveau...");
                // Maintenant, on appelle la méthode standard pour charger un niveau
                LoadLevel(levelToLoad);
            }
            else
            {
                Debug.LogError($"[GameManager] Impossible de trouver le LevelData_SO avec l'ID '{levelIDToLoad}'. Assurez-vous qu'il est dans un dossier 'Resources'. Chargement du menu principal.");
                LoadMainMenu();
            }
        }
        else
        {
            // Comportement normal si on ne vient pas de la scène de debug
            Debug.Log("[GameManager] Lancement en mode NORMAL. Chargement du menu principal.");
            LoadMainMenu();
        }
         if (CurrentState == GameState.Boot) // Seulement si on est vraiment au tout début
        {
            string sceneToLoad = "MainMenu"; // Scène par défaut
            if (mainMenuSceneData != null && !string.IsNullOrEmpty(mainMenuSceneData.SceneName))
            {
                sceneToLoad = mainMenuSceneData.SceneName;
            }
            else
            {
                Debug.LogWarning("[GameManager] MainMenu LevelData_SO non assigné ou SceneName vide. Tentative de charger 'MainMenu'.");
            }
            Debug.Log($"[GameManager] Start (Boot): Chargement initial de la scène '{sceneToLoad}'.");
            LoadSceneByName(sceneToLoad, GameState.MainMenu);
        }
    }

    public void LoadHub(LevelData_SO specificHubData = null)
    {
        string sceneToLoad = "MainHub"; // Scène Hub par défaut
        LevelData_SO dataToUse = specificHubData ?? hubSceneData;

        if (dataToUse != null && !string.IsNullOrEmpty(dataToUse.SceneName))
        {
            sceneToLoad = dataToUse.SceneName;
        }
        else
        {
            Debug.LogWarning("[GameManager] Hub LevelData_SO non assigné ou SceneName vide. Tentative de charger 'MainHub'.");
        }
        Debug.Log($"[GameManager] LoadHub: Demande de chargement de la scène '{sceneToLoad}'.");
        LoadSceneByName(sceneToLoad, GameState.Hub);
    }

    public void LoadLevel(LevelData_SO levelData)
    {
        if (levelData == null || string.IsNullOrEmpty(levelData.SceneName))
        {
            Debug.LogError("[GameManager] LevelData_SO ou SceneName est invalide pour LoadLevel.");
            return;
        }
        Debug.Log($"[GameManager] LoadLevel: Demande de chargement du niveau '{levelData.DisplayName}', scène '{levelData.SceneName}'.");
        CurrentLevelToLoad = levelData;
        LoadSceneByName(levelData.SceneName, GameState.InLevel);
    }

    public void LoadMainMenu()
    {
        string sceneToLoad = "MainMenu";
        if (mainMenuSceneData != null && !string.IsNullOrEmpty(mainMenuSceneData.SceneName))
        {
            sceneToLoad = mainMenuSceneData.SceneName;
        }
        else
        {
            Debug.LogWarning("[GameManager] MainMenu LevelData_SO non assigné ou SceneName vide. Tentative de charger 'MainMenu'.");
        }
        Debug.Log($"[GameManager] LoadMainMenu: Demande de chargement de la scène '{sceneToLoad}'.");
        LoadSceneByName(sceneToLoad, GameState.MainMenu);
    }

    /// <summary>
    /// Trouve un asset LevelData_SO dans les dossiers Resources du projet en utilisant son ID.
    /// </summary>
    /// <param name="levelID">L'ID du niveau à rechercher.</param>
    /// <returns>L'asset LevelData_SO ou null si non trouvé.</returns>
    private LevelData_SO FindLevelDataByID(string levelID)
    {
        // Charge tous les LevelData_SO depuis tous les sous-dossiers de "Resources".
        // Assurez-vous que le chemin est correct. Par exemple, "Data/Levels"
        LevelData_SO[] allLevels = Resources.LoadAll<LevelData_SO>("Data/Levels"); 

        Debug.Log($"[GameManager] Recherche de '{levelID}' parmi {allLevels.Length} niveaux trouvés dans Resources/Data/Levels.");

        foreach (LevelData_SO levelData in allLevels)
        {
            if (levelData.LevelID == levelID)
            {
                return levelData;
            }
        }

        // Si on ne trouve rien, on retourne null.
        return null;
    }
    private void LoadSceneByName(string sceneName, GameState targetStateAfterLoad)
    {
        if (string.IsNullOrEmpty(sceneName))
        {
            Debug.LogError("[GameManager] Tentative de chargement d'une scène avec un nom vide.");
            return;
        }

        Debug.Log($"[GameManager] LoadSceneByName: Reçu demande pour '{sceneName}'. État actuel: {CurrentState}, Scène active actuelle: '{_currentActiveSceneName}'.");

        if (CurrentState == GameState.Loading && _currentActiveSceneName == sceneName)
        {
            Debug.LogWarning($"[GameManager] La scène '{sceneName}' est déjà en cours de chargement ou est la scène active (et état Loading). Aucune action.");
            return;
        }
        if (CurrentState != GameState.Loading && _currentActiveSceneName == sceneName)
        {
            Debug.LogWarning($"[GameManager] La scène '{sceneName}' est déjà chargée et active. Passage à l'état {targetStateAfterLoad}.");
            SetState(targetStateAfterLoad); // Change juste l'état si la scène est déjà la bonne
            return;
        }

        if (_loadSceneCoroutine != null)
        {
            Debug.LogWarning($"[GameManager] Un chargement de scène ('{_currentActiveSceneName}' vers une nouvelle) est déjà en cours. Annulation du nouveau chargement pour '{sceneName}'.");
            return;
        }
        _loadSceneCoroutine = StartCoroutine(LoadSceneRoutine(sceneName, targetStateAfterLoad));
    }

    private IEnumerator LoadSceneRoutine(string sceneNameToLoad, GameState targetStateAfterLoad)
    {
        Debug.Log($"[GameManager] LoadSceneRoutine: DÉBUT pour '{sceneNameToLoad}'. _currentActiveSceneName AVANT déchargement: '{_currentActiveSceneName}'.");
        SetState(GameState.Loading);

        
        if (!string.IsNullOrEmpty(_currentActiveSceneName) && _currentActiveSceneName != sceneNameToLoad) // Ne pas décharger si on recharge la même scène
        {
            Scene sceneToUnload = SceneManager.GetSceneByName(_currentActiveSceneName);
            if (sceneToUnload.IsValid() && sceneToUnload.isLoaded)
            {
                Debug.Log($"[GameManager] LoadSceneRoutine: Déchargement de la scène '{_currentActiveSceneName}'.");
                AsyncOperation asyncUnload = SceneManager.UnloadSceneAsync(_currentActiveSceneName);
                while (asyncUnload != null && !asyncUnload.isDone) { yield return null; }
                Debug.Log($"[GameManager] LoadSceneRoutine: Scène '{_currentActiveSceneName}' déchargée.");
            }
            else
            {
                Debug.LogWarning($"[GameManager] LoadSceneRoutine: Tentative de décharger la scène '{_currentActiveSceneName}', mais elle n'est pas valide ou pas chargée. IsValid: {sceneToUnload.IsValid()}, IsLoaded: {sceneToUnload.isLoaded}.");
            }
        }
        else
        {
            Debug.Log("[GameManager] LoadSceneRoutine: _currentActiveSceneName est vide, pas de scène à décharger.");
        }
        // _currentActiveSceneName = ""; // On ne le vide pas ici, mais on le remplace après le chargement de la nouvelle

        // Charger la nouvelle scène additivement
        Debug.Log($"[GameManager] LoadSceneRoutine: Chargement additif de la scène '{sceneNameToLoad}'.");
        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(sceneNameToLoad, LoadSceneMode.Additive);
        if (asyncLoad == null) {
            Debug.LogError($"[GameManager] LoadSceneRoutine: Échec au démarrage du chargement pour '{sceneNameToLoad}'. Vérifiez les Build Settings.");
            SetState(GameState.MainMenu);
             _currentActiveSceneName = (mainMenuSceneData != null && !string.IsNullOrEmpty(mainMenuSceneData.SceneName)) ? mainMenuSceneData.SceneName : "MainMenu";
            _loadSceneCoroutine = null;
            yield break;
        }
        while (!asyncLoad.isDone) { yield return null; }
        Debug.Log($"[GameManager] LoadSceneRoutine: Scène '{sceneNameToLoad}' chargée additivement.");

        Scene newActiveScene = SceneManager.GetSceneByName(sceneNameToLoad);
        if (newActiveScene.IsValid() && newActiveScene.isLoaded)
        {
            SceneManager.SetActiveScene(newActiveScene);
            _currentActiveSceneName = newActiveScene.name;
            Debug.Log($"[GameManager] LoadSceneRoutine: Scène '{_currentActiveSceneName}' définie comme active.");
        }
        else
        {
            Debug.LogError($"[GameManager] LoadSceneRoutine: Scène '{sceneNameToLoad}' n'a pas pu être définie active. Fallback MainMenu.");
            SetState(GameState.MainMenu);
            _currentActiveSceneName = (mainMenuSceneData != null && !string.IsNullOrEmpty(mainMenuSceneData.SceneName)) ? mainMenuSceneData.SceneName : "MainMenu";
            _loadSceneCoroutine = null;
            yield break;
        }

        yield return new WaitForSeconds(0.1f); // Petit délai pour l'initialisation de la nouvelle scène

        Debug.Log($"[GameManager] LoadSceneRoutine: FIN pour '{sceneNameToLoad}'. Passage à l'état {targetStateAfterLoad}.");
        SetState(targetStateAfterLoad);
        _loadSceneCoroutine = null;
    }

    public void SetState(GameState newState)
    {
        if (CurrentState == newState && newState != GameState.Boot && newState != GameState.Loading) // Permettre la transition de Boot/Loading vers le même état final
        {
             Debug.Log($"[GameManager] SetState: État '{newState}' demandé, mais déjà actif. La logique d'état sera quand même exécutée pour assurer la cohérence.");
            // Ne pas return ici pour permettre au WinLoseController de se réinitialiser si nécessaire
        }

        GameState previousState = CurrentState;
        CurrentState = newState;
        Debug.Log($"[GameManager] SetState: État changé de '{previousState}' vers '{newState}'.");
        OnGameStateChanged?.Invoke(newState);

        // Gérer la réinitialisation du WinLoseController
        if (WinLoseController.Instance != null)
        {
            bool shouldResetWLC = (newState == GameState.InLevel || newState == GameState.Hub || newState == GameState.MainMenu);
            if (shouldResetWLC)
            {
                // On réinitialise toujours WinLoseController en entrant dans ces états pour assurer un état propre,
                // que le jeu précédent se soit terminé ou non. ResetGameConditionState est idempotent.
                Debug.Log($"[GameManager] Nouvel état ({newState}). APPEL de WinLoseController.ResetGameConditionState(). IsGameOver avant: {WinLoseController.Instance.IsGameOver}", this);
                WinLoseController.Instance.ResetGameConditionState();
            }
        }
        if (newState == GameState.Hub || newState == GameState.MainMenu)
        {
            // Nettoyer les données du niveau actuel
            CurrentLevelToLoad = null; // Réinitialiser le niveau actuel
            Debug.Log("[GameManager] Retour au Hub/Menu. Les données du niveau actuel ont été nettoyées.");
        }
        // Gérer les configurations d'état (musique et input)
        if (_gameStateConfigs.TryGetValue(newState, out GameStateConfig config))
        {
            // Gérer la musique
            if (MusicManager.Instance != null)
            {
                if (!string.IsNullOrEmpty(config.musicState))
                {
                    MusicManager.Instance.SetMusicState(config.musicState, config.immediateTransition);
                    Debug.Log($"[GameManager] Musique changée vers '{config.musicState}' (transition immédiate: {config.immediateTransition})");
                }
            }
            else
            {
                Debug.LogWarning("[GameManager] MusicManager.Instance est null. Impossible de changer l'état musical.");
            }

            // Gérer les Action Maps d'Input
            if (InputManager.Instance != null)
            {
                switch (config.inputMode)
                {
                    case InputMode.UI:
                        InputManager.Instance.UIActions.Enable();
                        InputManager.Instance.GameplayActions.Disable();
                        Debug.Log("[GameManager] Action Maps: UI activée, Gameplay désactivée");
                        break;
                    
                    case InputMode.Gameplay:
                        InputManager.Instance.GameplayActions.Enable();
                        InputManager.Instance.UIActions.Disable();
                        Debug.Log("[GameManager] Action Maps: Gameplay activée, UI désactivée");
                        break;
                    
                    case InputMode.Disabled:
                        InputManager.Instance.UIActions.Disable();
                        InputManager.Instance.GameplayActions.Disable();
                        Debug.Log("[GameManager] Action Maps: Toutes désactivées");
                        break;
                }
            }
            else
            {
                Debug.LogWarning("[GameManager] InputManager.Instance est null. Impossible de changer les Action Maps.");
            }
        }
        else
        {
            Debug.LogWarning($"[GameManager] Aucune configuration trouvée pour GameState: {newState}");
        }
    }
}


// --- FILE: Scripts/Core/InputDeviceManager.cs ---
﻿using UnityEngine;
using UnityEngine.InputSystem;

public enum InputDeviceType
{
    KeyboardAndMouse,
    Gamepad
}

public class InputDeviceManager : MonoBehaviour
{
    public static InputDeviceManager Instance { get; private set; }
    public InputDeviceType CurrentDevice { get; private set; }

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    private void OnEnable()
    {
        // On s'abonne à l'événement global de changement d'action
        InputSystem.onActionChange += OnActionChange;
    }

    private void OnDisable()
    {
        InputSystem.onActionChange -= OnActionChange;
    }

    private void OnActionChange(object obj, InputActionChange change)
    {
        // On s'intéresse uniquement au moment où une action est effectuée
        if (change != InputActionChange.ActionStarted)
            return;

        // On récupère le dernier appareil qui a déclenché l'action
        var lastDevice = ((InputAction)obj).activeControl?.device;

        if (lastDevice == null)
            return;

        // On vérifie le type de l'appareil et on met à jour notre état
        if (lastDevice is Gamepad)
        {
            if (CurrentDevice != InputDeviceType.Gamepad)
            {
                CurrentDevice = InputDeviceType.Gamepad;
                OnDeviceChanged();
            }
        }
        else if (lastDevice is Keyboard || lastDevice is Mouse)
        {
            if (CurrentDevice != InputDeviceType.KeyboardAndMouse)
            {
                CurrentDevice = InputDeviceType.KeyboardAndMouse;
                OnDeviceChanged();
            }
        }
    }

    private void OnDeviceChanged()
    {
        Debug.Log($"Input device changed to: {CurrentDevice}");
        if (CurrentDevice == InputDeviceType.Gamepad)
        {
            // On cache et verrouille le curseur
            Cursor.visible = false;
            Cursor.lockState = CursorLockMode.Locked;
        }
        else // KeyboardAndMouse
        {
            // On affiche et libère le curseur
            Cursor.visible = true;
            Cursor.lockState = CursorLockMode.None;
        }
    }
}

// --- FILE: Scripts/Core/InputManager.cs ---
﻿using UnityEngine;
using UnityEngine.InputSystem; 

public class InputManager : MonoBehaviour
{
    public static InputManager Instance { get; private set; }

    // --- Actions ---
    // Référence à notre classe de contrôles générée automatiquement.
    private GameControls _playerControls;

    void Awake()
    {
        // --- Singleton Initialisation ---
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
        DontDestroyOnLoad(gameObject); // Pour le garder actif entre les scènes (ex: du MainMenu au niveau)

        // --- Initialisation des Contrôles ---
        _playerControls = new GameControls();
        Debug.Log("[InputManager] PlayerControls initialisés.");
    }

    private void OnEnable()
    {
        _playerControls.Enable(); // Active toutes les Action Maps
    }

    private void OnDisable()
    {
        _playerControls.Disable(); // Désactive tout
    }

    // --- Méthodes d'Accès Publiques ---
    // Les autres scripts n'accéderont pas directement à _playerControls.
    // Ils passeront par ces méthodes et propriétés, ce qui est plus propre.

    // Accès aux actions de Gameplay
    public GameControls.GameplayActions GameplayActions => _playerControls.Gameplay;

    // Accès aux actions de l'UI
    public GameControls.UIActions UIActions => _playerControls.UI;
    
    // Vous pouvez aussi exposer des valeurs spécifiques si nécessaire
    public Vector2 GetCameraMove()
    {
        // Ne lit la valeur que si l'action map Gameplay est activée
        if (_playerControls.Gameplay.enabled)
        {
            return _playerControls.Gameplay.CameraMove.ReadValue<Vector2>();
        }
        return Vector2.zero;
    }
    
    public Vector2 GetCameraPan()
    {
        if (_playerControls.Gameplay.enabled)
        {
           return _playerControls.Gameplay.CameraPan.ReadValue<Vector2>();
        }
        return Vector2.zero;
    }
    
}

// --- FILE: Scripts/Core/IScenarioTriggerable.cs ---
/// <summary>
/// Interface pour les objets qui peuvent être déclenchés par un événement du LevelScenarioManager.
/// </summary>
public interface IScenarioTriggerable
{
    /// <summary>
    /// Exécute l'action principale de l'objet.
    /// </summary>
    void TriggerAction();
}

// --- FILE: Scripts/Core/LevelScenarioManager.cs ---
﻿using UnityEngine;
using Unity.Behavior.GraphFramework;
using Unity.Behavior;
using System;
using System.Collections;
using System.Collections.Generic;
using ScriptableObjects;
using Gameplay;

public class LevelScenarioManager : MonoBehaviour
{
    private LevelScenario_SO _currentScenario;
    private readonly Dictionary<ScenarioEvent, bool> _processedEvents = new Dictionary<ScenarioEvent, bool>();
    private float _levelStartTime;

    private class ObjectiveTracker
    {
        public int CurrentCount;
    }
    private readonly Dictionary<string, ObjectiveTracker> _destroyAllTrackers = new Dictionary<string, ObjectiveTracker>();

    public void Initialize(LevelScenario_SO scenario)
    {
        if (scenario == null) {
            Debug.LogWarning("[LevelScenarioManager] Aucun scénario fourni.", this);
            enabled = false;
            return;
        }
        _currentScenario = scenario;
        _processedEvents.Clear();
        _destroyAllTrackers.Clear();

        Debug.Log($"[LevelScenarioManager] Initialisé avec le scénario: '{_currentScenario.scenarioName}'.", this);

        ParseScenarioForObjectives();
        SubscribeToGameEvents();
        _levelStartTime = Time.time;
        ProcessEvents(TriggerType.OnLevelStart);
    }

    private void OnDestroy()
    {
        UnsubscribeFromGameEvents();
    }

    private void Update()
    {
        if (_currentScenario != null) ProcessTimerEvents();
    }

    private void ParseScenarioForObjectives()
    {
        foreach (var evt in _currentScenario.events)
        {
            if (evt.triggerType == TriggerType.OnAllTargetsWithTagDestroyed)
            {
                string tag = evt.triggerParameter;
                if (string.IsNullOrEmpty(tag)) continue;

                if (!_destroyAllTrackers.ContainsKey(tag))
                {
                    int initialCount = GameObject.FindGameObjectsWithTag(tag).Length;
                    _destroyAllTrackers[tag] = new ObjectiveTracker { CurrentCount = initialCount };
                    Debug.Log($"[LevelScenarioManager] OBJECTIF SUIVI : Détruire toutes les cibles avec le tag '{tag}'. Nombre initial : {initialCount}.");
                }
            }
        }
    }

    private void SubscribeToGameEvents()
    {
        Building.OnBuildingDestroyed += HandleTargetDestroyed;
        TriggerZone.OnZoneEntered += HandleZoneEntered;
        Building.OnBuildingTeamChangedGlobal += HandleBuildingTeamChanged;
    }

    private void UnsubscribeFromGameEvents()
    {
        Building.OnBuildingDestroyed -= HandleTargetDestroyed;
        TriggerZone.OnZoneEntered -= HandleZoneEntered;
        Building.OnBuildingTeamChangedGlobal -= HandleBuildingTeamChanged;
    }

    #region Handlers

    private void HandleBuildingTeamChanged(Building building, TeamType oldTeam, TeamType newTeam)
    {
        if (building != null && newTeam == TeamType.Player)
        {
            Debug.Log($"[LevelScenarioManager] Bâtiment '{building.name}' capturé par le joueur. Déclenchement des événements OnBuildingCaptured.");
            ProcessEvents(TriggerType.OnBuildingCaptured, building.name);
        }
    }

    private void HandleTargetDestroyed(Building destroyedBuilding)
    {
        if (destroyedBuilding == null) return;

        string destroyedName = destroyedBuilding.name;
        string destroyedTag = destroyedBuilding.tag;

        ProcessEvents(TriggerType.OnSpecificTargetDestroyed, destroyedName);

        if (_destroyAllTrackers.ContainsKey(destroyedTag))
        {
            var tracker = _destroyAllTrackers[destroyedTag];
            tracker.CurrentCount--;
            Debug.Log($"[LevelScenarioManager] Cible avec tag '{destroyedTag}' détruite. Restant: {tracker.CurrentCount}.");

            if (tracker.CurrentCount <= 0)
            {
                ProcessEvents(TriggerType.OnAllTargetsWithTagDestroyed, destroyedTag);
            }
        }
    }

    private void HandleZoneEntered(string zoneID)
    {
        ProcessEvents(TriggerType.OnZoneEnter, zoneID);
    }

    #endregion

    private void ProcessEvents(TriggerType trigger, string param = "")
    {
        if (_currentScenario == null) return;

        foreach (var evt in _currentScenario.events)
        {
            if (evt.triggerType == trigger && !_processedEvents.ContainsKey(evt))
            {
                bool match = false;

                if (trigger == TriggerType.OnZoneEnter ||
                    trigger == TriggerType.OnSpecificTargetDestroyed ||
                    trigger == TriggerType.OnAllTargetsWithTagDestroyed ||
                    trigger == TriggerType.OnBuildingCaptured)
                {
                    match = (evt.triggerParameter == param);
                }
                else
                {
                    match = true;
                }

                if (match)
                {
                    _processedEvents.Add(evt, true);
                    StartCoroutine(ExecuteActionWithDelay(evt));
                }
            }
        }
    }

    private void ProcessTimerEvents()
    {
        if (_currentScenario == null) return;
        float elapsedTime = Time.time - _levelStartTime;
        foreach (var evt in _currentScenario.events)
        {
            if (evt.triggerType == TriggerType.OnTimerElapsed && !_processedEvents.ContainsKey(evt))
            {
                if (float.TryParse(evt.triggerParameter, out float triggerTime) && elapsedTime >= triggerTime)
                {
                    _processedEvents.Add(evt, true);
                    StartCoroutine(ExecuteActionWithDelay(evt));
                }
            }
        }
    }

    private IEnumerator ExecuteActionWithDelay(ScenarioEvent scenarioEvent)
    {
        yield return new WaitForSeconds(scenarioEvent.delay);

        Debug.Log($"[LevelScenarioManager] Exécution de l'action '{scenarioEvent.actionType}' pour '{scenarioEvent.eventName}'.", this);

        switch (scenarioEvent.actionType)
        {
            // ----- MODIFICATION ICI -----
            case ActionType.ActivateSpawnerBuilding:
            case ActionType.DeactivateSpawnerBuilding:
                bool isActive = scenarioEvent.actionType == ActionType.ActivateSpawnerBuilding;
                SetSpawnerBuildingActive(scenarioEvent.actionParameter_GameObjectName, isActive);
                break;
            case ActionType.StartWave:
                CommandWaveToSpawner(scenarioEvent.actionParameter_GameObjectName, scenarioEvent.actionParameter_Wave);
                break;
            case ActionType.TriggerGameObject:
                 TriggerGameObjectByName(scenarioEvent.actionParameter_GameObjectName);
                break;
            // ---------------------------
            case ActionType.EndLevel:
                if (GameManager.Instance != null) GameManager.Instance.LoadHub();
                break;
            case ActionType.TriggerVictory:
                if (WinLoseController.Instance != null)
                    WinLoseController.Instance.TriggerWinCondition();
                else
                    Debug.LogError("[LevelScenarioManager] WinLoseController.Instance non trouvé pour TriggerVictory !");
                break;
            case ActionType.TriggerDefeat:
                if (WinLoseController.Instance != null)
                    WinLoseController.Instance.TriggerLoseCondition();
                else
                    Debug.LogError("[LevelScenarioManager] WinLoseController.Instance non trouvé pour TriggerDefeat !");
                break;
        }
    }

    private void SetSpawnerBuildingActive(string spawnerName, bool isActive)
    {
        if (string.IsNullOrEmpty(spawnerName))
        {
            Debug.LogWarning($"[LevelScenarioManager] Aucun nom de spawner fourni pour SetSpawnerBuildingActive.", this);
            return;
        }

        GameObject spawnerGO = GameObject.Find(spawnerName);
        if (spawnerGO == null)
        {
            Debug.LogWarning($"[LevelScenarioManager] Aucun spawner avec le nom '{spawnerName}' trouvé.", this);
            return;
        }

        var agent = spawnerGO.GetComponent<BehaviorGraphAgent>();
        if (agent != null && agent.BlackboardReference != null)
        {
            if (agent.BlackboardReference.GetVariable("IsActive", out BlackboardVariable<bool> bbIsActive))
            {
                bbIsActive.Value = isActive;
                Debug.Log($"[LevelScenarioManager] Bâtiment spawner '{spawnerGO.name}' mis à IsActive = {isActive}.", this);
            }
        }
    }

    private void CommandWaveToSpawner(string spawnerName, Wave_SO wave)
    {
        if (wave == null || string.IsNullOrEmpty(spawnerName)) return;

        GameObject spawnerGO = GameObject.Find(spawnerName);
        if (spawnerGO == null)
        {
            Debug.LogWarning($"[LevelScenarioManager] Aucun spawner avec le nom '{spawnerName}' trouvé pour l'action StartWave.");
            return;
        }

        Debug.Log($"[LevelScenarioManager] Commande de la vague '{wave.waveName}' au spawner '{spawnerName}'.");

        var agent = spawnerGO.GetComponent<BehaviorGraphAgent>();
        if (agent != null && agent.BlackboardReference != null)
        {
            if (agent.BlackboardReference.GetVariable("CommandedWave", out BlackboardVariable<Wave_SO> bbCommandedWave))
            {
                bbCommandedWave.Value = wave;
                Debug.Log($"[LevelScenarioManager] Vague '{wave.waveName}' envoyée au blackboard du spawner '{spawnerGO.name}'.");
            }
        }
    }

    private void TriggerGameObjectByName(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            Debug.LogWarning($"[LevelScenarioManager] L'action TriggerGameObject a été appelée avec un nom de GameObject vide.", this);
            return;
        }

        GameObject targetObject = GameObject.Find(name);

        if (targetObject == null)
        {
            Debug.LogError($"[LevelScenarioManager] Impossible de trouver le GameObject nommé '{name}' pour le déclencher.", this);
            return;
        }

        IScenarioTriggerable triggerable = targetObject.GetComponent<IScenarioTriggerable>();

        if (triggerable != null)
        {
            Debug.Log($"[LevelScenarioManager] Déclenchement de l'action sur '{name}'.", this);
            triggerable.TriggerAction();
        }
        else
        {
            Debug.LogWarning($"[LevelScenarioManager] Le GameObject '{name}' a été trouvé, mais il n'a pas de composant implémentant l'interface IScenarioTriggerable.", this);
        }
    }
}

// --- FILE: Scripts/Core/PlayerDataManager.cs ---
using UnityEngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq; 
using ScriptableObjects;
using Newtonsoft.Json;

[System.Serializable]
public class CharacterProgress
{
    public int CurrentLevel = 1;
    public int CurrentXP = 0;
}

/// <summary>
/// Structure pour stocker les données de sauvegarde du joueur.
/// </summary>
[System.Serializable]
public class PlayerSaveData
{
    public int Currency = 0;
    public int Experience = 0;
    public List<string> UnlockedCharacterIDs = new List<string>();
    public Dictionary<string, int> CompletedLevels = new Dictionary<string, int>();
    public List<string> ActiveTeamCharacterIDs = new List<string>();
    public List<string> UnlockedEquipmentIDs = new List<string>();

    public Dictionary<string, List<string>> EquippedItems = new Dictionary<string, List<string>>();
    public Dictionary<string, CharacterProgress> CharacterProgressData = new Dictionary<string, CharacterProgress>();

    // Options du jeu
    public float MusicVolume = 0.7f;
    public float SfxVolume = 0.75f;
    public bool VibrationEnabled = true;
    public bool ShowBeatIndicator = false; // Ajout de la nouvelle variable
}

/// <summary>
/// Manager persistant (Singleton) pour gérer les données du joueur (sauvegarde, chargement, accès).
/// Déclenche des événements lors des modifications.
/// </summary>
public class PlayerDataManager : SingletonPersistent<PlayerDataManager>
{
    // --- Événements Statiques ---
    public static event Action<int> OnCurrencyChanged;
    public static event Action<string> OnCharacterUnlocked;
    public static event Action<int> OnExperienceGained;
    /// <summary>
    /// Déclenché après le chargement initial des données ou la création de nouvelles données par défaut.
    /// Utile pour les autres managers qui dépendent de ces données (ex: TeamManager).
    /// </summary>
    public static event Action OnPlayerDataLoaded;

    // --- Propriétés ---
    public PlayerSaveData Data { get; private set; }

    // --- Variables Privées ---
    private string _saveFilePath;
    private const string SAVE_FILE_NAME = "playerData.json";
    private bool _isDataLoaded = false; // Pour s'assurer que OnPlayerDataLoaded n'est appelé qu'une fois

    // --- Méthodes Unity ---

    protected override void Awake()
    {
        base.Awake(); // Gère le pattern Singleton et DontDestroyOnLoad
        _saveFilePath = Path.Combine(Application.persistentDataPath, SAVE_FILE_NAME);
        Debug.Log($"[PlayerDataManager] Chemin de sauvegarde : {_saveFilePath}");
        LoadData();
    }

    private void Start()
    {
        // Déclencher l'événement OnPlayerDataLoaded ici, après que Awake ait pu s'exécuter sur tous les singletons
        // et que les données soient garanties d'être chargées ou créées.
        if (!_isDataLoaded)
        {
             Debug.Log("[PlayerDataManager] Déclenchement de OnPlayerDataLoaded.");
             OnPlayerDataLoaded?.Invoke();
            _isDataLoaded = true;
        }
    }

    // --- Sauvegarde / Chargement ---

    public void SaveData()
    {
        try
        {
            string json = JsonConvert.SerializeObject(Data, Formatting.Indented);
            File.WriteAllText(_saveFilePath, json);
            Debug.Log($"[PlayerDataManager] Données sauvegardées dans {_saveFilePath}");
        }
        catch (Exception e)
        {
            Debug.LogError($"[PlayerDataManager] Échec de la sauvegarde des données : {e.Message}\n{e.StackTrace}");
        }
    }

    public void LoadData()
    {
        if (File.Exists(_saveFilePath))
        {
            try
            {
                string json = File.ReadAllText(_saveFilePath);
                Data = JsonConvert.DeserializeObject<PlayerSaveData>(json);

                // Sécurité : S'assurer que les listes ne sont pas null après désérialisation
                if (Data.UnlockedCharacterIDs == null) Data.UnlockedCharacterIDs = new List<string>();
                if (Data.CompletedLevels == null) Data.CompletedLevels = new Dictionary<string, int>();
                if (Data.ActiveTeamCharacterIDs == null) Data.ActiveTeamCharacterIDs = new List<string>();

                Debug.Log($"[PlayerDataManager] Données chargées depuis {_saveFilePath}. Monnaie: {Data.Currency}, XP: {Data.Experience}, Persos: {Data.UnlockedCharacterIDs.Count}, Équipe: {Data.ActiveTeamCharacterIDs.Count}");
            }
            catch (Exception e)
            {
                Debug.LogError($"[PlayerDataManager] Échec du chargement du fichier de sauvegarde : {e.Message}. Création de nouvelles données par défaut.");
                CreateDefaultData();
                SaveData();
            }
        }
        else
        {
            Debug.Log("[PlayerDataManager] Aucun fichier de sauvegarde trouvé. Création de nouvelles données par défaut.");
            CreateDefaultData();
            SaveData(); // Sauvegarder les nouvelles données par défaut
        }
         _isDataLoaded = false; // Reset flag pour que Start puisse déclencher l'event
    }

    private void CreateDefaultData()
    {
        Data = new PlayerSaveData();
        Data.Currency = 50; // Monnaie initiale
        Data.Experience = 0;
        Data.UnlockedCharacterIDs = new List<string>();
        Data.ActiveTeamCharacterIDs = new List<string>();
        Data.CompletedLevels = new Dictionary<string, int>();

        // Débloquer les personnages par défaut
        // Important: Ceci nécessite que les assets CharacterData_SO soient accessibles,
        // par exemple dans un dossier Resources ou via un Asset Database spécifique.
        CharacterData_SO[] allCharacters = Resources.LoadAll<CharacterData_SO>("Data/Characters"); // Adapte le chemin si nécessaire

        Debug.Log($"[PlayerDataManager] Recherche des personnages par défaut parmi {allCharacters.Length} assets CharacterData_SO trouvés dans Resources/Data/Characters.");

        List<string> defaultTeam = new List<string>();
        foreach (var charData in allCharacters)
        {
            if (charData.UnlockedByDefault)
            {
                if (!Data.UnlockedCharacterIDs.Contains(charData.CharacterID))
                {
                    Data.UnlockedCharacterIDs.Add(charData.CharacterID);
                    Debug.Log($"[PlayerDataManager] Personnage par défaut débloqué : {charData.CharacterID}");
                    //Donne 10 XP initial pour chaque personnage débloqué par défaut
                    AddXPToCharacter(charData.CharacterID, 50); 
                    // Ajouter les premiers persos débloqués à l'équipe par défaut (jusqu'à 4)
                    if (defaultTeam.Count < 4)
                    {
                        defaultTeam.Add(charData.CharacterID);
                    }
                }
            }
        }

         // Si aucun perso n'est débloqué par défaut, ajoutons le premier trouvé comme perso initial (sécurité)
         if (Data.UnlockedCharacterIDs.Count == 0 && allCharacters.Length > 0)
         {
             CharacterData_SO firstChar = allCharacters[0];
             Data.UnlockedCharacterIDs.Add(firstChar.CharacterID);
             Debug.LogWarning($"[PlayerDataManager] Aucun personnage marqué comme 'UnlockedByDefault'. Ajout du premier trouvé : {firstChar.CharacterID}");
              if (defaultTeam.Count < 4)
              {
                  defaultTeam.Add(firstChar.CharacterID);
              }
         }


        // Définir l'équipe active par défaut
        Data.ActiveTeamCharacterIDs = defaultTeam;
        Debug.Log($"[PlayerDataManager] Équipe par défaut définie : {string.Join(", ", defaultTeam)}");

        Debug.Log("[PlayerDataManager] Nouvelles données par défaut créées.");
    }
    public void CompleteLevel(string levelID, int stars)
    {
        if (string.IsNullOrEmpty(levelID)) return;
        stars = Mathf.Clamp(stars, 0, 3); // Ensure stars are between 0 and 3.

        // Update if exists with a better score, or add if new.
        if (Data.CompletedLevels.ContainsKey(levelID))
        {
            if (stars > Data.CompletedLevels[levelID])
            {
                Data.CompletedLevels[levelID] = stars;
                Debug.Log($"[PlayerDataManager] Score du niveau '{levelID}' mis à jour à {stars} étoile(s).");
            }
        }
        else
        {
            Data.CompletedLevels.Add(levelID, stars);
            Debug.Log($"[PlayerDataManager] Niveau '{levelID}' complété avec {stars} étoile(s).");
        }
        SaveData();
    }
    // --- Gestion de la Monnaie ---

    public void AddCurrency(int amount)
    {
        if (amount <= 0) return;
        Data.Currency += amount;
        Debug.Log($"[PlayerDataManager] Monnaie ajoutée: +{amount}. Total: {Data.Currency}");
        OnCurrencyChanged?.Invoke(Data.Currency);
        SaveData();
    }

    public bool SpendCurrency(int amount)
    {
        if (amount <= 0) return false;
        if (Data.Currency >= amount)
        {
            Data.Currency -= amount;
            Debug.Log($"[PlayerDataManager] Monnaie dépensée: -{amount}. Reste: {Data.Currency}");
            OnCurrencyChanged?.Invoke(Data.Currency);
            SaveData();
            return true;
        }
        else
        {
            Debug.LogWarning($"[PlayerDataManager] Tentative de dépenser {amount}, mais seulement {Data.Currency} disponible.");
            return false;
        }
    }

    // --- Gestion de l'Expérience ---

    public void AddExperience(int amount)
    {
        if (amount <= 0) return;
        Data.Experience += amount;
        Debug.Log($"[PlayerDataManager] XP ajoutée: +{amount}. Total: {Data.Experience}");
        OnExperienceGained?.Invoke(Data.Experience);
        SaveData();
        // TODO: Ajouter la logique de montée de niveau si nécessaire
    }

    // --- Gestion des Déblocages ---

    public bool IsCharacterUnlocked(string characterID)
    {
        return Data.UnlockedCharacterIDs.Contains(characterID);
    }

    public void UnlockCharacter(string characterID)
    {
        if (!Data.UnlockedCharacterIDs.Contains(characterID))
        {
            Data.UnlockedCharacterIDs.Add(characterID);
            Debug.Log($"[PlayerDataManager] Personnage débloqué : {characterID}");
            AddXPToCharacter(characterID, 50); 
            OnCharacterUnlocked?.Invoke(characterID); // Notifier les autres systèmes
            SaveData();
        }
        else
        {
            Debug.LogWarning($"[PlayerDataManager] Tentative de débloquer un personnage déjà débloqué : {characterID}");
        }
    }

    public List<string> GetUnlockedCharacterIDs()
    {
        return new List<string>(Data.UnlockedCharacterIDs); // Retourne une copie
    }

    // --- Gestion de l'Équipe Active ---

    public List<string> GetActiveTeamIDs()
    {
        return new List<string>(Data.ActiveTeamCharacterIDs); // Retourne une copie
    }

    public bool SetActiveTeam(List<string> teamCharacterIDs)
    {
        if (teamCharacterIDs == null)
        {
             Debug.LogError("[PlayerDataManager] Tentative de définir une équipe active null.");
             return false;
        }
        if (teamCharacterIDs.Count > 4)
        {
            Debug.LogError($"[PlayerDataManager] Tentative de définir une équipe de {teamCharacterIDs.Count} personnages (Max 4).");
            return false;
        }

        // Vérifier que tous les personnages de la nouvelle équipe sont débloqués
        foreach (string id in teamCharacterIDs)
        {
            if (!IsCharacterUnlocked(id))
            {
                Debug.LogError($"[PlayerDataManager] Tentative d'ajouter le personnage non débloqué '{id}' à l'équipe active.");
                return false; // Échouer si un personnage n'est pas débloqué
            }
        }

        Data.ActiveTeamCharacterIDs = new List<string>(teamCharacterIDs); // Assigner la nouvelle liste
        Debug.Log($"[PlayerDataManager] Équipe active mise à jour : {string.Join(", ", Data.ActiveTeamCharacterIDs)}");
        SaveData();
        // Note : TeamManager écoutera OnPlayerDataLoaded pour se mettre à jour,
        // mais on pourrait aussi avoir un event OnActiveTeamChanged spécifique ici si besoin.
        return true;
    }

     // --- Utilitaires ---

     [ContextMenu("Supprimer Sauvegarde")]
     public void DeleteSaveFile()
     {
         if (File.Exists(_saveFilePath))
         {
             try
             {
                 File.Delete(_saveFilePath);
                 Debug.Log($"[PlayerDataManager] Fichier de sauvegarde supprimé : {_saveFilePath}");
                 // Recharger les données par défaut après suppression
                 LoadData();
                 OnPlayerDataLoaded?.Invoke(); // Notifier que de nouvelles données sont prêtes
             }
             catch (Exception e)
             {
                 Debug.LogError($"[PlayerDataManager] Échec de la suppression du fichier de sauvegarde : {e.Message}");
             }
         }
         else
         {
             Debug.LogWarning("[PlayerDataManager] Aucun fichier de sauvegarde à supprimer.");
         }
     }
     
     [ContextMenu("Simulate First 2 Levels Complete")]
     private void SimulateLevelCompletion()
     {
         // This requires you to know the IDs of your first few levels.
         // Replace "Level_01" and "Level_02" with actual LevelIDs from your SOs.
         LevelData_SO[] allLevels = Resources.LoadAll<LevelData_SO>("Data/Levels").OrderBy(l => l.DisplayName).ToArray();
         if (allLevels.Length > 0) CompleteLevel(allLevels[0].LevelID, 3); // 3 stars on first level
         if (allLevels.Length > 1) CompleteLevel(allLevels[1].LevelID, 1); // 1 star on second level
        
         Debug.Log("[PlayerDataManager] Données de test de complétion de niveau appliquées.");
         OnPlayerDataLoaded?.Invoke(); // Notify systems to refresh with new data
     }
     
     public void AddXPToCharacter(string characterID, int xpAmount)
     {
         // 1. Trouver le CharacterData pour obtenir sa courbe de progression
         CharacterData_SO charData = Resources.Load<CharacterData_SO>($"Data/Characters/{characterID}");
         if (charData == null || charData.Stats == null)
         {
             Debug.LogError($"[PlayerDataManager] Impossible d'ajouter de l'XP : CharacterData ou ProgressionData manquant pour l'ID {characterID}");
             return;
         }

         // 2. Initialiser la progression si elle n'existe pas
         if (!Data.CharacterProgressData.ContainsKey(characterID))
         {
             Data.CharacterProgressData[characterID] = new CharacterProgress();
         }

         CharacterProgress progress = Data.CharacterProgressData[characterID];
         progress.CurrentXP += xpAmount;

         // 3. Boucle de montée de niveau
         int xpForNextLevel = charData.Stats.GetXPRequiredForLevel(progress.CurrentLevel + 1);
         Debug.Log($"[PlayerDataManager] Ajout de {xpAmount} XP à {characterID}. XP actuel: {progress.CurrentXP}, Niveau actuel: {progress.CurrentLevel}, XP pour le niveau suivant: {xpForNextLevel}");
         while (progress.CurrentXP >= xpForNextLevel && xpForNextLevel > 0)
         {
             progress.CurrentLevel++;
             // On ne soustrait pas l'XP, car la courbe représente le total requis.
             // On pourrait le faire si la courbe représentait l'XP *par* niveau.
             // Pour l'instant, on garde le total.
            
             Debug.Log($"Personnage {characterID} est monté au niveau {progress.CurrentLevel}!");
             // Mettre à jour le montant requis pour le niveau suivant
             xpForNextLevel = charData.Stats.GetXPRequiredForLevel(progress.CurrentLevel + 1);
             if (xpForNextLevel == charData.Stats.GetXPRequiredForLevel(progress.CurrentLevel))
             {
                 Debug.Log($"[PlayerDataManager] Niveau maximum atteint pour {characterID} : {progress.CurrentLevel}");
                 // On a atteint le niveau max défini dans la courbe, on sort.
                 break;
             }
         }
         SaveData();
     }

     
     public void UnlockEquipment(string equipmentID)
     {
         if (!Data.UnlockedEquipmentIDs.Contains(equipmentID))
         {
             Data.UnlockedEquipmentIDs.Add(equipmentID);
             Debug.Log($"Equipment unlocked: {equipmentID}");
             SaveData();
         }
     }

     public void EquipItemOnCharacter(string characterID, string equipmentID)
     {
         if (!Data.UnlockedEquipmentIDs.Contains(equipmentID)) return;

         // Initialize dictionary entry if it doesn't exist
         if (!Data.EquippedItems.ContainsKey(characterID))
         {
             Data.EquippedItems[characterID] = new List<string>();
         }

         // TODO: Add logic to check if a slot of the same type is already occupied
         // before adding the new item.

         Data.EquippedItems[characterID].Add(equipmentID);
         SaveData();
     }

     public void UnequipItemFromCharacter(string characterID, string equipmentID)
     {
         if (Data.EquippedItems.ContainsKey(characterID))
         {
             Data.EquippedItems[characterID].Remove(equipmentID);
             SaveData();
         }
     }
     
     
     /// <summary>
     /// Débloque une liste d'équipements pour le joueur.
     /// </summary>
     /// <param name="equipmentIDs">La liste des EquipmentID à ajouter à l'inventaire.</param>
     public void UnlockMultipleEquipment(List<string> equipmentIDs)
     {
         if (equipmentIDs == null) return;

         int itemsAdded = 0;
         foreach (string id in equipmentIDs)
         {
             if (!string.IsNullOrEmpty(id) && !Data.UnlockedEquipmentIDs.Contains(id))
             {
                 Data.UnlockedEquipmentIDs.Add(id);
                 itemsAdded++;
             }
         }

         if (itemsAdded > 0)
         {
             Debug.Log($"[PlayerDataManager] {itemsAdded} nouveaux items d'équipement débloqués.");
             SaveData();
             // Optionnel : Déclencher un événement si l'UI de l'inventaire doit être notifiée globalement.
         }
     }
     
     // --- Gestion des Options de Jeu ---
     
     /// <summary>
     /// Événements pour notifier les changements d'options
     /// </summary>
     public static event Action<float> OnMusicVolumeChanged;
     public static event Action<float> OnSfxVolumeChanged;
     public static event Action<bool> OnVibrationChanged;
     public static event Action<bool> OnShowBeatIndicatorChanged; // Ajout de l'événement
     
     public void SetMusicVolume(float volume)
     {
         volume = Mathf.Clamp01(volume);
         if (!Mathf.Approximately(Data.MusicVolume, volume))
         {
             Data.MusicVolume = volume;
             OnMusicVolumeChanged?.Invoke(volume);
             SaveData();
             Debug.Log($"[PlayerDataManager] Volume musique réglé : {volume * 100:F0}%");
         }
     }
     
     public void SetSfxVolume(float volume)
     {
         volume = Mathf.Clamp01(volume);
         if (!Mathf.Approximately(Data.SfxVolume, volume))
         {
             Data.SfxVolume = volume;
             OnSfxVolumeChanged?.Invoke(volume);
             SaveData();
             Debug.Log($"[PlayerDataManager] Volume SFX réglé : {volume * 100:F0}%");
         }
     }
     
     public void SetVibrationEnabled(bool enabled)
     {
         if (Data.VibrationEnabled != enabled)
         {
             Data.VibrationEnabled = enabled;
             OnVibrationChanged?.Invoke(enabled);
             SaveData();
             Debug.Log($"[PlayerDataManager] Vibrations {(enabled ? "activées" : "désactivées")}");
         }
     }
     
     // Ajout de la méthode pour le beat indicator
     public void SetShowBeatIndicator(bool enabled)
     {
         if (Data.ShowBeatIndicator != enabled)
         {
             Data.ShowBeatIndicator = enabled;
             OnShowBeatIndicatorChanged?.Invoke(enabled);
             SaveData();
             Debug.Log($"[PlayerDataManager] Beat Indicator {(enabled ? "activé" : "désactivé")}");
         }
     }
     
     public float GetMusicVolume() => Data.MusicVolume;
     public float GetSfxVolume() => Data.SfxVolume;
     public bool IsVibrationEnabled() => Data.VibrationEnabled;
     // Ajout du getter pour le beat indicator
     public bool IsShowBeatIndicatorEnabled() => Data.ShowBeatIndicator;
}

// --- FILE: Scripts/Core/SingletonPersistent.cs ---
using UnityEngine;

/// <summary>
/// Singleton persistant générique pour les Managers Globaux.
/// </summary>
/// <typeparam name="T">Le type du manager.</typeparam>
public abstract class SingletonPersistent<T> : MonoBehaviour where T : Component
{
    public static T Instance { get; private set; }

    protected virtual void Awake()
    {
        if (Instance == null)
        {
            Instance = this as T;
            // Assurer que l'objet n'est pas détruit au changement de scène
            // et qu'il est à la racine pour que DontDestroyOnLoad fonctionne correctement.
            if (transform.parent != null)
            {
                transform.SetParent(null);
            }
            DontDestroyOnLoad(gameObject);
        }
        else if (Instance != this)
        {
            Debug.LogWarning($"Instance de {typeof(T).Name} déjà existante. Destruction du duplicata.");
            Destroy(gameObject);
        }
    }
} 

// --- FILE: Scripts/Core/StatsCalculator.cs ---
﻿using System.Collections.Generic;
using ScriptableObjects; 
using UnityEngine; 
using UnityEditor; // Added for Inspector button

/// <summary>
/// Classe statique utilitaire responsable de tous les calculs de statistiques des unités.
/// C'est le point d'entrée unique pour déterminer les stats finales d'une unité.
/// </summary>
public static class StatsCalculator
{
    /// <summary>
    /// Calcule les statistiques finales d'une unité en combinant ses stats de base,
    /// sa progression de niveau et les modificateurs de ses équipements.
    /// </summary>
    /// <param name="character">Les données du personnage (contenant le StatSheet).</param>
    /// <param name="level">Le niveau actuel du personnage.</param>
    /// <param name="equippedItems">La liste des équipements portés par le personnage.</param>
    /// <returns>Un objet RuntimeStats contenant les statistiques finales calculées.</returns>
    public static RuntimeStats GetFinalStats(CharacterData_SO character, int level, List<EquipmentData_SO> equippedItems)
    {
        // --- 1. Validation des entrées ---
        if (character == null || character.Stats == null)
        {
            Debug.LogError("StatsCalculator: CharacterData_SO ou son StatSheet est null. Retour de stats par défaut.");
            return new RuntimeStats(); // Retourne des stats vides pour éviter les erreurs
        }

        var statSheet = character.Stats;
        var finalStats = new RuntimeStats();

        // --- 2. Calcul à partir du StatSheet (Base + Niveau) ---
        // Les stats qui évoluent avec le niveau sont calculées via les AnimationCurves.
        finalStats.MaxHealth = statSheet.BaseHealth + Mathf.RoundToInt(statSheet.HealthCurve.Evaluate(level));
        finalStats.Attack = statSheet.BaseAttack + Mathf.RoundToInt(statSheet.AttackCurve.Evaluate(level));
        finalStats.Defense = statSheet.BaseDefense + Mathf.RoundToInt(statSheet.DefenseCurve.Evaluate(level));

        // Les stats qui sont fixes sont directement copiées depuis le StatSheet.
        finalStats.AttackRange = statSheet.AttackRange;
        finalStats.AttackDelay = statSheet.AttackDelay;
        finalStats.MovementDelay = statSheet.MovementDelay;
        finalStats.DetectionRange = statSheet.DetectionRange;

        // --- 3. Application des modificateurs d'équipement ---
        if (equippedItems != null)
        {
            foreach (var item in equippedItems)
            {
                if (item == null || item.Modifiers == null) continue;

                foreach (var modifier in item.Modifiers)
                {
                    // On utilise un switch pour appliquer le modificateur à la bonne stat.
                    // C'est propre et facile à étendre si vous ajoutez de nouvelles stats.
                    switch (modifier.StatToModify)
                    {
                        case StatType.Health:
                            finalStats.MaxHealth += modifier.Value;
                            break;
                        case StatType.Attack:
                            finalStats.Attack += modifier.Value;
                            break;
                        case StatType.Defense:
                            finalStats.Defense += modifier.Value;
                            break;
                        // Ajoutez d'autres cas ici si vos équipements peuvent modifier d'autres stats.
                    }
                }
            }
        }

        // --- 4. Retourner le résultat ---
        return finalStats;
    }
    
    //lets make the same but for the ennemy units. they dont use the CharacterData_SO but the StatSheet_SO directly.
    public static RuntimeStats GetFinalStats(StatSheet_SO statSheet, int level)
    {
        // --- 1. Validation des entrées ---
        if (statSheet == null)
        {
            Debug.LogError("StatsCalculator: StatSheet_SO est null. Retour de stats par défaut.");
            return new RuntimeStats(); // Retourne des stats vides pour éviter les erreurs
        }

        var finalStats = new RuntimeStats();

        // --- 2. Calcul à partir du StatSheet (Base + Niveau) ---
        finalStats.MaxHealth = statSheet.BaseHealth + Mathf.RoundToInt(statSheet.HealthCurve.Evaluate(level));
        finalStats.Attack = statSheet.BaseAttack + Mathf.RoundToInt(statSheet.AttackCurve.Evaluate(level));
        finalStats.Defense = statSheet.BaseDefense + Mathf.RoundToInt(statSheet.DefenseCurve.Evaluate(level));

        // Les stats qui sont fixes sont directement copiées depuis le StatSheet.
        finalStats.AttackRange = statSheet.AttackRange;
        finalStats.AttackDelay = statSheet.AttackDelay;
        finalStats.MovementDelay = statSheet.MovementDelay;
        finalStats.DetectionRange = statSheet.DetectionRange;

        // --- 3. Retourner le résultat ---
        return finalStats;
    }

    /// <summary>
    /// Logs the stats of a unit for debugging purposes.
    /// </summary>
    /// <param name="stats">The RuntimeStats object to log.</param>
    [ContextMenu("Log Stats")]
    public static void LogStats(RuntimeStats stats)
    {
        if (stats == null)
        {
            Debug.LogError("StatsCalculator: RuntimeStats is null. Cannot log stats.");
            return;
        }

        Debug.Log($"MaxHealth: {stats.MaxHealth}, Attack: {stats.Attack}, Defense: {stats.Defense}, " +
                  $"AttackRange: {stats.AttackRange}, AttackDelay: {stats.AttackDelay}, " +
                  $"MovementDelay: {stats.MovementDelay}, DetectionRange: {stats.DetectionRange}");
    }
}

// --- FILE: Scripts/Core/TeamManager.cs ---
using UnityEngine;
using System.Collections.Generic;
using System;
using System.Linq;
using ScriptableObjects;
// Assure-toi que ce script est dans le bon dossier, par exemple Scripts/Core/
// et qu'il hérite de SingletonPersistent<TeamManager>
public class TeamManager : SingletonPersistent<TeamManager>
{
    // --- Événements Statiques ---
    /// <summary>
    /// Déclenché lorsque l'équipe active du joueur est modifiée.
    /// Fournit la nouvelle liste de CharacterData_SO de l'équipe active.
    /// </summary>
    public static event Action<List<CharacterData_SO>> OnActiveTeamChanged;

    // --- Listes Internes ---
    private List<CharacterData_SO> _availableCharacters = new List<CharacterData_SO>();
    private List<CharacterData_SO> _activeTeam = new List<CharacterData_SO>(new CharacterData_SO[4]); // Initialise avec 4 emplacements nulls

    // --- Propriétés Publiques (Accesseurs) ---
    /// <summary>
    /// Retourne une COPIE de la liste des personnages actuellement débloqués par le joueur.
    /// </summary>
    public List<CharacterData_SO> AvailableCharacters => new List<CharacterData_SO>(_availableCharacters);

    /// <summary>
    /// Retourne une COPIE de la liste des personnages formant l'équipe active (peut contenir des nulls si moins de 4 persos).
    /// </summary>
    public List<CharacterData_SO> ActiveTeam => new List<CharacterData_SO>(_activeTeam);

    // --- Méthodes Unity ---
    protected override void Awake()
    {
        base.Awake(); // Gère le pattern Singleton et DontDestroyOnLoad

        // S'abonner aux événements du PlayerDataManager
        // Ces abonnements se feront même si PlayerDataManager.Instance n'est pas encore prêt,
        // car les events sont statiques. L'invocation se fera au bon moment.
        PlayerDataManager.OnPlayerDataLoaded += HandlePlayerDataLoaded;
        PlayerDataManager.OnCharacterUnlocked += HandleCharacterUnlocked;
        Debug.Log("[TeamManager] Awake complété et abonné aux événements de PlayerDataManager.");
    }

    private void OnDestroy()
    {
        // Toujours se désabonner pour éviter les fuites de mémoire
        PlayerDataManager.OnPlayerDataLoaded -= HandlePlayerDataLoaded;
        PlayerDataManager.OnCharacterUnlocked -= HandleCharacterUnlocked;
        Debug.Log("[TeamManager] OnDestroy appelé et désabonné des événements.");
    }

    // --- Logique d'Initialisation ---

    private void HandlePlayerDataLoaded()
    {
        Debug.Log("[TeamManager] Réception de OnPlayerDataLoaded. Initialisation de l'équipe...");
        if (PlayerDataManager.Instance == null)
        {
            Debug.LogError("[TeamManager] PlayerDataManager.Instance est null lors de HandlePlayerDataLoaded ! Impossible d'initialiser.");
            return;
        }

        // 1. Mettre à jour les personnages disponibles
        _availableCharacters.Clear();
        List<string> unlockedIDs = PlayerDataManager.Instance.GetUnlockedCharacterIDs();
        Debug.Log($"[TeamManager] IDs de personnages débloqués reçus : {string.Join(", ", unlockedIDs)}");

        foreach (string id in unlockedIDs)
        {
            CharacterData_SO character = FindCharacterDataByID(id); // Utilise le chemin Resources
            if (character != null)
            {
                if (!_availableCharacters.Contains(character))
                {
                    _availableCharacters.Add(character);
                }
            }
            else
            {
                Debug.LogWarning($"[TeamManager] CharacterData_SO non trouvé pour l'ID débloqué via Resources : {id}");
            }
        }
        Debug.Log($"[TeamManager] {_availableCharacters.Count} personnages disponibles après chargement.");

        // 2. Mettre à jour l'équipe active
        List<string> activeTeamIDs = PlayerDataManager.Instance.GetActiveTeamIDs();
        Debug.Log($"[TeamManager] IDs d'équipe active reçus : {string.Join(", ", activeTeamIDs)}");

        // Réinitialiser l'équipe active avec potentiellement des nulls
        for(int i = 0; i < _activeTeam.Capacity; i++) _activeTeam[i] = null;


        for (int i = 0; i < activeTeamIDs.Count && i < _activeTeam.Capacity; i++)
        {
            string id = activeTeamIDs[i];
            if (!string.IsNullOrEmpty(id)) // Gérer le cas où un ID pourrait être null/vide
            {
                CharacterData_SO character = FindCharacterDataInList(_availableCharacters, id);
                if (character != null)
                {
                    _activeTeam[i] = character;
                }
                else
                {
                    Debug.LogWarning($"[TeamManager] Personnage '{id}' de l'équipe active non trouvé parmi les personnages disponibles. Sera null dans l'équipe.");
                }
            }
        }

        // S'assurer que la liste _activeTeam a toujours 4 éléments, même si certains sont null
        while(_activeTeam.Count < 4)
        {
            _activeTeam.Add(null);
        }
        if(_activeTeam.Count > 4)
        {
            _activeTeam = _activeTeam.Take(4).ToList();
        }


        Debug.Log($"[TeamManager] Équipe active initialisée : {string.Join(", ", _activeTeam.Select(c => c != null ? c.DisplayName : "NULL"))}");
        OnActiveTeamChanged?.Invoke(new List<CharacterData_SO>(_activeTeam));
    }

    private void HandleCharacterUnlocked(string characterID)
    {
        CharacterData_SO character = FindCharacterDataByID(characterID);
        if (character != null)
        {
            if (!_availableCharacters.Contains(character))
            {
                _availableCharacters.Add(character);
                Debug.Log($"[TeamManager] Personnage '{character.DisplayName}' (ID: {characterID}) ajouté à la liste des disponibles.");
                // Optionnel : Notifier un changement dans les personnages disponibles si l'UI doit se mettre à jour.
                // public static event Action<List<CharacterData_SO>> OnAvailableCharactersChanged;
                // OnAvailableCharactersChanged?.Invoke(new List<CharacterData_SO>(_availableCharacters));
            }
        }
        else
        {
            Debug.LogWarning($"[TeamManager] Tentative de gestion du déblocage pour l'ID '{characterID}', mais CharacterData_SO non trouvé.");
        }
    }

    // --- Gestion de l'Équipe Active ---

    /// <summary>
    /// Définit la nouvelle équipe active du joueur.
    /// </summary>
    /// <param name="newTeamComposition">Liste des CharacterData_SO pour la nouvelle équipe (taille max 4). Les éléments peuvent être null.</param>
    /// <returns>True si l'équipe a été mise à jour, false sinon.</returns>
    public bool SetActiveTeam(List<CharacterData_SO> newTeamComposition)
    {
        if (newTeamComposition == null)
        {
            Debug.LogError("[TeamManager] Tentative de définir une équipe active avec une liste null.");
            return false;
        }
        if (newTeamComposition.Count > 4)
        {
            Debug.LogError($"[TeamManager] Tentative de définir une équipe avec {newTeamComposition.Count} personnages. Maximum autorisé : 4.");
            return false;
        }

        // Valider que tous les personnages de la nouvelle composition sont disponibles
        foreach (CharacterData_SO character in newTeamComposition)
        {
            if (character != null && !_availableCharacters.Contains(character))
            {
                Debug.LogError($"[TeamManager] Personnage '{character.DisplayName}' (ID: {character.CharacterID}) n'est pas dans la liste des personnages disponibles. Impossible de l'ajouter à l'équipe.");
                return false;
            }
        }

        // Mettre à jour _activeTeam. S'assurer qu'elle a toujours 4 éléments.
        _activeTeam.Clear();
        for(int i = 0; i < 4; i++)
        {
            if (i < newTeamComposition.Count)
            {
                _activeTeam.Add(newTeamComposition[i]);
            }
            else
            {
                _activeTeam.Add(null); // Remplir avec null si moins de 4 persos fournis
            }
        }


        Debug.Log($"[TeamManager] Équipe active mise à jour : {string.Join(", ", _activeTeam.Select(c => c != null ? c.DisplayName : "NULL"))}");

        // Sauvegarder les IDs de l'équipe active via PlayerDataManager
        List<string> activeTeamIDs = _activeTeam.Where(c => c != null).Select(c => c.CharacterID).ToList();
        PlayerDataManager.Instance?.SetActiveTeam(activeTeamIDs); // PlayerDataManager gère la sauvegarde

        OnActiveTeamChanged?.Invoke(new List<CharacterData_SO>(_activeTeam)); // Notifier les auditeurs
        return true;
    }

    // --- Méthodes Utilitaires ---

    private CharacterData_SO FindCharacterDataByID(string id)
    {
        // Assure-toi que le chemin correspond à l'emplacement de tes SOs dans le dossier Resources
        CharacterData_SO data = Resources.Load<CharacterData_SO>($"Data/Characters/{id}");
        // Le nom du fichier SO doit correspondre exactement à son CharacterID pour que cela fonctionne.
        // Par exemple, si CharacterID = "CD_Hero", le fichier doit être "CD_Hero.asset".
        if (data == null)
        {
            Debug.LogWarning($"[TeamManager] Impossible de charger CharacterData_SO depuis 'Resources/Data/Characters/{id}'. Vérifiez le chemin et le nom du fichier.");
        }
        return data;
    }

    private CharacterData_SO FindCharacterDataInList(List<CharacterData_SO> list, string id)
    {
        return list.Find(c => c != null && c.CharacterID == id);
    }

    /// <summary>
    /// Vérifie si un personnage spécifique est dans l'équipe active.
    /// </summary>
    public bool IsCharacterInActiveTeam(CharacterData_SO character)
    {
        if (character == null) return false;
        return _activeTeam.Contains(character);
    }

    /// <summary>
    /// Tente d'ajouter un personnage à la première place disponible dans l'équipe active.
    /// </summary>
    /// <returns>True si le personnage a été ajouté, false sinon (équipe pleine ou personnage non dispo).</returns>
    public bool TryAddCharacterToActiveTeam(CharacterData_SO characterToAdd)
    {
        if (characterToAdd == null || !_availableCharacters.Contains(characterToAdd) || IsCharacterInActiveTeam(characterToAdd))
        {
            Debug.LogWarning($"[TeamManager] Impossible d'ajouter '{characterToAdd?.CharacterID}'. Soit non disponible, soit déjà dans l'équipe.");
            return false;
        }

        for (int i = 0; i < _activeTeam.Count; i++)
        {
            if (_activeTeam[i] == null)
            {
                List<CharacterData_SO> tempTeam = new List<CharacterData_SO>(_activeTeam);
                tempTeam[i] = characterToAdd;
                return SetActiveTeam(tempTeam); // Utilise SetActiveTeam pour la validation et la sauvegarde
            }
        }
        Debug.LogWarning("[TeamManager] Impossible d'ajouter le personnage, l'équipe active est pleine.");
        return false;
    }

    /// <summary>
    /// Tente de retirer un personnage de l'équipe active.
    /// </summary>
    public bool TryRemoveCharacterFromActiveTeam(CharacterData_SO characterToRemove)
    {
        if (characterToRemove == null || !IsCharacterInActiveTeam(characterToRemove))
        {
            Debug.LogWarning($"[TeamManager] Impossible de retirer '{characterToRemove?.CharacterID}'. Personnage non trouvé dans l'équipe active.");
            return false;
        }

        List<CharacterData_SO> tempTeam = new List<CharacterData_SO>(_activeTeam);
        int index = tempTeam.IndexOf(characterToRemove);
        if (index != -1)
        {
            tempTeam[index] = null; // Laisser un slot vide
            return SetActiveTeam(tempTeam); // Utilise SetActiveTeam pour la validation et la sauvegarde
        }
        return false;
    }
}

// --- FILE: Scripts/Debug/DebugLevelLoader.cs ---
﻿using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using TMPro;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using ScriptableObjects;

#if UNITY_EDITOR
using UnityEditor;
#endif

public class DebugLevelLoader : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private Transform levelButtonsContainer;
    [SerializeField] private GameObject levelButtonPrefab;
    [SerializeField] private ScrollRect scrollView;
    
    [Header("Info Panel")]
    [SerializeField] private TextMeshProUGUI levelCountText;
    [SerializeField] private TextMeshProUGUI selectedLevelInfoText;
    
    [Header("Configuration")]
    [SerializeField] private string coreSceneName = "Core";
    
    private List<LevelData_SO> discoveredLevels = new List<LevelData_SO>();
    private LevelData_SO selectedLevel = null;

    void Start()
    {
        Debug.Log("[DebugLevelLoader] Initialisation du Debug Level Loader");
        DiscoverLevels();
        CreateLevelButtons();
        UpdateInfoPanel();
    }

    void DiscoverLevels()
    {
        discoveredLevels.Clear();

#if UNITY_EDITOR
        string[] guids = AssetDatabase.FindAssets("t:LevelData_SO");
        
        foreach (string guid in guids)
        {
            string assetPath = AssetDatabase.GUIDToAssetPath(guid);
            LevelData_SO levelData = AssetDatabase.LoadAssetAtPath<LevelData_SO>(assetPath);
            
            if (levelData != null && levelData.TypeOfLevel == LevelType.GameplayLevel)
            {
                discoveredLevels.Add(levelData);
            }
        }
        
        Debug.Log($"[DebugLevelLoader] Découverte via AssetDatabase : {discoveredLevels.Count} niveaux de gameplay trouvés");
#else
        LevelData_SO[] allLevels = Resources.LoadAll<LevelData_SO>("Data/Levels");
        discoveredLevels = allLevels.Where(level => level.TypeOfLevel == LevelType.GameplayLevel).ToList();
        
        Debug.Log($"[DebugLevelLoader] Découverte via Resources : {discoveredLevels.Count} niveaux de gameplay trouvés");
#endif

        discoveredLevels = discoveredLevels.OrderBy(level => level.DisplayName).ToList();
    }

    void CreateLevelButtons()
    {
        if (levelButtonsContainer == null || levelButtonPrefab == null)
        {
            Debug.LogError("[DebugLevelLoader] Références UI manquantes pour la création des boutons");
            return;
        }

        // Nettoyer les boutons existants
        foreach (Transform child in levelButtonsContainer)
        {
            Destroy(child.gameObject);
        }

        // Créer un bouton pour chaque niveau
        foreach (LevelData_SO levelData in discoveredLevels)
        {
            GameObject buttonObj = Instantiate(levelButtonPrefab, levelButtonsContainer);
            
            // Configurer le texte du bouton
            TextMeshProUGUI buttonText = buttonObj.GetComponentInChildren<TextMeshProUGUI>();
            if (buttonText != null)
            {
                buttonText.text = $"{levelData.DisplayName}\n<size=70%><color=#888888>({levelData.LevelID})</color></size>";
            }

            // Configurer l'action du bouton
            Button button = buttonObj.GetComponent<Button>();
            if (button != null)
            {
                LevelData_SO capturedLevelData = levelData;
                button.onClick.AddListener(() => OnLevelButtonClicked(capturedLevelData));
            }

            // Optionnel : coloration différente selon la difficulté
            Image buttonImage = buttonObj.GetComponent<Image>();
            if (buttonImage != null)
            {
                buttonImage.color = GetDifficultyColor(levelData.Difficulty);
            }
        }
    }

    Color GetDifficultyColor(int difficulty)
    {
        switch (difficulty)
        {
            case 1: return new Color(0.7f, 1f, 0.7f, 1f);     // Vert clair (Facile)
            case 2: return new Color(1f, 1f, 0.7f, 1f);       // Jaune clair (Normal)
            case 3: return new Color(1f, 0.8f, 0.6f, 1f);     // Orange clair (Difficile)
            case 4: return new Color(1f, 0.7f, 0.7f, 1f);     // Rouge clair (Très difficile)
            case 5: return new Color(1f, 0.6f, 1f, 1f);       // Magenta clair (Extrême)
            default: return Color.white;
        }
    }

    void OnLevelButtonClicked(LevelData_SO levelData)
    {
        selectedLevel = levelData;
        UpdateSelectedLevelInfo();
        
        Debug.Log($"[DebugLevelLoader] Niveau sélectionné : {levelData.DisplayName}");
        
        // Démarrer la coroutine pour charger Core puis le niveau
    }

    /// <summary>
    /// Coroutine qui charge d'abord Core, attend que GameManager soit prêt, puis lance le niveau
    /// </summary>
    IEnumerator LoadCoreAndLevel()
    {
        if (selectedLevel == null)
        {
            Debug.LogWarning("[DebugLevelLoader] Aucun niveau sélectionné pour le lancement");
            yield break;
        }

        Debug.Log($"[DebugLevelLoader] Étape 1: Chargement de la scène {coreSceneName}...");
        // ✅ SOLUTION ROBUSTE : Utiliser PlayerPrefs pour persister l'info
        Debug.Log($"[DebugLevelLoader] Étape 1: Signalement du mode debug via PlayerPrefs...");
        PlayerPrefs.SetInt("DebugMode_LaunchedFromDebug", 1);
        PlayerPrefs.SetString("DebugMode_SelectedLevel", selectedLevel.LevelID);
        PlayerPrefs.Save(); 
        // 1. Charger la scène Core
        AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(coreSceneName);
        
        // Attendre que le chargement soit terminé
        while (!asyncLoad.isDone)
        {
            yield return null;
        }
        
        Debug.Log($"[DebugLevelLoader] Scène {coreSceneName} chargée, attente de GameManager...");
        
        // 2. Attendre que GameManager soit initialisé
        float timeout = 5f; // Timeout de sécurité
        float timeWaited = 0f;
        
        while (GameManager.Instance == null && timeWaited < timeout)
        {
            yield return new WaitForFixedUpdate(); // Attendre un frame
            timeWaited += Time.fixedDeltaTime;
        }
        
        // 3. Vérifier si GameManager est prêt
        if (GameManager.Instance == null)
        {
            Debug.LogError("[DebugLevelLoader] Timeout: GameManager.Instance toujours null après chargement de Core !");
            yield break;
        }
        
        Debug.Log("[DebugLevelLoader] GameManager trouvé ! Application des options de debug...");
        
        // 4. Appliquer les options de debug
        ApplyDebugOptions();
        
        // 5. Assigner le niveau à charger
        GameManager.Instance.LoadLevel(selectedLevel);
        Debug.Log($"[DebugLevelLoader] GameManager.CurrentLevelToLoad assigné à : {selectedLevel.DisplayName}");
        
        // 6. Lancer le niveau via GameManager
        Debug.Log($"[DebugLevelLoader] Lancement du niveau via GameManager.LoadLevel()");
        GameManager.Instance.LoadLevel(selectedLevel);
    }

    void ApplyDebugOptions()
    {
        // Pour l'instant, pas d'options de debug (vous les ajouterez plus tard)
        DebugManager.InfiniteGold = false;
        DebugManager.Invincibility = false;
        DebugManager.SkipIntro = false;
        DebugManager.FastBeat = false;

        Debug.Log($"[DebugLevelLoader] Options de debug appliquées - " +
                  $"Or Infini: {DebugManager.InfiniteGold}, " +
                  $"Invincibilité: {DebugManager.Invincibility}, " +
                  $"Skip Intro: {DebugManager.SkipIntro}, " +
                  $"Beat Rapide: {DebugManager.FastBeat}");
    }

    void UpdateInfoPanel()
    {
        if (levelCountText != null)
        {
            levelCountText.text = $"Niveaux disponibles : {discoveredLevels.Count}";
        }
    }

    void UpdateSelectedLevelInfo()
    {
        if (selectedLevelInfoText == null || selectedLevel == null) return;

        string info = $"<b>{selectedLevel.DisplayName}</b>\n" +
                      $"ID: {selectedLevel.LevelID}\n" +
                      $"Scène: {selectedLevel.SceneName}\n" +
                      $"Difficulté: {selectedLevel.Difficulty}/5\n" +
                      $"BPM: {selectedLevel.RhythmBPM}\n" +
                      $"XP Récompense: {selectedLevel.ExperienceReward}\n" +
                      $"Or Récompense: {selectedLevel.CurrencyReward}\n\n" +
                      $"<i>{selectedLevel.Description}</i>";

        selectedLevelInfoText.text = info;
        LaunchLevel();
    }
    void LaunchLevel()
    {
        if (selectedLevel == null)
        {
            Debug.LogError("[DebugLevelLoader] Aucun niveau sélectionné pour le lancement !");
            return;
        }

        // 1. Sauvegarder les informations pour que GameManager puisse les lire
        PlayerPrefs.SetInt("DebugMode_LaunchedFromDebug", 1);
        PlayerPrefs.SetString("DebugMode_SelectedLevelID", selectedLevel.LevelID); // On sauvegarde l'ID
    
        // Appliquer les autres options de debug si vous en avez
        // PlayerPrefs.SetInt("DebugMode_InfiniteGold", infiniteGoldToggle.isOn ? 1 : 0);
    
        PlayerPrefs.Save(); 
    
        // 2. Charger la scène Core. Le travail de ce script est terminé.
        SceneManager.LoadScene(coreSceneName);
    }

    public void RefreshLevelList()
    {
        DiscoverLevels();
        CreateLevelButtons();
        UpdateInfoPanel();
        selectedLevel = null;
        if (selectedLevelInfoText != null) selectedLevelInfoText.text = "Aucun niveau sélectionné";
    }
}

/// <summary>
/// Classe statique pour stocker les options de debug
/// </summary>
public static class DebugManager
{
    public static bool InfiniteGold { get; set; } = false;
    public static bool Invincibility { get; set; } = false;
    public static bool SkipIntro { get; set; } = false;
    public static bool FastBeat { get; set; } = false;

    public static void ResetAllFlags()
    {
        InfiniteGold = false;
        Invincibility = false;
        SkipIntro = false;
        FastBeat = false;
    }

    public static void LogCurrentState()
    {
        Debug.Log($"[DebugManager] État actuel - " +
                  $"Or Infini: {InfiniteGold}, " +
                  $"Invincibilité: {Invincibility}, " +
                  $"Skip Intro: {SkipIntro}, " +
                  $"Beat Rapide: {FastBeat}");
    }
}

// --- FILE: Scripts/Environment/Environment.cs ---
using UnityEngine;
using System.Collections;
using Sirenix.OdinInspector; // Si vous utilisez Odin Inspector
using ScriptableObjects;

public class Environment : MonoBehaviour
{
    [Header("Environment Settings")]
    [SerializeField] private bool _isBlocking = false;
    [SerializeField] private float yOffset = 0f; // Décalage vertical pour le positionnement
    [SerializeField] private string environmentName = "Generic Environment";
    [Tooltip("Description of this environment piece")]
    [TextArea(3, 5)]
    [SerializeField] private string description;

    [Header("Visual Settings")]
    [SerializeField] private bool useRandomRotation = false;
    [ShowIf("useRandomRotation")] // Attribut Odin Inspector, optionnel
    [SerializeField] private Vector3 randomRotationRange = new Vector3(0, 360, 0);

    // Référence à la tuile occupée
    protected Tile occupiedTile;
    protected bool isAttached = false;

    // Référence aux statistiques (si l'environnement a des propriétés spéciales)
    [InlineEditor(InlineEditorModes.FullEditor)] // Attribut Odin Inspector
    [SerializeField] private EnvironmentStats environmentStats;

    // --- Propriétés Publiques ---
    public bool IsBlocking => _isBlocking;
    public string EnvironmentName => environmentName;
    public string Description => description;
    public EnvironmentStats Stats => environmentStats;

    protected virtual IEnumerator Start()
    {
        // Attendre que HexGridManager soit prêt
        while (HexGridManager.Instance == null)
        {
            yield return new WaitForSeconds(0.1f);
        }

        // Tenter de s'attacher à la tuile la plus proche
        while (!isAttached)
        {
            Tile nearestTile = HexGridManager.Instance.GetClosestTile(transform.position);
            if (nearestTile != null)
            {
                bool tileAvailableForEnvironment = true;
                Vector2Int nearestTilePos = new Vector2Int(nearestTile.column, nearestTile.row);

                // 1. Vérifier si la tuile est physiquement occupée par un bâtiment ou une unité
                if (nearestTile.currentBuilding != null)
                {
                    Debug.LogWarning($"[ENVIRONMENT:{name}] Cannot attach to tile ({nearestTilePos.x},{nearestTilePos.y}), it already has building: {nearestTile.currentBuilding.name}");
                    tileAvailableForEnvironment = false;
                }
                else if (nearestTile.currentUnit != null)
                {
                    Debug.LogWarning($"[ENVIRONMENT:{name}] Cannot attach to tile ({nearestTilePos.x},{nearestTilePos.y}), it already has unit: {nearestTile.currentUnit.name}");
                    tileAvailableForEnvironment = false;
                }
                // 2. Vérifier si la tuile est réservée par une unité via le TileReservationController
                //    (On ne veut pas placer un environnement, surtout bloquant, où une unité prévoit d'aller)
                else if (TileReservationController.Instance != null && TileReservationController.Instance.IsTileReserved(nearestTilePos))
                {
                    Unit reservingUnit = TileReservationController.Instance.GetReservingUnit(nearestTilePos);
                    Debug.LogWarning($"[ENVIRONMENT:{name}] Cannot attach to tile ({nearestTilePos.x},{nearestTilePos.y}), tile is reserved by unit: {reservingUnit?.name ?? "Unknown Unit"}");
                    tileAvailableForEnvironment = false;
                }
                // 3. (Optionnel) Ajouter d'autres conditions, par ex. si l'environnement ne peut être placé que sur certains TileType
                // else if (nearestTile.tileType != TileType.Ground && _isBlocking)
                // {
                //     Debug.LogWarning($"[ENVIRONMENT:{name}] Blocking environment cannot be placed on non-Ground tile ({nearestTilePos.x},{nearestTilePos.y}).");
                //     tileAvailableForEnvironment = false;
                // }


                if (tileAvailableForEnvironment)
                {
                    AttachToTile(nearestTile); // S'attache et notifie la tuile
                    isAttached = true;
                    // Si cet environnement est _isBlocking, la propriété Tile.IsOccupied deviendra true
                    // via Tile.currentEnvironment.IsBlocking. Cela empêchera les unités de la réserver/occuper.
                    break;
                }
                else
                {
                    // La tuile la plus proche n'est pas disponible.
                    // Selon la logique de votre jeu, vous pourriez :
                    // - Détruire cet environnement.
                    // - Le marquer comme "non placé" et le cacher.
                    // - Essayer une autre tuile (nécessiterait une logique de recherche plus complexe).
                    Debug.LogError($"[ENVIRONMENT:{name}] Failed to find a suitable initial tile for attachment near {transform.position}. Environment will not be placed correctly.");
                    // Pour éviter une boucle infinie si mal placé dans l'éditeur :
                    yield return new WaitForSeconds(5f); // Attendre plus longtemps avant de réessayer ou de logguer à nouveau
                }
            }
            yield return new WaitForSeconds(0.2f); // Attendre avant de réessayer si nearestTile était null
        }

        // Appliquer une rotation aléatoire si configuré
        if (useRandomRotation && isAttached)
        {
            ApplyRandomRotation();
        }
    }

    protected void AttachToTile(Tile tile)
    {
        occupiedTile = tile;

        // Se positionner correctement sur la tuile
        transform.position = tile.transform.position + new Vector3(0f, yOffset, 0f);
        transform.SetParent(tile.transform, false); // 'false' pour position locale relative au parent
        transform.localPosition = new Vector3(0f, yOffset, 0f); // Assurer la position locale correcte

        // Notifier la tuile qu'elle a maintenant cet environnement
        AssignToTile(tile);
    }

    // Méthode virtuelle pour que les classes dérivées puissent surcharger si besoin,
    // mais la logique principale est dans Tile.AssignEnvironment
    protected virtual void AssignToTile(Tile tile)
    {
        tile.AssignEnvironment(this);
    }

    protected void ApplyRandomRotation()
    {
        Vector3 randomRot = new Vector3(
            Random.Range(-randomRotationRange.x, randomRotationRange.x),
            Random.Range(-randomRotationRange.y, randomRotationRange.y),
            Random.Range(-randomRotationRange.z, randomRotationRange.z)
        );
        transform.localRotation = Quaternion.Euler(randomRot);
    }

    public virtual void OnDestroy()
    {
        // Lorsque l'environnement est détruit, notifier la tuile pour qu'elle se libère
        if (occupiedTile != null)
        {
            occupiedTile.RemoveEnvironment(); // La tuile mettra son currentEnvironment à null
        }
    }

    public Tile GetOccupiedTile()
    {
        return occupiedTile;
    }

    // Permet de changer dynamiquement si l'environnement bloque le passage
    public void SetBlocking(bool isBlocking)
    {
        if (_isBlocking != isBlocking)
        {
            _isBlocking = isBlocking;
            // Si la tuile existe, notifier qu'elle a peut-être changé d'état d'occupation
            // (Tile.IsOccupied dépendra de _isBlocking)
            occupiedTile?.NotifyManagerOfStateChange();
        }
    }
}

// --- FILE: Scripts/Environment/MusicReactiveEnvironment.cs ---
using UnityEngine;
using System.Collections;
using Sirenix.OdinInspector;

public enum EnvironmentAnimationType
{
    Stretch,
    Bounce,
    BounceTileReactive
}

public class MusicReactiveEnvironment : Environment
{
    [Title("Music Reaction Settings")]
    [SerializeField, Range(0f, 1f)]
    protected float reactionProbability = 0.65f;

    [SerializeField]
    protected bool reactToBeat = true;

    [SerializeField]
    protected EnvironmentAnimationType animationType = EnvironmentAnimationType.Stretch;

    [Title("Stretch Animation Settings")]
    [ShowIf("IsStretchAnimation")]
    [SerializeField]
    protected bool useStretchAnimation = true;

    [ShowIf("@this.IsStretchAnimation() && this.useStretchAnimation")]
    [SerializeField, LabelText("Stretch Axis")]
    protected Vector3 stretchAxis = new Vector3(1, 1, 1);

    [ShowIf("@this.IsStretchAnimation() && this.useStretchAnimation")]
    [SerializeField, Range(0.5f, 2f), LabelText("Stretch Intensity")]
    protected float stretchIntensity = 1.2f;

    [ShowIf("@this.IsStretchAnimation() && this.useStretchAnimation")]
    [SerializeField, LabelText("Start Stretched")]
    protected bool startStretched = false;

    [ShowIf("@this.IsStretchAnimation() && this.useStretchAnimation")]
    [SerializeField, LabelText("Two Beat Cycle")]
    protected bool twoBeatCycle = false;

    [ShowIf("@this.IsStretchAnimation() && this.useStretchAnimation")]
    [SerializeField, LabelText("Use Natural Rebound")]
    protected bool useNaturalRebound = true;

    [ShowIf("@this.IsStretchAnimation() && this.useStretchAnimation && this.useNaturalRebound")]
    [SerializeField, Range(0.05f, 0.5f), LabelText("Rebound Amount")]
    protected float reboundAmount = 0.2f;

    [Title("Bounce Animation Settings")]
    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, Range(0.1f, 3f), LabelText("Bounce Height")]
    protected float bounceHeight = 0.5f;

    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, Range(0f, 45f), LabelText("Max Bounce Rotation")]
    protected float maxBounceRotation = 15f;

    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, LabelText("Rotation Axis")]
    protected Vector3 rotationAxis = new Vector3(1, 0, 0); // Default to x-axis rotation

    [ShowIf("IsBounceAnimation")]
    [SerializeField, LabelText("Two Beat Cycle")]
    protected bool twoBeatBounce = true;

    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, LabelText("Bounce Curve")]
    protected AnimationCurve bounceCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, LabelText("Squash On Land")]
    protected bool squashOnLand = true;

    [ShowIf("@(this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()) && this.squashOnLand")]
    [SerializeField, Range(0.5f, 1f), LabelText("Squash Factor")]
    protected float squashFactor = 0.8f;

    [Title("Tile Reactive Settings")]
    [ShowIf("IsBounceTileReactiveAnimation")]
    [SerializeField, Range(0.0001f, 0.5f), LabelText("Minimum Tile Movement Threshold")]
    protected float tileMovementThreshold = 0.0001f;

    [ShowIf("IsBounceTileReactiveAnimation")]
    [SerializeField, LabelText("React To Tile Upward Movement")]
    protected bool reactToTileUpMovement = true;

    [ShowIf("IsBounceTileReactiveAnimation")]
    [SerializeField, LabelText("React To Tile Downward Movement")]
    protected bool reactToTileDownMovement = false;

    [ShowIf("IsBounceTileReactiveAnimation")]
    [SerializeField, Range(0.2f, 2f), LabelText("Animation Duration")]
    protected float tileReactiveAnimationDuration = 0.4f;

    [ShowIf("IsBounceTileReactiveAnimation")]
    [SerializeField, LabelText("Always Debug Tile Movement")]
    protected bool alwaysDebugTileMovement = false;

    [Title("Organic Movement Settings")]
    [ShowIf("@this.IsBounceTileReactiveAnimation()")]
    [SerializeField, Range(0f, 1f), LabelText("Axis Variation")]
    protected float axisVariation = 0.5f;

    [ShowIf("@this.IsBounceTileReactiveAnimation()")]
    [SerializeField, Range(0f, 1f), LabelText("Height Variation Per Bounce")]
    protected float heightVariationPerBounce = 0.2f;

    [ShowIf("@this.IsBounceTileReactiveAnimation()")]
    [SerializeField, Range(0f, 1f), LabelText("Rotation Variation")]
    protected float rotationVariation = 0.3f;

    [ShowIf("@this.IsBounceTileReactiveAnimation()")]
    [SerializeField, Range(0f, 1f), LabelText("Timing Variation")]
    protected float timingVariation = 0.15f;

    [ShowIf("@this.IsBounceTileReactiveAnimation()")]
    [SerializeField, Range(0.1f, 1f), LabelText("Path Wobble")]
    protected float pathWobble = 0.2f;

    [SerializeField, Range(0.1f, 2f), LabelText("Animation Duration")]
    protected float animationDuration = 0.5f;

    [SerializeField, LabelText("Animation Curve")]
    protected AnimationCurve animationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

    [SerializeField, Range(0.1f, 0.9f), LabelText("Pre-Beat Fraction")]
    protected float preBeatFraction = 0.3f;

    [SerializeField, Range(0f, 0.5f), LabelText("Randomness")]
    protected float animationRandomness = 0.1f;

    [SerializeField, LabelText("Varied Animation Per Object")]
    protected bool varyAnimationPerObject = true;

    [Title("Debug Settings")]
    [SerializeField]
    protected bool debugReactions = false;

    // Private variables
    protected Coroutine currentAnimation;
    protected bool isAnimating = false;
    protected Vector3 originalScale;
    protected Vector3 originalPosition;
    protected Quaternion originalRotation;
    protected bool isInitialized = false;
    protected Vector3 lastTilePosition;
    protected float objectVariationFactor; // Unique variation factor per object for more natural forest look
    protected Vector3 originalWorldPosition; // Original world position (needed for reference)

    // Organic variation variables
    protected Vector3 uniqueRotationAxis;
    protected float uniqueObjectID;
    protected float lastBounceTime;
    protected int bounceCounter = 0;

    // Tile reactive variables
    protected bool isWaitingForTileDown = false;
    protected float lastSignificantTileMovement = 0f;
    protected bool hasTileMovedUp = false;

    // Frame counters for debugging
    protected int framesWithoutMovement = 0;

    protected override IEnumerator Start()
    {
        // Call the base Environment Start method which handles attachment to a tile
        yield return StartCoroutine(base.Start());

        // Store the original world position
        if (occupiedTile != null)
        {
            originalWorldPosition = occupiedTile.transform.position;
        }
        else
        {
            originalWorldPosition = transform.position;
        }

        // Initialize after we've attached to a tile
        InitializeReactiveState();

        // Subscribe to beat events
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat += HandleBeat;
            MusicManager.Instance.OnMusicStateChanged += HandleMusicStateChange;
        }
        else
        {
            Debug.LogWarning($"[REACTIVE ENVIRONMENT] {gameObject.name} couldn't find MusicManager!");
        }

        // Log initial state if debugging is enabled
        if (debugReactions && animationType == EnvironmentAnimationType.BounceTileReactive)
        {
            Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} initialized as BounceTileReactive. " +
                       $"Threshold: {tileMovementThreshold}, " +
                       $"React to up: {reactToTileUpMovement}, " +
                       $"Tile position: {lastTilePosition}");
        }
    }

    protected void InitializeReactiveState()
    {
        if (!isInitialized)
        {
            // Store original transform values (before any animation)
            originalScale = transform.localScale;
            originalPosition = transform.localPosition;
            originalRotation = transform.localRotation;

            // Generate a unique variation factor for this object if enabled
            if (varyAnimationPerObject)
            {
                // This creates a value between 0.8 and 1.2 that's unique to this object
                objectVariationFactor = Random.Range(0.8f, 1.2f);

                // Create a unique object ID based on position (for consistent randomization)
                uniqueObjectID = transform.position.x * 1000 + transform.position.y * 100 + transform.position.z * 10;

                // Generate a unique rotation axis with variation from the main axis
                float axisRandomizer = uniqueObjectID * 0.1f % 1.0f;

                // Create a unique but stable rotation axis that's different for each object
                uniqueRotationAxis = new Vector3(
                    rotationAxis.x + Random.Range(-0.3f, 0.3f) * axisVariation,
                    rotationAxis.y + Random.Range(-0.3f, 0.3f) * axisVariation,
                    rotationAxis.z + Random.Range(-0.3f, 0.3f) * axisVariation
                ).normalized;
            }
            else
            {
                objectVariationFactor = 1.0f;
                uniqueObjectID = 0;
                uniqueRotationAxis = rotationAxis.normalized;
            }

            // Initialize bounce counter
            bounceCounter = 0;
            lastBounceTime = Time.time;

            // Store the initial tile position if we're attached to a tile
            if (occupiedTile != null)
            {
                lastTilePosition = occupiedTile.transform.position;
            }

            // Apply stretched state if configured to start stretched and using stretch animation
            if (animationType == EnvironmentAnimationType.Stretch && startStretched && useStretchAnimation)
            {
                // Normalize stretch axis to use as a multiplier
                Vector3 normalizedStretchAxis = stretchAxis.normalized;

                // Create the stretched scale by applying the stretch intensity along the selected axis
                Vector3 stretchedScale = new Vector3(
                    originalScale.x * (1 + (normalizedStretchAxis.x * (stretchIntensity - 1))),
                    originalScale.y * (1 + (normalizedStretchAxis.y * (stretchIntensity - 1))),
                    originalScale.z * (1 + (normalizedStretchAxis.z * (stretchIntensity - 1)))
                );

                // Apply the stretched scale
                transform.localScale = stretchedScale;

                if (debugReactions)
                {
                    Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} initialized in stretched state");
                }
            }

            // Initialize tile reactive variables
            isWaitingForTileDown = false;
            hasTileMovedUp = false;
            framesWithoutMovement = 0;

            isInitialized = true;

            if (debugReactions)
            {
                Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} initialized with variation factor: {objectVariationFactor}");
            }
        }
    }

    protected virtual void Update()
    {
        // If we're attached to a tile, follow its vertical movement
        if (occupiedTile != null && isInitialized)
        {
            Vector3 currentTilePosition = occupiedTile.transform.position;

            // Check if the tile has moved vertically
            if (currentTilePosition.y != lastTilePosition.y)
            {
                framesWithoutMovement = 0;

                // Calculate the change in height
                float deltaY = currentTilePosition.y - lastTilePosition.y;

                // Debug logging for tile movement
                if (debugReactions && animationType == EnvironmentAnimationType.BounceTileReactive &&
                    (Mathf.Abs(deltaY) > 0.001f || alwaysDebugTileMovement))
                {
                    Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} detected tile movement: deltaY={deltaY}, " +
                             $"threshold={tileMovementThreshold}, isAnimating={isAnimating}, " +
                             $"waitingForDown={isWaitingForTileDown}");
                }

                // For BounceTileReactive animation type, check if we should trigger animations
                if (animationType == EnvironmentAnimationType.BounceTileReactive && !isAnimating)
                {
                    // Detect significant upward movement to trigger bounce
                    if (reactToTileUpMovement && deltaY > tileMovementThreshold)
                    {
                        if (debugReactions)
                        {
                            Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} detected SIGNIFICANT upward tile movement: {deltaY}, triggering animation!");
                        }

                        // Only react if we're not waiting for the tile to go down
                        if (!isWaitingForTileDown)
                        {
                            // Increment bounce counter for variation
                            bounceCounter++;
                            lastBounceTime = Time.time;

                            // Trigger the bounce animation
                            if (currentAnimation != null)
                            {
                                StopCoroutine(currentAnimation);
                            }

                            currentAnimation = StartCoroutine(AnimateTileReactiveBounce(tileReactiveAnimationDuration, deltaY));
                            hasTileMovedUp = true;
                            isWaitingForTileDown = true;
                        }
                    }
                    // Detect when the tile has moved back down to reset - ONLY if not animating
                    else if (reactToTileDownMovement && deltaY < -tileMovementThreshold && !isAnimating)
                    {
                        if (debugReactions)
                        {
                            Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} detected significant downward tile movement: {deltaY}");
                        }

                        // Only trigger if the tile has moved down after moving up
                        if (isWaitingForTileDown && hasTileMovedUp)
                        {
                            // The tile has returned to its down position, reset the flag
                            isWaitingForTileDown = false;
                            hasTileMovedUp = false;
                        }
                    }

                    // If we detect the tile has returned to a stable position near original
                    // and we were waiting for it, reset the waiting flag - ONLY if not animating
                    if (isWaitingForTileDown && !isAnimating && 
                        Mathf.Abs(currentTilePosition.y - originalWorldPosition.y) < tileMovementThreshold * 0.5f)
                    {
                        isWaitingForTileDown = false;
                        hasTileMovedUp = false;

                        if (debugReactions)
                        {
                            Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} tile has returned to near-original position, resetting flags");
                        }
                    }
                }

                // IMPORTANT: For non-tile reactive animations OR when not actively animating,
                // update position to maintain relative height
                if (animationType != EnvironmentAnimationType.BounceTileReactive || !isAnimating)
                {
                    // Update our local position to maintain the same relative height
                    transform.localPosition = new Vector3(
                        originalPosition.x,
                        originalPosition.y,
                        originalPosition.z
                    );
                }

                // Update the stored tile position
                lastTilePosition = currentTilePosition;
            }
            else
            {
                // No movement detected
                framesWithoutMovement++;

                // If we've seen no movement for a while and we're in a waiting state, reset the flags
                // ONLY if not currently animating and increase the timeout to avoid interfering with animations
                if (framesWithoutMovement > 120 && isWaitingForTileDown && !isAnimating &&
                    animationType == EnvironmentAnimationType.BounceTileReactive)
                {
                    isWaitingForTileDown = false;
                    hasTileMovedUp = false;

                    if (debugReactions)
                    {
                        Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} no movement for 120 frames and not animating, resetting flags");
                    }
                }
            }
        }
    }

    protected virtual void HandleBeat(float beatDuration)
    {
        if (!isInitialized || !reactToBeat)
        {
            return;
        }

        // Skip direct beat reaction for BounceTileReactive type
        if (animationType == EnvironmentAnimationType.BounceTileReactive)
        {
            return;
        }

        // Apply probability check
        if (Random.value > reactionProbability)
        {
            return;
        }

        // For bounce animations, only interrupt if we're not in a critical phase
        if (currentAnimation != null && isAnimating)
        {
            if (animationType == EnvironmentAnimationType.Bounce)
            {
                // For bounce animations, check if we should allow completion
                // Don't interrupt if we're in a two-beat cycle and still in the first beat
                if (twoBeatBounce)
                {
                    // Let two-beat bounces complete their cycle
                    if (debugReactions)
                    {
                        Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} skipping beat - two-beat bounce in progress");
                    }
                    return;
                }
                else
                {
                    // For one-beat bounces, only interrupt if the animation has been running for a reasonable time
                    // This prevents rapid fire interruptions
                    float minAnimationTime = beatDuration * 0.3f; // Allow at least 30% of beat duration
                    if (Time.time - lastBounceTime < minAnimationTime)
                    {
                        if (debugReactions)
                        {
                            Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} skipping beat - recent bounce still in progress");
                        }
                        return;
                    }
                }
            }
            
            // Safe to stop the current animation
            StopCoroutine(currentAnimation);
            isAnimating = false;
            currentAnimation = null;
        }

        // Choose animation based on selected type
        switch (animationType)
        {
            case EnvironmentAnimationType.Stretch:
                if (useStretchAnimation)
                {
                    currentAnimation = StartCoroutine(AnimateStretch(beatDuration));
                }
                break;

            case EnvironmentAnimationType.Bounce:
                // Update the last bounce time when starting a new bounce
                lastBounceTime = Time.time;
                currentAnimation = StartCoroutine(AnimateBounce(beatDuration));
                break;
        }
    }

    protected virtual IEnumerator AnimateStretch(float beatDuration)
    {
        isAnimating = true;

        // Get current scale as starting point (in case we're already stretched)
        Vector3 currentScale = transform.localScale;

        // Normalize stretch axis to use as a multiplier
        Vector3 normalizedStretchAxis = stretchAxis.normalized;

        // Add slight randomness to the stretch intensity for organic feel
        // Also apply the object's unique variation factor
        float effectiveIntensity = stretchIntensity * objectVariationFactor;
        float randomizedIntensity = effectiveIntensity * Random.Range(1f - animationRandomness, 1f + animationRandomness);

        // Create the target scale by applying the stretch intensity along the selected axis
        Vector3 stretchedScale = new Vector3(
            originalScale.x * (1 + (normalizedStretchAxis.x * (randomizedIntensity - 1))),
            originalScale.y * (1 + (normalizedStretchAxis.y * (randomizedIntensity - 1))),
            originalScale.z * (1 + (normalizedStretchAxis.z * (randomizedIntensity - 1)))
        );

        // If using natural rebound, prepare an "overshoot" scale
        Vector3 reboundScale = originalScale;
        if (useNaturalRebound)
        {
            // For rebound, we need to go slightly past the target in the opposite direction
            // i.e., if we're stretching up, we'll slightly compress after
            float reboundFactor = 1f - (reboundAmount * Random.Range(0.7f, 1.3f));
            reboundScale = new Vector3(
                originalScale.x * (1 + (normalizedStretchAxis.x * (1f - reboundFactor))),
                originalScale.y * (1 + (normalizedStretchAxis.y * (1f - reboundFactor))),
                originalScale.z * (1 + (normalizedStretchAxis.z * (1f - reboundFactor)))
            );
        }

        // Determine if we're going from stretched to normal or vice versa
        bool isCurrentlyStretched = Vector3.Distance(currentScale, stretchedScale) < Vector3.Distance(currentScale, originalScale);

        // Set the source and target scales based on current state
        Vector3 sourceScale = isCurrentlyStretched ? stretchedScale : originalScale;
        Vector3 targetScale = isCurrentlyStretched ? originalScale : stretchedScale;

        // Add small random offset to the animation timing for less mechanical feel
        float randomTimeOffset = beatDuration * Random.Range(-animationRandomness * 0.3f, animationRandomness * 0.3f);

        // Get next beat time for animation timing
        float nextBeatTime = MusicManager.Instance.GetNextBeatTime() + randomTimeOffset;

        // Calculate animation durations with slight randomness
        float durationRandomFactor = Random.Range(1f - animationRandomness * 0.5f, 1f + animationRandomness * 0.5f);
        float totalAnimDuration;
        float preBeatDuration;
        float postBeatDuration;

        if (twoBeatCycle)
        {
            // In two-beat mode, we stretch on first beat, then return on second beat
            totalAnimDuration = beatDuration * durationRandomFactor; // Full beat duration with randomness
            preBeatDuration = totalAnimDuration * preBeatFraction;
            postBeatDuration = totalAnimDuration - preBeatDuration;
        }
        else
        {
            // In one-beat mode, we do the full animation in one beat
            totalAnimDuration = beatDuration * animationDuration * durationRandomFactor;
            preBeatDuration = totalAnimDuration * preBeatFraction;
            postBeatDuration = totalAnimDuration - preBeatDuration;
        }

        // Calculate when to start the animation to hit the peak exactly on the beat
        float animationStartTime = nextBeatTime - preBeatDuration;

        // Wait until it's time to start the animation
        float waitTime = animationStartTime - Time.time;
        if (waitTime > 0)
        {
            yield return new WaitForSeconds(waitTime);
        }

        // Animation Phase 1: First transition
        float startTimePhase1 = Time.time;
        float endTimePhase1 = nextBeatTime;

        while (Time.time < endTimePhase1)
        {
            float progress = Mathf.InverseLerp(startTimePhase1, endTimePhase1, Time.time);

            // Apply a slightly modified easing for more organic movement
            // This combines the animation curve with a sine wave for subtle variation
            float easedProgress = animationCurve.Evaluate(progress);
            if (animationRandomness > 0)
            {
                // Add subtle sine wave overlay for more natural motion
                float sineWave = Mathf.Sin(progress * Mathf.PI * 2) * animationRandomness * 0.15f;
                easedProgress = Mathf.Clamp01(easedProgress + sineWave);
            }

            // Apply scale transformation
            transform.localScale = Vector3.Lerp(sourceScale, targetScale, easedProgress);

            yield return null;
        }

        // Ensure we reach the exact target scale at the beat
        transform.localScale = targetScale;

        // If using natural rebound, add a small rebound animation
        if (useNaturalRebound && !twoBeatCycle) // Only in one-beat mode
        {
            // Add a short rebound phase
            float reboundDuration = beatDuration * 0.15f; // Brief rebound
            float startRebound = Time.time;
            float endRebound = startRebound + reboundDuration;

            // Animate to the rebound scale
            while (Time.time < endRebound)
            {
                float progress = Mathf.InverseLerp(startRebound, endRebound, Time.time);
                // Use a sin curve for the rebound motion
                float reboundEase = Mathf.Sin(progress * Mathf.PI);

                transform.localScale = Vector3.Lerp(targetScale, reboundScale, reboundEase);

                yield return null;
            }
        }

        // If using two-beat cycle, wait for next beat before returning
        if (twoBeatCycle)
        {
            // Wait for the next beat to occur
            float timeToNextBeat = MusicManager.Instance.GetNextBeatTime() - Time.time;

            if (timeToNextBeat > 0)
            {
                yield return new WaitForSeconds(timeToNextBeat);
            }

            // Swap source and target for the return journey
            Vector3 tempScale = sourceScale;
            sourceScale = targetScale;
            targetScale = tempScale;

            // Animation Phase 2: Second transition
            float startTimePhase2 = Time.time;
            float endTimePhase2 = startTimePhase2 + beatDuration;

            while (Time.time < endTimePhase2)
            {
                float progress = Mathf.InverseLerp(startTimePhase2, endTimePhase2, Time.time);

                // Apply slightly modified easing
                float easedProgress = animationCurve.Evaluate(progress);
                if (animationRandomness > 0)
                {
                    // Add subtle sine wave overlay
                    float sineWave = Mathf.Sin(progress * Mathf.PI * 2) * animationRandomness * 0.15f;
                    easedProgress = Mathf.Clamp01(easedProgress + sineWave);
                }

                // Apply scale transformation
                transform.localScale = Vector3.Lerp(sourceScale, targetScale, easedProgress);

                yield return null;
            }

            // Add rebound at the end of two-beat cycle if enabled
            if (useNaturalRebound)
            {
                // Add a short rebound phase
                float reboundDuration = beatDuration * 0.15f; // Brief rebound
                float startRebound = Time.time;
                float endRebound = startRebound + reboundDuration;

                // Animate to the rebound scale
                while (Time.time < endRebound)
                {
                    float progress = Mathf.InverseLerp(startRebound, endRebound, Time.time);
                    // Use a sin curve for the rebound motion
                    float reboundEase = Mathf.Sin(progress * Mathf.PI);

                    transform.localScale = Vector3.Lerp(targetScale, reboundScale, reboundEase);

                    yield return null;
                }
            }
        }
        else // One-beat cycle
        {
            // Animation Phase 2: Return journey
            float startTimePhase2 = Time.time;
            float endTimePhase2 = startTimePhase2 + postBeatDuration;

            while (Time.time < endTimePhase2)
            {
                float progress = Mathf.InverseLerp(startTimePhase2, endTimePhase2, Time.time);

                // Apply slightly modified easing for more organic movement
                float easedProgress = animationCurve.Evaluate(progress);
                if (animationRandomness > 0)
                {
                    // Add subtle sine wave overlay
                    float sineWave = Mathf.Sin(progress * Mathf.PI) * animationRandomness * 0.15f;
                    easedProgress = Mathf.Clamp01(easedProgress + sineWave);
                }

                // If we started stretched, we go normal then back to stretched
                // If we started normal, we go stretched then back to normal
                transform.localScale = Vector3.Lerp(targetScale, sourceScale, easedProgress);

                yield return null;
            }
        }

        // Ensure we end at the right scale (same as what we started with)
        transform.localScale = sourceScale;

        isAnimating = false;
    }

    protected virtual IEnumerator AnimateBounce(float beatDuration)
    {
        isAnimating = true;

        // Store original position and rotation
        Vector3 startPos = transform.localPosition;
        Quaternion startRot = transform.localRotation;
        Vector3 startScale = transform.localScale;

        // Apply the object's unique variation factor to bounce height and rotation
        float effectiveHeight = bounceHeight * objectVariationFactor;
        float effectiveRotation = maxBounceRotation * objectVariationFactor;

        // Add slight randomness for organic feel
        float randomizedHeight = effectiveHeight * Random.Range(1f - animationRandomness, 1f + animationRandomness);
        float randomizedRotation = effectiveRotation * Random.Range(0.7f, 1.3f);

        // Calculate target positions and rotations
        Vector3 peakPos = new Vector3(
            originalPosition.x,
            originalPosition.y + randomizedHeight,
            originalPosition.z
        );

        // Normalize rotation axis
        Vector3 normalizedRotAxis = rotationAxis.normalized;

        // Create target rotation (tilted during bounce)
        Quaternion peakRot = Quaternion.AngleAxis(randomizedRotation, normalizedRotAxis) * originalRotation;

        // Calculate squashed scale for landing
        Vector3 squashedScale = originalScale;
        if (squashOnLand)
        {
            squashedScale = new Vector3(
                originalScale.x * (1f + (1f - squashFactor) * 0.5f),
                originalScale.y * squashFactor,
                originalScale.z * (1f + (1f - squashFactor) * 0.5f)
            );
        }

        float randomTimeOffset = beatDuration * Random.Range(-animationRandomness * 0.2f, animationRandomness * 0.2f); // Reduced randomness
        
        // Get next beat time for animation timing - with better null check
        float nextBeatTime;
        if (MusicManager.Instance != null)
        {
            nextBeatTime = MusicManager.Instance.GetNextBeatTime() + randomTimeOffset;
        }
        else
        {
            nextBeatTime = Time.time + beatDuration + randomTimeOffset;
        }

        if (twoBeatBounce)
        {
            // === TWO BEAT CYCLE ===
            
            float durationRandomFactor = Random.Range(1f - animationRandomness * 0.3f, 1f + animationRandomness * 0.3f); // Reduced range
            float riseAnimDuration = beatDuration * durationRandomFactor;
            float preBeatRiseDuration = riseAnimDuration * preBeatFraction;

            float animationStartTime = nextBeatTime - preBeatRiseDuration;
            float waitTime = animationStartTime - Time.time;
            
            if (waitTime > 0 && waitTime < beatDuration * 2f) // Don't wait longer than 2 beats
            {
                yield return new WaitForSeconds(waitTime);
            }

            if (!isAnimating)
            {
                yield break;
            }

            // Animation Phase 1: Rise up to the first beat (ground to peak)
            float startTimeRise = Time.time;
            float endTimeRise = nextBeatTime;
            float maxRiseTime = beatDuration * 1.5f; // Safety limit

            while (Time.time < endTimeRise && Time.time - startTimeRise < maxRiseTime && isAnimating)
            {
                float progress = Mathf.InverseLerp(startTimeRise, endTimeRise, Time.time);
                float easedProgress = bounceCurve.Evaluate(progress);

                transform.localPosition = Vector3.Lerp(originalPosition, peakPos, easedProgress);
                transform.localRotation = Quaternion.Slerp(originalRotation, peakRot, easedProgress);

                yield return null;
            }

            if (!isAnimating)
            {
                yield break;
            }

            // Ensure we reach the exact peak position at the beat
            transform.localPosition = peakPos;
            transform.localRotation = peakRot;

            // Hold near the peak until the next beat
            float secondBeatTime;
            if (MusicManager.Instance != null)
            {
                secondBeatTime = MusicManager.Instance.GetNextBeatTime();
            }
            else
            {
                secondBeatTime = nextBeatTime + beatDuration;
            }
            
            float timeToNextBeat = secondBeatTime - Time.time;

            if (timeToNextBeat > 0 && timeToNextBeat < beatDuration * 1.5f && isAnimating) // Safety limits
            {
                float holdStartTime = Time.time;
                float holdEndTime = secondBeatTime - (beatDuration * 0.1f);

                while (Time.time < holdEndTime && isAnimating)
                {
                    float holdProgress = Mathf.InverseLerp(holdStartTime, holdEndTime, Time.time);
                    float hoverOffset = Mathf.Sin(holdProgress * Mathf.PI * 2) * 0.05f * randomizedHeight;

                    transform.localPosition = new Vector3(
                        peakPos.x,
                        peakPos.y + hoverOffset,
                        peakPos.z
                    );

                    yield return null;
                }

                if (!isAnimating)
                {
                    yield break;
                }

                // Fall phase to the second beat
                float fallStartTime = Time.time;
                float fallEndTime = secondBeatTime;
                float maxFallTime = beatDuration; // Safety limit

                while (Time.time < fallEndTime && Time.time - fallStartTime < maxFallTime && isAnimating)
                {
                    float fallProgress = Mathf.InverseLerp(fallStartTime, fallEndTime, Time.time);
                    float easedFallProgress = bounceCurve.Evaluate(fallProgress);

                    transform.localPosition = Vector3.Lerp(peakPos, originalPosition, easedFallProgress);
                    transform.localRotation = Quaternion.Slerp(peakRot, originalRotation, easedFallProgress);

                    yield return null;
                }
            }

            if (!isAnimating)
            {
                yield break;
            }

            // Ensure we're at ground level
            transform.localPosition = originalPosition;
            transform.localRotation = originalRotation;

            if (squashOnLand && isAnimating)
            {
                float squashDuration = beatDuration * 0.2f;
                float startSquash = Time.time;
                float endSquash = startSquash + squashDuration;

                while (Time.time < endSquash && isAnimating)
                {
                    float progress = Mathf.InverseLerp(startSquash, endSquash, Time.time);
                    
                    float squashProgress;
                    if (progress < 0.3f)
                    {
                        squashProgress = progress / 0.3f;
                    }
                    else
                    {
                        squashProgress = 1f - ((progress - 0.3f) / 0.7f);
                    }

                    transform.localScale = Vector3.Lerp(originalScale, squashedScale, squashProgress);
                    yield return null;
                }

                // Ensure we end at the original scale
                if (isAnimating)
                {
                    transform.localScale = originalScale;
                }
            }
        }
        else
        {
            // === ONE BEAT CYCLE ===
            
            float durationRandomFactor = Random.Range(1f - animationRandomness * 0.3f, 1f + animationRandomness * 0.3f);
            float totalAnimDuration = beatDuration * animationDuration * durationRandomFactor;
            float preBeatDuration = totalAnimDuration * preBeatFraction;
            float postBeatDuration = totalAnimDuration - preBeatDuration;

            float animationStartTime = nextBeatTime - preBeatDuration;
            float waitTime = animationStartTime - Time.time;
            
            if (waitTime > 0 && waitTime < beatDuration) // Don't wait longer than 1 beat
            {
                yield return new WaitForSeconds(waitTime);
            }

            if (!isAnimating)
            {
                yield break;
            }

            // Animation Phase 1: Rise up to the beat (ground to peak)
            float startTimePhase1 = Time.time;
            float endTimePhase1 = nextBeatTime;
            float maxPhase1Time = beatDuration; // Safety limit

            while (Time.time < endTimePhase1 && Time.time - startTimePhase1 < maxPhase1Time && isAnimating)
            {
                float progress = Mathf.InverseLerp(startTimePhase1, endTimePhase1, Time.time);
                float easedProgress = bounceCurve.Evaluate(progress);

                transform.localPosition = Vector3.Lerp(originalPosition, peakPos, easedProgress);
                transform.localRotation = Quaternion.Slerp(originalRotation, peakRot, easedProgress);

                yield return null;
            }

            if (!isAnimating)
            {
                yield break;
            }

            // Ensure we reach the exact peak position and rotation at the beat
            transform.localPosition = peakPos;
            transform.localRotation = peakRot;

            // Animation Phase 2: Fall back down (peak to ground)
            float startTimePhase2 = Time.time;
            float endTimePhase2 = startTimePhase2 + postBeatDuration * 0.8f;

            while (Time.time < endTimePhase2 && isAnimating)
            {
                float progress = Mathf.InverseLerp(startTimePhase2, endTimePhase2, Time.time);
                float easedProgress = bounceCurve.Evaluate(1f - progress); // Inverse for the way down

                transform.localPosition = Vector3.Lerp(peakPos, originalPosition, easedProgress);
                transform.localRotation = Quaternion.Slerp(peakRot, originalRotation, easedProgress);

                yield return null;
            }

            if (!isAnimating)
            {
                yield break;
            }

            // Ensure we reach the ground
            transform.localPosition = originalPosition;
            transform.localRotation = originalRotation;

            if (squashOnLand && isAnimating)
            {
                float squashDuration = postBeatDuration * 0.2f;
                float startSquash = Time.time;
                float endSquash = startSquash + squashDuration;

                while (Time.time < endSquash && isAnimating)
                {
                    float progress = Mathf.InverseLerp(startSquash, endSquash, Time.time);
                    
                    float squashProgress;
                    if (progress < 0.3f)
                    {
                        squashProgress = progress / 0.3f;
                    }
                    else
                    {
                        squashProgress = 1f - ((progress - 0.3f) / 0.7f);
                    }

                    transform.localScale = Vector3.Lerp(originalScale, squashedScale, squashProgress);
                    yield return null;
                }

                // Ensure we end at the original scale
                if (isAnimating)
                {
                    transform.localScale = originalScale;
                }
            }
        }

        isAnimating = false;
        currentAnimation = null;
    }

    protected virtual IEnumerator AnimateTileReactiveBounce(float duration, float tileMovementAmount)
    {
        isAnimating = true;

        if (debugReactions)
        {
            Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} starting tile reactive bounce animation. Movement amount: {tileMovementAmount}");
        }

        // Store original position and rotation
        Vector3 startPos = transform.localPosition;
        Quaternion startRot = transform.localRotation;
        Vector3 startScale = transform.localScale;

        // Apply the object's unique variation factor to bounce height and rotation
        float effectiveHeight = bounceHeight * objectVariationFactor;
        float effectiveRotation = maxBounceRotation * objectVariationFactor;

        // Create bounce-specific variations based on the bounce counter
        // This ensures each bounce has a different feel

        // Generate pseudo-random but deterministic values based on object ID, bounce counter and time
        float bounceVariation = (bounceCounter * 7919 + uniqueObjectID * 104729) % 1000 / 1000.0f;
        float timeOffset = Mathf.Sin(Time.time * 0.1f + uniqueObjectID) * 0.5f + 0.5f;

        // Create unique values for this specific bounce
        float variationHeight = 1.0f + (bounceVariation - 0.5f) * heightVariationPerBounce * 2.0f;
        float timingMod = 1.0f + (timeOffset - 0.5f) * timingVariation * 2.0f;
        float rotationMod = 1.0f + (bounceVariation - 0.5f) * rotationVariation * 2.0f;

        // Create a unique rotation axis for this bounce that's different from the default
        Vector3 thisBounceRotationAxis = new Vector3(
            uniqueRotationAxis.x + (bounceVariation - 0.5f) * axisVariation,
            uniqueRotationAxis.y + ((bounceCounter * 13) % 100 / 100.0f - 0.5f) * axisVariation,
            uniqueRotationAxis.z + ((Time.time * 7) % 1 - 0.5f) * axisVariation
        ).normalized;

        // Scale bounce height based on how much the tile moved
        float heightScale = Mathf.Clamp01(tileMovementAmount / (tileMovementThreshold * 3));
        float adjustedHeight = effectiveHeight * variationHeight * (0.7f + heightScale * 0.6f);

        // Add slight randomness for organic feel
        float randomizedHeight = adjustedHeight * Random.Range(1f - animationRandomness * 0.5f, 1f + animationRandomness * 0.5f);
        float randomizedRotation = effectiveRotation * rotationMod * Random.Range(0.7f, 1.3f) * heightScale;

        // Create lateral offsets to add wobble to the path
        float lateralOffsetX = Mathf.Sin(bounceCounter * 0.7f) * pathWobble * 0.05f;
        float lateralOffsetZ = Mathf.Cos(bounceCounter * 1.3f) * pathWobble * 0.05f;

        // Calculate target positions and rotations with wobble
        Vector3 peakPos = new Vector3(
            originalPosition.x + lateralOffsetX,
            originalPosition.y + randomizedHeight,
            originalPosition.z + lateralOffsetZ
        );

        // Create target rotation for this specific bounce
        Quaternion peakRot = Quaternion.AngleAxis(randomizedRotation, thisBounceRotationAxis) * originalRotation;

        // Adjust squash effect for this bounce
        float squashVariation = 0.9f + (bounceVariation * 0.2f);

        // Calculate squashed scale for landing with variation
        Vector3 squashedScale = originalScale;
        if (squashOnLand)
        {
            // Make squash vary by bounce
            float effectiveSquashFactor = squashFactor * squashVariation;
            effectiveSquashFactor = Mathf.Clamp(effectiveSquashFactor, 0.5f, 0.95f);

            // Each bounce squashes differently
            squashedScale = new Vector3(
                originalScale.x * (1f + (1f - effectiveSquashFactor) * 0.5f),
                originalScale.y * effectiveSquashFactor,
                originalScale.z * (1f + (1f - effectiveSquashFactor) * 0.5f)
            );
        }

        // Apply timing variation for this bounce
        float modifiedDuration = duration * timingMod;

        // Rise up phase - with varied timing
        float riseTime = modifiedDuration * (0.35f + bounceVariation * 0.1f); // Rise time varies between bounces
        float elapsedTime = 0f;

        while (elapsedTime < riseTime)
        {
            float t = elapsedTime / riseTime;

            // Create a unique easing for this bounce
            float easedT;
            if (bounceCounter % 3 == 0) {
                // Sine-based easing
                easedT = Mathf.Sin(t * Mathf.PI * 0.5f);
            } else if (bounceCounter % 3 == 1) {
                // Bounce curve easing
                easedT = bounceCurve.Evaluate(t);
            } else {
                // Cubic easing
                easedT = t * t * (3f - 2f * t);
            }

            // Apply position and rotation changes - add some wobble to the path
            float wobbleX = Mathf.Sin(t * Mathf.PI * 2f + Time.time) * pathWobble * 0.02f;
            float wobbleZ = Mathf.Cos(t * Mathf.PI * 3f + Time.time) * pathWobble * 0.02f;

            Vector3 currentPos = Vector3.Lerp(startPos, peakPos, easedT);
            currentPos.x += wobbleX;
            currentPos.z += wobbleZ;

            transform.localPosition = currentPos;
            transform.localRotation = Quaternion.Slerp(startRot, peakRot, easedT);

            elapsedTime += Time.deltaTime;
            yield return null;
        }

        // Ensure we reach the peak
        transform.localPosition = peakPos;
        transform.localRotation = peakRot;

        // Hold at peak for a moment - varies per bounce
        float holdTime = modifiedDuration * (0.15f + bounceVariation * 0.1f);

        // Add a little hovering effect during the hold
        float holdStartTime = Time.time;
        float holdEndTime = holdStartTime + holdTime;

        while (Time.time < holdEndTime)
        {
            float holdProgress = Mathf.InverseLerp(holdStartTime, holdEndTime, Time.time);

            // Create a gentle floating effect
            float hoverOffset = Mathf.Sin(holdProgress * Mathf.PI * 2) * 0.03f * randomizedHeight;
            float wobbleX = Mathf.Sin(holdProgress * Mathf.PI * 3f) * pathWobble * 0.01f;
            float wobbleZ = Mathf.Cos(holdProgress * Mathf.PI * 2f) * pathWobble * 0.01f;

            // Apply subtle hovering motion
            transform.localPosition = new Vector3(
                peakPos.x + wobbleX,
                peakPos.y + hoverOffset,
                peakPos.z + wobbleZ
            );

            yield return null;
        }

        // Fall down phase - slightly faster for more cartoon-like effect, varies by bounce
        float fallTime = modifiedDuration * (0.25f + bounceVariation * 0.1f);
        elapsedTime = 0f;

        while (elapsedTime < fallTime)
        {
            float t = elapsedTime / fallTime;

            // Create a unique easing for the fall of this bounce
            float easedT;
            if (bounceCounter % 4 == 0) {
                // Quick start, slow end
                easedT = 1f - Mathf.Pow(1f - t, 2f);
            } else if (bounceCounter % 4 == 1) {
                // Bounce curve inversion for fall
                easedT = bounceCurve.Evaluate(1f - t);
            } else if (bounceCounter % 4 == 2) {
                // Linear fall
                easedT = 1f - t;
            } else {
                // Accelerating fall
                easedT = 1f - (t * t);
            }

            // Apply position and rotation changes with subtle path variation
            float wobbleX = Mathf.Sin(t * Mathf.PI * 2f + Time.time * 0.7f) * pathWobble * 0.015f;
            float wobbleZ = Mathf.Cos(t * Mathf.PI * 1.5f + Time.time * 0.9f) * pathWobble * 0.015f;

            Vector3 currentPos = Vector3.Lerp(originalPosition, peakPos, easedT);
            currentPos.x += wobbleX;
            currentPos.z += wobbleZ;

            transform.localPosition = currentPos;
            transform.localRotation = Quaternion.Slerp(originalRotation, peakRot, easedT);

            elapsedTime += Time.deltaTime;
            yield return null;
        }

        // Ensure we reach the ground
        transform.localPosition = originalPosition;
        transform.localRotation = originalRotation;

        // Add squash effect if enabled - with variations
        if (squashOnLand)
        {
            float squashTime = modifiedDuration * (0.08f + bounceVariation * 0.04f);
            elapsedTime = 0f;

            while (elapsedTime < squashTime)
            {
                float t = elapsedTime / squashTime;

                // Squash and then unsquash - faster in, slower out - varies by bounce
                float squashT;
                if (bounceCounter % 2 == 0) {
                    // Standard squash easing
                    if (t < 0.3f) {
                        squashT = t / 0.3f; // Fast ease in
                    } else {
                        squashT = 1f - ((t - 0.3f) / 0.7f); // Slower ease out
                    }
                } else {
                    // Alternate squash easing
                    if (t < 0.4f) {
                        squashT = Mathf.Sin(t / 0.4f * Mathf.PI * 0.5f);
                    } else {
                        squashT = Mathf.Cos((t - 0.4f) / 0.6f * Mathf.PI * 0.5f);
                    }
                }

                transform.localScale = Vector3.Lerp(originalScale, squashedScale, squashT);

                elapsedTime += Time.deltaTime;
                yield return null;
            }

            // Ensure we end at the original scale
            transform.localScale = originalScale;
        }

        isAnimating = false;

        if (debugReactions)
        {
            Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} finished tile reactive bounce animation");
        }
    }

    protected virtual void HandleMusicStateChange(string newState)
    {
        // Reset animation if music state changes
        if (currentAnimation != null)
        {
            StopCoroutine(currentAnimation);
            isAnimating = false;

            // Reset to original state
            transform.localScale = originalScale;
            transform.localPosition = originalPosition;
            transform.localRotation = originalRotation;

            // Reset tile reactive state
            isWaitingForTileDown = false;
            hasTileMovedUp = false;
        }
    }

    public virtual void ResetToOriginalState()
    {
        if (currentAnimation != null)
        {
            StopCoroutine(currentAnimation);
        }

        transform.localScale = originalScale;
        transform.localPosition = originalPosition;
        transform.localRotation = originalRotation;

        isAnimating = false;
        isWaitingForTileDown = false;
        hasTileMovedUp = false;
    }

    public override void OnDestroy()
    {
        base.OnDestroy();

        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= HandleBeat;
            MusicManager.Instance.OnMusicStateChanged -= HandleMusicStateChange;
        }

        if (currentAnimation != null)
        {
            StopCoroutine(currentAnimation);
            currentAnimation = null;
        }
    }

    #region Helper Methods for Odin Inspector
    // Used for showing/hiding stretch animation properties
    protected bool IsStretchAnimation()
    {
        return animationType == EnvironmentAnimationType.Stretch;
    }

    // Used for showing/hiding bounce animation properties
    protected bool IsBounceAnimation()
    {
        return animationType == EnvironmentAnimationType.Bounce;
    }

    // Used for showing/hiding tile reactive animation properties
    protected bool IsBounceTileReactiveAnimation()
    {
        return animationType == EnvironmentAnimationType.BounceTileReactive;
    }
    #endregion

#if UNITY_EDITOR
    [ContextMenu("Test Beat Reaction")]
    protected virtual void TestBeatReaction()
    {
        if (!isInitialized)
        {
            InitializeReactiveState();
        }

        if (currentAnimation != null)
        {
            StopCoroutine(currentAnimation);
        }

        switch (animationType)
        {
            case EnvironmentAnimationType.Stretch:
                if (useStretchAnimation)
                {
                    currentAnimation = StartCoroutine(AnimateStretch(0.5f));
                }
                break;
            case EnvironmentAnimationType.Bounce:
                currentAnimation = StartCoroutine(AnimateBounce(0.5f));
                break;
            case EnvironmentAnimationType.BounceTileReactive:
                bounceCounter++; // Increment bounce counter for testing
                currentAnimation = StartCoroutine(AnimateTileReactiveBounce(tileReactiveAnimationDuration, 0.2f));
                break;
        }
    }

    [ContextMenu("Reset To Original State")]
    protected virtual void EditorResetState()
    {
        ResetToOriginalState();
    }

    [ContextMenu("Reset Tile Reactive Flags")]
    protected virtual void ResetTileReactiveFlags()
    {
        isWaitingForTileDown = false;
        hasTileMovedUp = false;
        isAnimating = false;

        Debug.Log($"[REACTIVE ENVIRONMENT] {gameObject.name} tile reactive flags reset via editor menu");
    }

    [ContextMenu("Test Organic Bounce Variations")]
    protected virtual void TestOrganicBounceVariations()
    {
        if (!isInitialized)
        {
            InitializeReactiveState();
        }

        if (animationType != EnvironmentAnimationType.BounceTileReactive)
        {
            Debug.LogWarning("This test is for BounceTileReactive animation type only!");
            return;
        }

        StartCoroutine(TestMultipleBounces());
    }

    private IEnumerator TestMultipleBounces()
    {
        for (int i = 0; i < 5; i++)
        {
            if (currentAnimation != null)
            {
                StopCoroutine(currentAnimation);
            }

            bounceCounter++;
            Debug.Log($"Testing bounce #{bounceCounter}");
            currentAnimation = StartCoroutine(AnimateTileReactiveBounce(tileReactiveAnimationDuration, 0.2f));

            // Wait for animation to complete plus a small delay
            yield return new WaitForSeconds(tileReactiveAnimationDuration + 0.3f);
        }
    }
#endif
}



// --- FILE: Scripts/Environment/MusicReactiveEnvironment_Optimized.cs ---
﻿using UnityEngine;
using Sirenix.OdinInspector;
using System.Collections;

/// <summary>
/// Version optimisée et complète de MusicReactiveEnvironment.
/// Ce script est conçu pour être une simple couche de configuration qui appelle le EnvironmentAnimationManager,
/// qui est maintenant une réplique structurelle de TileAnimationManager.
/// </summary>
public class MusicReactiveEnvironment_Optimized : Environment, IAnimatableEnvironment
{
    #region Configuration Fields
    [Title("Music Reaction Settings")]
    [SerializeField, Range(0f, 1f)]
    protected float reactionProbability = 0.65f;

    [SerializeField]
    protected bool reactToBeat = true;

    [SerializeField]
    protected EnvironmentAnimationType animationType = EnvironmentAnimationType.Stretch;

    [Title("Stretch Animation Settings")]
    [ShowIf("IsStretchAnimation")]
    [SerializeField]
    protected bool useStretchAnimation = true;

    [ShowIf("@this.IsStretchAnimation() && this.useStretchAnimation")]
    [SerializeField, LabelText("Stretch Axis")]
    protected Vector3 stretchAxis = new Vector3(0, 1, 0);

    [ShowIf("@this.IsStretchAnimation() && this.useStretchAnimation")]
    [SerializeField, Range(0.5f, 2f), LabelText("Stretch Intensity")]
    protected float stretchIntensity = 1.2f;

    [Title("Bounce Animation Settings")]
    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, Range(0.1f, 3f), LabelText("Bounce Height")]
    protected float bounceHeight = 0.5f;

    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, Range(0f, 45f), LabelText("Max Bounce Rotation")]
    protected float maxBounceRotation = 15f;

    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, LabelText("Rotation Axis")]
    protected Vector3 rotationAxis = new Vector3(1, 0, 0);

    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, LabelText("Bounce Curve")]
    protected AnimationCurve bounceCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

    [ShowIf("@this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()")]
    [SerializeField, LabelText("Squash On Land")]
    protected bool squashOnLand = true;

    [ShowIf("@(this.IsBounceAnimation() || this.IsBounceTileReactiveAnimation()) && this.squashOnLand")]
    [SerializeField, Range(0.5f, 1f), LabelText("Squash Factor")]
    protected float squashFactor = 0.8f;

    [Title("Common Settings")]
    [SerializeField, Range(0.1f, 2f), LabelText("Animation Duration")]
    protected float animationDuration = 0.5f;

    [SerializeField, LabelText("Animation Curve")]
    protected AnimationCurve animationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);

    // Note: Les autres champs complexes (TileReactive, Organic, etc.) sont omis pour se concentrer
    // sur le cœur du problème (Stretch & Bounce), mais peuvent être ajoutés de la même manière.
    #endregion

    #region Private State
    private bool isAnimating = false;
    #endregion

    #region Unity Lifecycle
    protected override IEnumerator Start()
    {
        yield return StartCoroutine(base.Start());
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat += HandleBeat;
        }
    }

    public override void OnDestroy()
    {
        base.OnDestroy();
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= HandleBeat;
        }
        if (EnvironmentAnimationManager.Instance != null)
        {
            // Assure qu'aucune animation ne reste en cours si l'objet est détruit
            EnvironmentAnimationManager.Instance.StopAllAnimationsFor(this);
        }
    }
    #endregion

    /// <summary>
    /// La méthode principale qui réagit au battement de la musique.
    /// </summary>
    private void HandleBeat(float beatDuration)
    {
        // Conditions pour ne pas jouer l'animation
        if (isAnimating || !reactToBeat || !this.enabled || !gameObject.activeInHierarchy) return;
        if (Random.value > reactionProbability) return;

        // On se marque comme "en animation" pour éviter les déclenchements multiples
        isAnimating = true;

        // On délègue entièrement la logique d'animation au manager
        switch (animationType)
        {
            case EnvironmentAnimationType.Stretch:
                if (!useStretchAnimation)
                {
                    isAnimating = false; // On n'anime pas, on se libère
                    return;
                }
                EnvironmentAnimationManager.Instance.RequestAnimation(
                    this,
                    EnvironmentAnimationManager.AnimationType.Stretch,
                    animationDuration,
                    animationCurve,
                    stretchIntensity: stretchIntensity,
                    stretchAxis: stretchAxis
                );
                break;

            case EnvironmentAnimationType.Bounce:
                EnvironmentAnimationManager.Instance.RequestAnimation(
                    this,
                    EnvironmentAnimationManager.AnimationType.Bounce,
                    animationDuration,
                    bounceCurve,
                    bounceHeight: bounceHeight,
                    bounceRotation: maxBounceRotation,
                    rotationAxis: rotationAxis,
                    squashFactor: squashOnLand ? squashFactor : 1.0f // squashFactor de 1 = pas de squash
                );
                break;
            
            // Le cas pour BounceTileReactive serait géré ici, probablement pas sur le beat
            // mais dans la méthode Update() en vérifiant le mouvement de la tuile.
            case EnvironmentAnimationType.BounceTileReactive:
                isAnimating = false; // Pour cet exemple, on ne fait rien sur le beat.
                break;
        }
    }

    /// <summary>
    /// Callback appelé par le EnvironmentAnimationManager quand l'animation est terminée.
    /// </summary>
    public void OnAnimationComplete()
    {
        isAnimating = false;
    }

    #region Odin Inspector Helpers
    protected bool IsStretchAnimation() => animationType == EnvironmentAnimationType.Stretch;
    protected bool IsBounceAnimation() => animationType == EnvironmentAnimationType.Bounce;
    protected bool IsBounceTileReactiveAnimation() => animationType == EnvironmentAnimationType.BounceTileReactive;
    #endregion
}

// --- FILE: Scripts/Environment/StillEnvironment.cs ---
using UnityEngine;
using System.Collections;

public class StillEnvironment : Environment
{
    [Header("Forced Attachment (Optionnel)")]
    [Tooltip("Si une tuile est assignée ici, l'environnement tentera de s'y attacher au démarrage, ignorant la recherche de la plus proche.")]
    public Tile forceAttachTile = null;

    [Header("Granular Lock Settings")]
    [Tooltip("Verrouille la position locale sur l'axe X.")]
    [SerializeField] private bool lockLocalPositionX = true;
    [Tooltip("Verrouille la position locale sur l'axe Y.")]
    [SerializeField] private bool lockLocalPositionY = true;
    [Tooltip("Verrouille la position locale sur l'axe Z.")]
    [SerializeField] private bool lockLocalPositionZ = true;

    [Space(10)]
    [Tooltip("Verrouille la rotation locale sur l'axe X (Euler).")]
    [SerializeField] private bool lockLocalRotationX = true;
    [Tooltip("Verrouille la rotation locale sur l'axe Y (Euler).")]
    [SerializeField] private bool lockLocalRotationY = true;
    [Tooltip("Verrouille la rotation locale sur l'axe Z (Euler).")]
    [SerializeField] private bool lockLocalRotationZ = true;

    [Space(10)]
    [Tooltip("Verrouille l'échelle locale sur l'axe X.")]
    [SerializeField] private bool lockLocalScaleX = true;
    [Tooltip("Verrouille l'échelle locale sur l'axe Y.")]
    [SerializeField] private bool lockLocalScaleY = true;
    [Tooltip("Verrouille l'échelle locale sur l'axe Z.")]
    [SerializeField] private bool lockLocalScaleZ = true;

    private Vector3 _initialLocalPosition;
    private Quaternion _initialLocalRotation;
    private Vector3 _initialLocalScale;

    private bool _stillEnvironmentInitialized = false;

    protected override IEnumerator Start()
    {
        // --- NOUVEAU: Capturer l'échelle locale désirée AVANT toute modification par SetParent ou Tile.cs ---
        // Ceci représente l'échelle que vous avez définie dans l'éditeur pour cet objet, avant qu'il ne devienne enfant d'une tuile.
        Vector3 desiredFinalLocalScale = transform.localScale;
        // --- FIN NOUVEAU ---

        bool attachedThisCycle = false; // Renommé pour clarté et portée

        if (forceAttachTile != null)
        {
            if (!forceAttachTile.IsOccupied || forceAttachTile.currentEnvironment == this)
            {
                if (occupiedTile != null && occupiedTile != forceAttachTile)
                {
                    occupiedTile.RemoveEnvironment();
                }
                AttachToTile(forceAttachTile); // Cette méthode (de Environment.cs) appelle tile.AssignEnvironment()
                if (isAttached)
                {
                    attachedThisCycle = true;
                    // Debug.Log($"[{gameObject.name}/StillEnvironment] Force-attached to tile: {forceAttachTile.name}", this);
                }
                else
                {
                    // Debug.LogWarning($"[{gameObject.name}/StillEnvironment] Failed to force-attach to tile '{forceAttachTile.name}'. Falling back.", this);
                }
            }
            else
            {
                // Debug.LogWarning($"[{gameObject.name}/StillEnvironment] Cannot force-attach to tile '{forceAttachTile.name}' (occupied). Falling back.", this);
            }
        }

        if (!attachedThisCycle)
        {
            // Debug.Log($"[{gameObject.name}/StillEnvironment] No force attach or failed. Calling base.Start() for closest tile attachment.", this);
            yield return StartCoroutine(base.Start()); // base.Start() appelle AttachToTile -> tile.AssignEnvironment()
            // isAttached sera mis à jour par base.Start()
        }

        if (isAttached) // Vérifier le 'isAttached' qui est mis à jour par la classe de base ou l'attachement forcé.
        {
            // --- NOUVEAU: Réappliquer l'échelle locale désirée APRÈS le parentage et la compensation de Tile.cs ---
            // Cela annule la compensation d'échelle faite par Tile.AssignEnvironment,
            // permettant à StillEnvironment de conserver son échelle locale d'origine.
            transform.localScale = desiredFinalLocalScale;
            // --- FIN NOUVEAU ---

            // Maintenant, capturer les transformations locales finales pour le verrouillage.
            _initialLocalPosition = transform.localPosition; // Sera (0, yOffset, 0) par rapport à la tuile
            _initialLocalRotation = transform.localRotation; // Sera la rotation après ApplyRandomRotation (si activé)
            _initialLocalScale = transform.localScale;       // Sera desiredFinalLocalScale

            _stillEnvironmentInitialized = true;

            // Debug.Log($"[{gameObject.name}/StillEnvironment] Initialized. Tile: {occupiedTile.name}. " +
            //           $"DesiredLocalScale was: {desiredFinalLocalScale}, Effective InitialLocalScale for locking: {_initialLocalScale}. " +
            //           $"Initial Local Pos: {_initialLocalPosition}, Rot: {_initialLocalRotation.eulerAngles}", this);
        }
        else
        {
            Debug.LogWarning($"[{gameObject.name}/StillEnvironment] Failed to attach to any tile. Locking mechanisms will be disabled.", this);
        }
    }

    void LateUpdate()
    {
        if (!_stillEnvironmentInitialized || !isAttached)
        {
            return;
        }

        // Verrouillage de la Position Locale (inchangé)
        Vector3 currentLocalPos = transform.localPosition;
        bool positionNeedsUpdate = false;
        if (lockLocalPositionX && !Mathf.Approximately(currentLocalPos.x, _initialLocalPosition.x))
        {
            currentLocalPos.x = _initialLocalPosition.x;
            positionNeedsUpdate = true;
        }
        if (lockLocalPositionY && !Mathf.Approximately(currentLocalPos.y, _initialLocalPosition.y))
        {
            currentLocalPos.y = _initialLocalPosition.y;
            positionNeedsUpdate = true;
        }
        if (lockLocalPositionZ && !Mathf.Approximately(currentLocalPos.z, _initialLocalPosition.z))
        {
            currentLocalPos.z = _initialLocalPosition.z;
            positionNeedsUpdate = true;
        }
        if (positionNeedsUpdate)
        {
            transform.localPosition = currentLocalPos;
        }

        // Verrouillage de la Rotation Locale (inchangé)
        Vector3 currentLocalEuler = transform.localEulerAngles;
        Vector3 initialLocalEuler = _initialLocalRotation.eulerAngles;
        bool rotationNeedsUpdate = false;
        if (lockLocalRotationX && !Mathf.Approximately(currentLocalEuler.x, initialLocalEuler.x))
        {
            currentLocalEuler.x = initialLocalEuler.x;
            rotationNeedsUpdate = true;
        }
        if (lockLocalRotationY && !Mathf.Approximately(currentLocalEuler.y, initialLocalEuler.y))
        {
            currentLocalEuler.y = initialLocalEuler.y;
            rotationNeedsUpdate = true;
        }
        if (lockLocalRotationZ && !Mathf.Approximately(currentLocalEuler.z, initialLocalEuler.z))
        {
            currentLocalEuler.z = initialLocalEuler.z;
            rotationNeedsUpdate = true;
        }
        if (rotationNeedsUpdate)
        {
            transform.localRotation = Quaternion.Euler(currentLocalEuler);
        }

        // Verrouillage de l'Échelle Locale (inchangé - se base maintenant sur le _initialLocalScale corrigé)
        Vector3 currentLocalScale = transform.localScale;
        bool scaleNeedsUpdate = false;
        if (lockLocalScaleX && !Mathf.Approximately(currentLocalScale.x, _initialLocalScale.x))
        {
            currentLocalScale.x = _initialLocalScale.x;
            scaleNeedsUpdate = true;
        }
        if (lockLocalScaleY && !Mathf.Approximately(currentLocalScale.y, _initialLocalScale.y))
        {
            currentLocalScale.y = _initialLocalScale.y; // C'est ici que la magie opère maintenant
            scaleNeedsUpdate = true;
        }
        if (lockLocalScaleZ && !Mathf.Approximately(currentLocalScale.z, _initialLocalScale.z))
        {
            currentLocalScale.z = _initialLocalScale.z;
            scaleNeedsUpdate = true;
        }
        if (scaleNeedsUpdate)
        {
            transform.localScale = currentLocalScale;
        }
    }
    // La méthode SetBlocking est héritée de Environment.cs
}

// --- FILE: Scripts/Feedbacks/UnitSpawnFeedback.cs ---
using UnityEngine;
using MoreMountains.Feedbacks;
using System.Collections;

/// <summary>
/// Gère les feedbacks de spawn simplifié - CHARGE SEULEMENT
/// </summary>
public class UnitSpawnFeedback : MonoBehaviour
{
    [Header("Feel Integration")]
    [Tooltip("MMF_Player pour la phase Charge")]
    public MMF_Player ChargeFeedbacks;

    [Header("Timing Configuration")]
    [Tooltip("Durée de la phase Charge")]
    public float ChargeDuration = 0.3f;

    [Header("Spawn Configuration")]
    [Tooltip("Délai avant de commencer la séquence")]
    public float DelayBeforeSpawn = 0f;
    
    // --- MODIFICATION : Texte du Tooltip mis à jour ---
    [Tooltip("Synchroniser avec le beat du MusicManager")]
    public bool SyncWithRhythm = false;
    
    [Header("Debug")]
    [SerializeField] private bool enableDebugLogs = false;

    private bool hasPlayedSpawnFeedback = false;
    private Coroutine spawnSequenceCoroutine;
    private Unit _unit; // Référence au composant Unit
    public System.Action OnSpawnCompleted;

    /// <summary>
    /// Déclenche la séquence de spawn
    /// </summary>
    private IEnumerator ExecuteSpawnSequence()
    {
        if (_unit == null)
        {
            _unit = GetComponent<Unit>();
            if (_unit == null && enableDebugLogs)
            {
                Debug.LogWarning($"[UnitSpawnFeedback] Pas de composant Unit trouvé sur {gameObject.name}");
            }
        }

        if (_unit != null)
        {
            _unit.SetSpawningState(true);
        }
        
        hasPlayedSpawnFeedback = true;

        if (enableDebugLogs)
            Debug.Log($"[UnitSpawnFeedback] Début séquence spawn pour {gameObject.name}. _unit.IsSpawning: {(_unit != null ? _unit.IsSpawning.ToString() : "N/A")}");

        // PHASE UNIQUE: CHARGE
        if (ChargeFeedbacks != null)
        {
            if (enableDebugLogs) Debug.Log($"[UnitSpawnFeedback] Phase CHARGE ({ChargeDuration:F2}s)");
            ChargeFeedbacks.PlayFeedbacks();
        }
        yield return new WaitForSeconds(ChargeDuration);

        if (enableDebugLogs)
            Debug.Log($"[UnitSpawnFeedback] Séquence terminée pour {gameObject.name}");

        if (_unit != null)
        {
            _unit.SetSpawningState(false);
            if (enableDebugLogs) Debug.Log($"[UnitSpawnFeedback] {gameObject.name} _unit.IsSpawning set to false.");
        }

        // 🔥 NOUVEAU: Notifier AllyUnit que c'est terminé
        OnSpawnCompleted?.Invoke();
        
        spawnSequenceCoroutine = null;
    }

    /// <summary>
    /// Déclenche la séquence de feedback de spawn (public pour AllyUnit)
    /// </summary>
    public void PlaySpawnFeedback()
    {
        if (hasPlayedSpawnFeedback)
        {
            if (enableDebugLogs)
                Debug.LogWarning($"[UnitSpawnFeedback] Séquence déjà jouée pour {gameObject.name}");
            return;
        }

        if (spawnSequenceCoroutine != null)
        {
            StopCoroutine(spawnSequenceCoroutine);
        }
        spawnSequenceCoroutine = StartCoroutine(ExecuteSpawnSequence());
    }

    /// <summary>
    /// Arrête la séquence en cours
    /// </summary>
    public void StopSpawnFeedback()
    {
        if (spawnSequenceCoroutine != null)
        {
            StopCoroutine(spawnSequenceCoroutine);
            spawnSequenceCoroutine = null;
        }

        ChargeFeedbacks?.StopFeedbacks();
    }
    private void OnDestroy()
    {
        StopSpawnFeedback();
        OnSpawnCompleted = null; // Cleanup des événements
    }
    /// <summary>
    /// Remet à zéro pour réutilisation
    /// </summary>
    public void ResetForReuse()
    {
        hasPlayedSpawnFeedback = false;
        StopSpawnFeedback();
    }

    /// <summary>
    /// 🔥 NOUVELLE MÉTHODE : Lier manuellement le composant Unit
    /// </summary>
    public void SetUnit(Unit unit)
    {
        _unit = unit;
        if (enableDebugLogs)
            Debug.Log($"[UnitSpawnFeedback] Unit lié manuellement: {(_unit != null ? _unit.name : "null")}");
    }

    private void Awake()
    {
        // 🔥 CORRECTION : Essayer de récupérer Unit automatiquement
        if (_unit == null)
        {
            _unit = GetComponent<Unit>();
            if (enableDebugLogs)
            {
                Debug.Log($"[UnitSpawnFeedback] Unit auto-détecté: {(_unit != null ? "✅ Trouvé" : "❌ Pas trouvé")}");
            }
        }

        // Auto-setup du MMF_Player si pas assigné
        SetupMMFPlayer();
    }

    private void SetupMMFPlayer()
    {
        if (ChargeFeedbacks == null)
        {
            var mmfPlayer = GetComponent<MMF_Player>();
            if (mmfPlayer != null)
            {
                ChargeFeedbacks = mmfPlayer;
                if (enableDebugLogs)
                    Debug.Log($"[UnitSpawnFeedback] MMF_Player auto-assigné: {mmfPlayer.name}");
            }
        }
    }   
}


// --- FILE: Scripts/Gameplay/AllyUnitRegistry.cs ---
﻿using System;

namespace Gameplay
{
    using UnityEngine;
    using System.Collections.Generic;
    using System.Linq;
    using Unity.Behavior;


    public class AllyUnitRegistry : MonoBehaviour
    {
        public static AllyUnitRegistry Instance { get; private set; }

        private List<AllyUnit> activeAllyUnits = new List<AllyUnit>();
        public IReadOnlyList<AllyUnit> ActiveAllyUnits => activeAllyUnits.AsReadOnly(); // Exposition en lecture seule
        public event Action<AllyUnit> OnDefensiveKillConfirmed;

        private void Awake()
        {
            if (Instance == null)
            {
                Instance = this;
            }
            else
            {
                Debug.LogWarning("[AllyUnitRegistry] Multiple instances detected. Destroying duplicate.", gameObject);
                Destroy(gameObject);
            }
        }

        public void RegisterUnit(AllyUnit unit)
        {
            if (unit != null && !activeAllyUnits.Contains(unit))
            {
                activeAllyUnits.Add(unit);
            }
        }

        public void UnregisterUnit(AllyUnit unit)
        {
            if (unit != null)
            {
                activeAllyUnits.Remove(unit);
            }
        }
        
        private void OnEnable()
        {
            Unit.OnUnitKilled += HandleUnitKilled;
        }

        private void OnDisable()
        {
            Unit.OnUnitKilled -= HandleUnitKilled;
        }
        private void HandleUnitKilled(Unit attacker, Unit victim)
        {
            // On s'intéresse uniquement aux cas où l'attaquant est une unité alliée.
            if (attacker is AllyUnit attackingAlly)
            {
                var blackboard = attackingAlly.Blackboard;

                if (blackboard != null)
                {
                    BlackboardVariable<bool> isDefendingVar;
                    if (blackboard.GetVariable("IsDefending", out isDefendingVar))
                    {
                        if (isDefendingVar.Value)
                        {
                            if (MomentumManager.Instance != null && attackingAlly.MomentumGainOnObjectiveComplete > 0)
                            {
                                MomentumManager.Instance.AddMomentum(attackingAlly.MomentumGainOnObjectiveComplete);
                                Debug.Log($"[AllyUnitRegistry] L'unité défensive {attackingAlly.name} a tué une unité et a rapporté {attackingAlly.MomentumGainOnObjectiveComplete} de momentum.");
                            }
                            
                            OnDefensiveKillConfirmed?.Invoke(attackingAlly);
                        }
                    }
                }
            }
        }
    }
}

// --- FILE: Scripts/Gameplay/GamePlayManager.cs ---
namespace Gameplay
{
    using UnityEngine;
    using System.Collections.Generic;
    using System;
    using System.Linq;
    using ScriptableObjects;

    public class GameplayManager : MonoBehaviour
    {
        private LevelData_SO currentLevelData;
        private TeamManager teamManager;
        private SequenceController sequenceController;
        private LevelScenarioManager scenarioManager; 
        
        private GlobalSpellManager globalSpellManager;
        private UnitSpawner unitSpawner;
        [Header("Configuration")]
        [SerializeField] private string globalSpellsResourcePath = "Data/GlobalSpells";
        

        // Les cooldowns des unités sont maintenant gérés par UnitSpawner
        public IReadOnlyDictionary<string, float> UnitCooldowns => unitSpawner?.UnitCooldowns;
        public IReadOnlyDictionary<string, float> SpellCooldowns => globalSpellManager?.SpellCooldowns;
    
        private float _beatInterval;

        void Start()
        {
            // Récupération des instances
            teamManager = TeamManager.Instance;
            sequenceController = FindFirstObjectByType<SequenceController>();
            scenarioManager = FindFirstObjectByType<LevelScenarioManager>(); 
            unitSpawner = FindFirstObjectByType<UnitSpawner>();
            globalSpellManager = FindFirstObjectByType<GlobalSpellManager>();

            // Validation des dépendances critiques
            if (GameManager.Instance == null || GameManager.CurrentLevelToLoad == null)
            {
                Debug.LogError("[GameplayManager] GameManager ou CurrentLevelToLoad est null! Impossible d'initialiser le niveau.", this);
                enabled = false;
                return;
            }
            else
            {
                currentLevelData = GameManager.CurrentLevelToLoad;
            }
            
            if (teamManager == null || sequenceController == null || unitSpawner == null) // Ajout de unitSpawner
            {
                Debug.LogError("[GameplayManager] Un ou plusieurs managers/contrôleurs critiques (TeamManager, SequenceController, UnitSpawner) sont introuvables!", this);
                enabled = false;
                return;
            }
            InitializeLevel();
        }

        void InitializeLevel()
        {
            Debug.Log($"[GameplayManager] Initialisation du niveau : {currentLevelData.DisplayName}");
            ConfigureAudioAndRhythm();
            globalSpellManager.LoadSpells();
            InitializeSequenceController();
            SubscribeToSequenceEvents();
            Unit.OnUnitAttacked += HandleCombatDetection;
            Building.OnBuildingAttackedByUnit += HandleCombatDetection;
            
            if (scenarioManager != null && currentLevelData.scenario != null)
            {
                scenarioManager.Initialize(currentLevelData.scenario);
            }
            else if (scenarioManager != null)
            {
                Debug.LogWarning($"[GameplayManager] Le niveau '{currentLevelData.DisplayName}' n'a pas de LevelScenario_SO assigné.");
            }
        }

        void ConfigureAudioAndRhythm()
        {
            if (MusicManager.Instance != null && currentLevelData.RhythmBPM > 0)
            {
                MusicManager.Instance.SetBPM(currentLevelData.RhythmBPM);
                _beatInterval = MusicManager.Instance.GetBeatDuration();
            }

            if (MusicManager.Instance != null)
            {
                if (currentLevelData.MusicStateSwitch != null && currentLevelData.MusicStateSwitch.IsValid())
                {
                    MusicManager.Instance.SetMusicState(currentLevelData.MusicStateSwitch.Name);
                }
                else if (currentLevelData.BackgroundMusic != null && currentLevelData.BackgroundMusic.IsValid())
                {
                    currentLevelData.BackgroundMusic.Post(MusicManager.Instance.gameObject);
                }
                else
                {
                    MusicManager.Instance.SetMusicState("Exploration");
                }
            }
        }
        
        void InitializeSequenceController()
        {
            if (teamManager == null || sequenceController == null || globalSpellManager == null)
            {
                Debug.LogError("[GameplayManager] TeamManager, SequenceController ou GlobalSpellManager est null! Impossible d'initialiser le SequenceController.", this);
                return;
            }

            List<CharacterData_SO> activeTeam = teamManager.ActiveTeam;
            if (activeTeam == null)
            {
                Debug.LogWarning("[GameplayManager] L'équipe active est null. Le SequenceController sera initialisé avec une équipe vide.");
                activeTeam = new List<CharacterData_SO>();
            }
		             // Chargement des sorts globaux disponibles(AvailableSpells) 
			if (globalSpellManager.AvailableSpells == null || globalSpellManager.AvailableSpells.Count == 0)
            {
                Debug.LogWarning("[GameplayManager] Aucun sort global disponible. Le SequenceController sera initialisé sans sorts globaux.");
            }
            else
            {
                Debug.Log($"[GameplayManager] Chargement de {globalSpellManager.AvailableSpells.Count} sorts globaux pour le SequenceController.");
				sequenceController.InitializeWithPlayerTeamAndSpells(activeTeam, globalSpellManager.AvailableSpells.ToList());
           }
            // Initialisation du SequenceController avec l'équipe active et les sorts globaux disponibles
			            
        }

        void SubscribeToSequenceEvents()
        {
            if (sequenceController == null) return;
            SequenceController.OnCharacterInvocationSequenceComplete -= HandleCharacterInvocation;
            SequenceController.OnGlobalSpellSequenceComplete -= HandleGlobalSpell;

            SequenceController.OnCharacterInvocationSequenceComplete += HandleCharacterInvocation;
            SequenceController.OnGlobalSpellSequenceComplete += HandleGlobalSpell;
        }

        /// <summary>
        /// Méthode déléguée qui reçoit l'événement d'invocation.
        /// Appelle maintenant le UnitSpawner pour gérer la logique.
        /// </summary>
        public void HandleCharacterInvocation(CharacterData_SO characterData, int perfectCount)
        {
            Debug.Log($"[GameplayManager] Tentative d'invocation reçue pour {characterData.DisplayName}. Délégation à UnitSpawner.");
            // On délègue TOUTE la logique au spawner.
            unitSpawner.TrySpawnUnit(characterData, perfectCount);
        }

        /// <summary>
        /// Délègue l'exécution du sort au GlobalSpellManager.
        /// </summary>
        void HandleGlobalSpell(GlobalSpellData_SO spellData, int perfectCount)
        {
            Debug.Log($"[GameplayManager] Tentative de sort reçue pour {spellData.DisplayName}. Délégation à GlobalSpellManager.");
            // On délègue TOUTE la logique au manager de sorts.
            globalSpellManager.TryExecuteSpell(spellData, perfectCount);
        }
        
        private void HandleCombatDetection(Unit attacker, Unit target, int damage)
        {
            bool isCrossTeamCombat = (attacker is EnemyUnit && target is AllyUnit) || (attacker is AllyUnit && target is EnemyUnit);
            if (isCrossTeamCombat) TriggerCombatState();
        }

        private void HandleCombatDetection(Building target, Unit attacker)
        {
            bool isCrossTeamCombat = (attacker is EnemyUnit && target is PlayerBuilding);
            if (isCrossTeamCombat) TriggerCombatState();
        }

        private void TriggerCombatState()
        {
            var gameStateManager = FindObjectOfType<GameStateManager>();
            if (gameStateManager != null && gameStateManager.CurrentState == GameStateManager.GameState.Exploration)
            {
                gameStateManager.UpdateGameState(GameStateManager.GameState.Combat);
            }
        }
        
        private void OnDestroy()
        {
            if (sequenceController != null)
            {
                SequenceController.OnCharacterInvocationSequenceComplete -= HandleCharacterInvocation;
                SequenceController.OnGlobalSpellSequenceComplete -= HandleGlobalSpell;
            }
            Unit.OnUnitAttacked -= HandleCombatDetection;
            Building.OnBuildingAttackedByUnit -= HandleCombatDetection;
            Debug.Log($"[GameplayManager] Destruction du GameplayManager pour le niveau : {currentLevelData.DisplayName}", this);
        }
    }
}

// --- FILE: Scripts/Gameplay/GlobalSpellManager.cs ---
﻿namespace Gameplay
{
    using UnityEngine;
using System.Collections.Generic;
using ScriptableObjects;
using System;

/// <summary>
/// Gère le chargement, les cooldowns et l'exécution des sorts globaux.
/// Centralise toute la logique liée aux sorts pour alléger le GameplayManager.
/// </summary>
public class GlobalSpellManager : MonoBehaviour
{
    [Header("Configuration")]
    [Tooltip("Chemin dans le dossier Resources pour charger les sorts globaux.")]
    [SerializeField] private string globalSpellsResourcePath = "Data/GlobalSpells";

    // Références aux managers
    private GoldController _goldController;
    private MusicManager _musicManager;

    // Données des sorts
    private List<GlobalSpellData_SO> _availableSpells = new List<GlobalSpellData_SO>();
    private Dictionary<string, float> _spellCooldowns = new Dictionary<string, float>();

    // Propriétés publiques pour l'UI et autres systèmes
    public IReadOnlyList<GlobalSpellData_SO> AvailableSpells => _availableSpells;
    public IReadOnlyDictionary<string, float> SpellCooldowns => _spellCooldowns;

    public static event Action<IReadOnlyList<GlobalSpellData_SO>> OnGlobalSpellsLoaded;

    void Awake()
    {
        // Initialisation des références via les singletons
        _goldController = GoldController.Instance;
        _musicManager = MusicManager.Instance;

        if (_goldController == null)
            Debug.LogError("[GlobalSpellManager] GoldController.Instance est introuvable !", this);
        if (_musicManager == null)
            Debug.LogError("[GlobalSpellManager] MusicManager.Instance est introuvable !", this);
    }

    /// <summary>
    /// Charge tous les ScriptableObjects de sorts depuis le chemin spécifié.
    /// Doit être appelée par le GameplayManager lors de l'initialisation du niveau.
    /// </summary>
    public void LoadSpells()
    {
        GlobalSpellData_SO[] spells = Resources.LoadAll<GlobalSpellData_SO>(globalSpellsResourcePath);
        _availableSpells = new List<GlobalSpellData_SO>(spells);
        Debug.Log($"[GlobalSpellManager] Chargé {_availableSpells.Count} sorts globaux depuis '{globalSpellsResourcePath}'.");
        
        // Notifie l'UI ou d'autres systèmes que les sorts sont prêts
        OnGlobalSpellsLoaded?.Invoke(_availableSpells);
    }

    /// <summary>
    /// Tente d'exécuter un sort global. Gère toutes les vérifications.
    /// </summary>
    /// <param name="spellData">Le sort à lancer.</param>
    /// <param name="perfectCount">Le nombre d'inputs parfaits pour les bonus.</param>
    public void TryExecuteSpell(GlobalSpellData_SO spellData, int perfectCount)
    {
        if (spellData == null)
        {
            Debug.LogWarning("[GlobalSpellManager] Tentative d'exécution d'un sort nul.");
            return;
        }

        // 1. Vérification du Cooldown
        if (_spellCooldowns.ContainsKey(spellData.SpellID) && Time.time < _spellCooldowns[spellData.SpellID])
        {
            Debug.Log($"[GlobalSpellManager] Le sort '{spellData.DisplayName}' est en cooldown.");
            // Feedback sonore négatif possible ici
            return;
        }
        
        // Check and spend momentum
        if (!MomentumManager.Instance.TrySpendMomentum(spellData.MomentumCost))
        {
            Debug.Log($"[GlobalSpellManager] Lancement de '{spellData.DisplayName}' échoué : Momentum insuffisant.");
            return;
        }
        
        // 2. Vérification de l'or
        if (_goldController.GetCurrentGold() < spellData.GoldCost)
        {
            Debug.LogWarning($"[GlobalSpellManager] Pas assez d'or pour lancer {spellData.DisplayName}. Requis : {spellData.GoldCost}, Actuel : {_goldController.GetCurrentGold()}");
            return;
        }

        // Si tout est bon :
        // 3. Dépenser l'or
        _goldController.RemoveGold(spellData.GoldCost);

        // 4. Exécuter l'effet du sort
        if (spellData.SpellEffect != null)
        {
            // L'effet du sort est un scriptable object, il est autonome.
            // On lui passe le GameObject du manager pour le contexte (ex: coroutines, sons).
            spellData.SpellEffect.ExecuteEffect(this.gameObject, perfectCount);
            Debug.Log($"[GlobalSpellManager] Sort '{spellData.DisplayName}' exécuté.");

            // Jouer le son d'activation si défini
            if (spellData.ActivationSound != null && spellData.ActivationSound.IsValid())
            {
                spellData.ActivationSound.Post(gameObject);
            }
        }

        // 5. Mettre le sort en cooldown
        float cooldownInSeconds = spellData.BeatCooldown * (_musicManager?.GetBeatDuration() ?? 1.0f);
        _spellCooldowns[spellData.SpellID] = Time.time + cooldownInSeconds;
        Debug.Log($"[GlobalSpellManager] Cooldown pour {spellData.DisplayName} défini à {cooldownInSeconds:F2} secondes.");
    }
}
}

// --- FILE: Scripts/Gameplay/TriggerZone.cs ---
﻿namespace Gameplay
{
    using UnityEngine;
    using System;

    [RequireComponent(typeof(Collider))]
    public class TriggerZone : MonoBehaviour
    {
        [Tooltip("ID unique pour cette zone, utilisé par le LevelScenarioManager.")]
        public string ZoneID;

        public static event Action<string> OnZoneEntered;

        private bool _hasBeenTriggered = false;

        private void Awake()
        {
            Collider col = GetComponent<Collider>();
            if (!col.isTrigger)
            {
                Debug.LogWarning(
                    $"[TriggerZone] Le collider sur {gameObject.name} n'est pas réglé sur 'Is Trigger'. Correction automatique.",
                    this);
                col.isTrigger = true;
            }
        }

        private void OnTriggerEnter(Collider other)
        {
            if (_hasBeenTriggered) return;

            // Vérifier si l'objet entrant est une unité du joueur (ajuster le tag si nécessaire)
            if (other.CompareTag("PlayerUnit")) // Assurez-vous que vos unités alliées ont ce tag
            {
                _hasBeenTriggered = true;
                Debug.Log($"[TriggerZone] L'unité joueur '{other.name}' est entrée dans la zone '{ZoneID}'.", this);
                OnZoneEntered?.Invoke(ZoneID);
            }
        }
    }
}

// --- FILE: Scripts/Gameplay/UnitSpawner.cs ---
﻿namespace Gameplay
{
   using UnityEngine;
    using System.Collections.Generic;
    using System.Linq;
    using ScriptableObjects;

    /// <summary>
    /// Gère la logique spécifique de l'invocation d'unités,
    /// incluant la vérification des coûts, des cooldowns et la recherche de tuiles de spawn.
    /// </summary>
    public class UnitSpawner : MonoBehaviour
    {
        [Header("Configuration des Points de Spawn")]
        [Tooltip("Point de spawn par défaut si aucun bâtiment joueur n'est trouvé.")]
        [SerializeField] private Transform defaultPlayerUnitSpawnPoint;

        // Références aux contrôleurs nécessaires
        private GoldController _goldController;
        private MusicManager _musicManager;

        // Dictionnaires pour gérer les cooldowns
        private Dictionary<string, float> _unitCooldowns = new Dictionary<string, float>();
        public IReadOnlyDictionary<string, float> UnitCooldowns => _unitCooldowns;

        void Awake()
        {
            // Initialisation des références
            _goldController = GoldController.Instance;
            _musicManager = MusicManager.Instance;

            if (_goldController == null)
                Debug.LogError("[UnitSpawner] GoldController.Instance est introuvable !", this);
            if (_musicManager == null)
                Debug.LogError("[UnitSpawner] MusicManager.Instance est introuvable !", this);
        }

        /// <summary>
        /// Tente d'invoquer un personnage. Gère toutes les vérifications nécessaires.
        /// </summary>
        /// <param name="characterData">Les données du personnage à invoquer.</param>
        /// <param name="perfectCount">Le nombre d'inputs parfaits pour d'éventuels bonus.</param>
        public void TrySpawnUnit(CharacterData_SO characterData, int perfectCount)
        {
            
            // Vérification des données du personnage
            if (characterData == null)
            {
                Debug.LogWarning("[UnitSpawner] Tentative d'invocation avec un CharacterData_SO nul.");
                return;
            }

            // 1. Vérification du Cooldown
            if (_unitCooldowns.ContainsKey(characterData.CharacterID) && Time.time < _unitCooldowns[characterData.CharacterID])
            {
                Debug.Log($"[UnitSpawner] L'unité '{characterData.CharacterID}' est en cooldown.");
                // On pourrait ajouter un feedback sonore "négatif" ici.
                return;
            }

            if (!MomentumManager.Instance.TrySpendMomentum(characterData.MomentumCost))
            {
                Debug.Log($"Invocation de '{characterData.DisplayName}' échouée : Momentum insuffisant.");
                return; // Échec de l'invocation
            }

            // 2. Vérification de l'or
            if (_goldController.GetCurrentGold() < characterData.GoldCost)
            {
                Debug.LogWarning($"[UnitSpawner] Pas assez d'or pour invoquer {characterData.DisplayName}. Requis : {characterData.GoldCost}, Actuel : {_goldController.GetCurrentGold()}");
                return;
            }

            // 3. Trouver une tuile de spawn valide
            Tile spawnTile = FindValidSpawnTile();
            if (spawnTile == null)
            {
                Debug.LogError($"[UnitSpawner] Impossible d'invoquer {characterData.DisplayName}: Aucune tuile de spawn valide n'a été trouvée.");
                return;
            }
            
            // Si toutes les conditions sont remplies :
            // 4. Dépenser l'or
            _goldController.RemoveGold(characterData.GoldCost);
            Debug.Log($"[UnitSpawner] Or dépensé : {characterData.GoldCost}. Or restant : {_goldController.GetCurrentGold()}");
            
            // 5. Instancier et initialiser l'unité
            Vector3 spawnPosition = spawnTile.transform.position + Vector3.up * 0.1f; // Léger offset Y
            GameObject unitGO = Instantiate(characterData.GameplayUnitPrefab, spawnPosition, Quaternion.identity);
            
            Unit newUnit = unitGO.GetComponentInChildren<Unit>(true);
            if (newUnit != null)
            {
                newUnit.InitializeFromCharacterData(characterData);
                if (characterData.MomentumGainOnInvoke > 0)
                {
                    MomentumManager.Instance.AddMomentum(characterData.MomentumGainOnInvoke);
                }
                else {
                    Debug.Log($"[UnitSpawner] Pas de gain de Momentum à l'invocation pour {characterData.DisplayName}.");
                }

                Debug.Log($"[UnitSpawner] Unité {characterData.DisplayName} invoquée sur la tuile ({spawnTile.column},{spawnTile.row}).");
            }

            // 6. Mettre l'unité en cooldown
            float cooldownInSeconds = characterData.InvocationCooldown * (_musicManager?.GetBeatDuration() ?? 1.0f);
            _unitCooldowns[characterData.CharacterID] = Time.time + cooldownInSeconds;
            Debug.Log($"[UnitSpawner] Cooldown pour {characterData.DisplayName} défini à {cooldownInSeconds:F2} secondes.");
        }

        /// <summary>
        /// Cherche une tuile valide pour faire apparaître une unité alliée.
        /// Priorise les tuiles adjacentes au premier bâtiment joueur trouvé.
        /// Si aucun n'est trouvé, utilise le point de spawn par défaut.
        /// </summary>
        /// <returns>Une tuile valide ou null si aucune n'est trouvée.</returns>
        private Tile FindValidSpawnTile()
        {
            PlayerBuilding spawnerBuilding = FindFirstObjectByType<PlayerBuilding>();

            if (spawnerBuilding != null)
            {
                List<Tile> adjacentTiles = HexGridManager.Instance.GetAdjacentTiles(spawnerBuilding.GetOccupiedTile());
                foreach (Tile tile in adjacentTiles.OrderBy(t => Random.value)) // Randomise la recherche
                {
                    if (IsTileValidForSpawn(tile))
                    {
                        return tile;
                    }
                }
            }
            
            // Fallback si aucun bâtiment joueur ou aucune tuile adjacente n'est libre
            if (defaultPlayerUnitSpawnPoint != null)
            {
                Debug.LogWarning("[UnitSpawner] Aucun PlayerBuilding trouvé ou aucune tuile adjacente libre. Tentative de spawn au point par défaut.");
                Tile spawnTile = HexGridManager.Instance.GetClosestTile(defaultPlayerUnitSpawnPoint.position);
                if (IsTileValidForSpawn(spawnTile))
                {
                    return spawnTile;
                }
            }

            return null;
        }

        /// <summary>
        /// Vérifie si une tuile est valide pour le spawn (ni occupée, ni réservée, et de type Ground).
        /// </summary>
        private bool IsTileValidForSpawn(Tile tile)
        {
            return tile != null && !tile.IsOccupied && !tile.IsReserved && tile.tileType == TileType.Ground;
        }
    }
}

// --- FILE: Scripts/Hub/HubManager.cs ---
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System.Collections.Generic;
using UnityEngine.Events;
using System.Linq;
using ScriptableObjects;
using System.Collections;
using UnityEngine.InputSystem;

public class HubManager : MonoBehaviour
{
    
    public static HubManager Instance { get; private set; }
    
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Debug.LogWarning("[HubManager] Une autre instance de HubManager existe déjà. Destruction de la nouvelle instance.");
            Destroy(gameObject);
        }
    }
    [Header("UI Panels")]
    [SerializeField] private GameObject panelMainHub;
    [SerializeField] private GameObject panelLevelSelection;
    [SerializeField] private GameObject panelTeamManagement;

    [Header("UI Elements - Global Hub Info (Optionnel)")]
    [SerializeField] private TextMeshProUGUI textCurrency;
    [SerializeField] private TextMeshProUGUI textExperience;
    [SerializeField] private Button buttonBackToMainMenu;
  	[Header("Debug Options")]
    [Tooltip("Liste des SO d'équipement à donner au joueur via le bouton de débogage.")]
    [SerializeField] private List<EquipmentData_SO> testEquipmentToGive;
 	[Header("UI Dynamique du Hub")]
    [SerializeField] private TextMeshProUGUI hubTitleText;
    [SerializeField] private CanvasGroup hubTitleCanvasGroup;
    [SerializeField] private float titleFadeDuration = 0.2f;
    [System.Serializable]
    public class HubPointOfInterest
    {
        public string Name; 
        public HubViewpoint Viewpoint;
        public GameObject UIPanel;
    }

    [Header("Navigation & Points d'Intérêt")]
    [Tooltip("Configurez ici les points d'intérêt du Hub. L'ordre dans la liste définit l'ordre de navigation.")]
    [SerializeField] private List<HubPointOfInterest> hubPointsOfInterest = new List<HubPointOfInterest>();
    private bool _hubControlsActive = true; 

    private HubCameraManager _hubCameraManager;
    private bool _isTransitioning = false;
    private HubViewpoint _currentViewpoint = HubViewpoint.General;
    
    // Variables pour la gestion de l'input
    private float _navigationCooldown = 0.2f; // Empêche la navigation trop rapide
    private float _lastNavigationTime = 0f;

    void Start()
    {
        _hubCameraManager = HubCameraManager.Instance; 
        if (_hubCameraManager == null)
        {
            Debug.LogError("[HubManager] HubCameraManager.Instance non trouvé ! La navigation caméra ne fonctionnera pas.");
        }

        if (GameManager.Instance == null || PlayerDataManager.Instance == null /* ... etc */)
        {
            Debug.LogError("[HubManager] Managers globaux non trouvés!");
            enabled = false;
            return;
        }
        Debug.Log("[HubManager] Initialisé.");
        //GameManager.Instance.SetState(GameState.Hub);

        if (buttonBackToMainMenu != null) buttonBackToMainMenu.onClick.AddListener(GoBackToMainMenu);

        UpdateCurrencyDisplay(PlayerDataManager.Instance.Data.Currency);
        UpdateExperienceDisplay(PlayerDataManager.Instance.Data.Experience);
        PlayerDataManager.OnCurrencyChanged += UpdateCurrencyDisplay;
        PlayerDataManager.OnExperienceGained += UpdateExperienceDisplay;
 		if (hubTitleCanvasGroup != null)
        {
            UpdateTitle();
            hubTitleCanvasGroup.alpha = 1f;
        }
        _currentViewpoint = HubViewpoint.General;
        ShowCorrectPanelForCurrentView();
    }
	
    private void UpdateTitle()
    {
        if (hubTitleText == null) return;

        switch (_currentViewpoint)
        {
            case HubViewpoint.General:
                hubTitleText.text = "GENERAL";
                break;
            case HubViewpoint.LevelSelection:
                hubTitleText.text = "LEVEL SELECTION";
                break;
            case HubViewpoint.TeamManagement:
                hubTitleText.text = "TEAM MANAGEMENT";
                break;
        }
    }

	private IEnumerator FadeTitle(bool fadeIn)
    {
        if (hubTitleCanvasGroup == null) yield break;

        float startAlpha = hubTitleCanvasGroup.alpha;
        float endAlpha = fadeIn ? 1f : 0f;
        float elapsedTime = 0f;

        while (elapsedTime < titleFadeDuration)
        {
            elapsedTime += Time.unscaledDeltaTime;
            hubTitleCanvasGroup.alpha = Mathf.Lerp(startAlpha, endAlpha, elapsedTime / titleFadeDuration);
            yield return null;
        }

        hubTitleCanvasGroup.alpha = endAlpha;
    }
    
    private void OnDestroy()
    {
        if (PlayerDataManager.Instance != null)
        {
            PlayerDataManager.OnCurrencyChanged -= UpdateCurrencyDisplay;
            PlayerDataManager.OnExperienceGained -= UpdateExperienceDisplay;
        }
    }

    void Update()
    {
        if (_isTransitioning) return;

        HandleInputSystemNavigation();
    }

    private void HandleInputSystemNavigation()
    {
        if (hubPointsOfInterest.Count == 0) return;
        
        // Ne pas traiter les inputs si un panel de section est actif
        if (IsSectionPanelActive()) return;
        
        // Vérifier le cooldown pour éviter la navigation trop rapide
        if (Time.time - _lastNavigationTime < _navigationCooldown) return;

        // Récupérer l'InputManager
        var inputManager = InputManager.Instance;
        if (inputManager == null) return;

        // Récupérer la valeur de navigation (Vector2)
        Vector2 navigationInput = inputManager.UIActions.Navigate.ReadValue<Vector2>();
        HubViewpoint nextView = _currentViewpoint;

        // Navigation horizontale uniquement (axe X)
        if (Mathf.Abs(navigationInput.x) > 0.5f) // Seuil pour éviter les inputs accidentels
        {
            switch (_currentViewpoint)
            {
                case HubViewpoint.General:
                    if (navigationInput.x < 0) // Gauche
                        nextView = HubViewpoint.LevelSelection;
                    else if (navigationInput.x > 0) // Droite
                        nextView = HubViewpoint.TeamManagement;
                    break;

                case HubViewpoint.LevelSelection:
                    if (navigationInput.x > 0) // Droite depuis la gauche = retour au centre
                        nextView = HubViewpoint.General;
                    break;

                case HubViewpoint.TeamManagement:
                    if (navigationInput.x < 0) // Gauche depuis la droite = retour au centre
                        nextView = HubViewpoint.General;
                    break;
            }

            // Si la vue a changé, on lance la transition
            if (nextView != _currentViewpoint)
            {
                _lastNavigationTime = Time.time;
                StartCoroutine(TransitionToView(nextView));
            }
        }

        // Gestion de l'action Submit (validation)
        if (_currentViewpoint != HubViewpoint.General && inputManager.UIActions.Submit.WasPressedThisFrame())
        {
            StartCoroutine(FadeTitle(false));
            ShowCorrectPanelForCurrentView();
        }
    }
    
    private bool IsSectionPanelActive()
    {
        // Vérifier si un des panels de section est actif
        if (_currentViewpoint != HubViewpoint.General)
        {
            if (!_hubControlsActive)
            {
                // Si les contrôles du hub sont désactivés, on ne permet pas la navigation
                return true;
            }
            var point = hubPointsOfInterest.FirstOrDefault(p => p.Viewpoint == _currentViewpoint);
            if (point != null && point.UIPanel != null && point.UIPanel.activeSelf)
            {
                return true;
            }
            
        }
        return false;
    }

 	private IEnumerator TransitionToView(HubViewpoint newView)
    {
        _isTransitioning = true;
        
        HideAllSectionPanels();
		if (_currentViewpoint != newView)
        {
            yield return StartCoroutine(FadeTitle(false));
        }
        // On met à jour l'état logique immédiatement
        _currentViewpoint = newView;
            
        // Demander la transition de caméra et attendre qu'elle soit finie
        yield return StartCoroutine(_hubCameraManager.TransitionTo(newView));
        
        _isTransitioning = false;
        UpdateTitle(); 
        yield return StartCoroutine(FadeTitle(true));
       
        if (_currentViewpoint == HubViewpoint.General)
        {
            ShowCorrectPanelForCurrentView();
        }
    }

    private void ShowCorrectPanelForCurrentView()
    {
        HideAllSectionPanels();

        if (_currentViewpoint == HubViewpoint.General)
        {
            if (panelMainHub != null) panelMainHub.SetActive(true);
        }
        else
        {
            // Trouver le point d'intérêt correspondant à la vue actuelle et activer son panel
            var point = hubPointsOfInterest.FirstOrDefault(p => p.Viewpoint == _currentViewpoint);
            if (point != null && point.UIPanel != null)
            {
                point.UIPanel.SetActive(true);
            }
        }
    }
    
    private void HideAllSectionPanels()
    {
        if (panelMainHub != null) panelMainHub.SetActive(false);
        foreach (var point in hubPointsOfInterest)
        {
            point.UIPanel?.SetActive(false);
        }
    }
    
    public void GoToGeneralView()
    {
        if (_isTransitioning) return;
        StartCoroutine(TransitionToView(HubViewpoint.General));
    }

    private void UpdateCurrencyDisplay(int newAmount)
    {
        if (textCurrency != null) textCurrency.text = $"Monnaie: {newAmount}";
    }

    private void UpdateExperienceDisplay(int newAmount)
    {
        if (textExperience != null) textExperience.text = $"XP: {newAmount}";
    }

    public void StartLevel(LevelData_SO levelData)
    {
        if (levelData == null) { Debug.LogError("[HubManager] LevelData_SO est null."); return; }
        GameManager.Instance.LoadLevel(levelData);
    }

    public void GoBackToMainMenu()
    {	
        GameManager.Instance?.LoadMainMenu();
    }

 	public void OnDebugAddItemsClicked()
    {
        if (testEquipmentToGive == null || testEquipmentToGive.Count == 0)
        {
            Debug.LogWarning("[HubManager] La liste 'testEquipmentToGive' est vide. Aucun item à ajouter.");
            return;
        }

        if (PlayerDataManager.Instance != null)
        {
            // Extraire les IDs de la liste de ScriptableObjects
            List<string> idsToUnlock = testEquipmentToGive.Select(item => item.EquipmentID).ToList();
            
            // Appeler la nouvelle méthode du PlayerDataManager
            PlayerDataManager.Instance.UnlockMultipleEquipment(idsToUnlock);

            Debug.Log($"[HubManager] Tentative de déblocage de {idsToUnlock.Count} items de test.");
            
            // On peut ajouter un petit feedback visuel simple
            // par exemple en désactivant le bouton après usage.
            // (Logique plus avancée : rafraîchir l'UI de l'inventaire si elle est visible).
        }
        else
        {
            Debug.LogError("[HubManager] PlayerDataManager.Instance non trouvé ! Impossible d'ajouter les items.");
        }
    }

	/// <summary>
    /// Appelée par le bouton de débogage pour ajouter de l'XP à tous les personnages de l'équipe active.
    /// </summary>
    public void OnDebugAddXPClicked()
    {
        // Montant d'XP à donner à chaque fois, vous pouvez l'ajuster
        const int xpToGive = 100;

        if (TeamManager.Instance == null || PlayerDataManager.Instance == null)
        {
            Debug.LogError("[HubManager] TeamManager ou PlayerDataManager non disponible ! Impossible d'ajouter de l'XP.");
            return;
        }

        List<CharacterData_SO> activeTeam = TeamManager.Instance.ActiveTeam;
        if (activeTeam.Count == 0)
        {
            Debug.LogWarning("[HubManager] L'équipe active est vide. Aucun XP n'a été ajouté.");
            return;
        }

        Debug.Log($"[HubManager] Ajout de {xpToGive} XP à {activeTeam.Count(c => c != null)} personnage(s) de l'équipe active...");

        // Parcourir chaque personnage de l'équipe active et lui ajouter de l'XP
        foreach (CharacterData_SO character in activeTeam)
        {
            if (character != null)
            {
                PlayerDataManager.Instance.AddXPToCharacter(character.CharacterID, xpToGive);
                // Le log de la montée de niveau est déjà dans PlayerDataManager.
            }
        }

        Debug.Log("[HubManager] Distribution d'XP terminée.");
        
        // Optionnel : Mettre à jour l'UI si elle est ouverte et affiche des niveaux/XP.
        // Si vous êtes sur le panel d'équipement, il faudrait le notifier pour qu'il se rafraîchisse.
        // Pour l'instant, quitter et rouvrir le panel suffira pour voir les changements.
    }
    
    public void DisableHubControls()
    {
        _hubControlsActive = false;
    }

    public void EnableHubControls()
    {
        _hubControlsActive = true;
    }
}

// --- FILE: Scripts/Input/GameControls.cs ---
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by com.unity.inputsystem:InputActionCodeGenerator
//     version 1.14.0
//     from Assets/Input/GameControls.inputactions
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

/// <summary>
/// Provides programmatic access to <see cref="InputActionAsset" />, <see cref="InputActionMap" />, <see cref="InputAction" /> and <see cref="InputControlScheme" /> instances defined in asset "Assets/Input/GameControls.inputactions".
/// </summary>
/// <remarks>
/// This class is source generated and any manual edits will be discarded if the associated asset is reimported or modified.
/// </remarks>
/// <example>
/// <code>
/// using namespace UnityEngine;
/// using UnityEngine.InputSystem;
///
/// // Example of using an InputActionMap named "Player" from a UnityEngine.MonoBehaviour implementing callback interface.
/// public class Example : MonoBehaviour, MyActions.IPlayerActions
/// {
///     private MyActions_Actions m_Actions;                  // Source code representation of asset.
///     private MyActions_Actions.PlayerActions m_Player;     // Source code representation of action map.
///
///     void Awake()
///     {
///         m_Actions = new MyActions_Actions();              // Create asset object.
///         m_Player = m_Actions.Player;                      // Extract action map object.
///         m_Player.AddCallbacks(this);                      // Register callback interface IPlayerActions.
///     }
///
///     void OnDestroy()
///     {
///         m_Actions.Dispose();                              // Destroy asset object.
///     }
///
///     void OnEnable()
///     {
///         m_Player.Enable();                                // Enable all actions within map.
///     }
///
///     void OnDisable()
///     {
///         m_Player.Disable();                               // Disable all actions within map.
///     }
///
///     #region Interface implementation of MyActions.IPlayerActions
///
///     // Invoked when "Move" action is either started, performed or canceled.
///     public void OnMove(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnMove: {context.ReadValue&lt;Vector2&gt;()}");
///     }
///
///     // Invoked when "Attack" action is either started, performed or canceled.
///     public void OnAttack(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnAttack: {context.ReadValue&lt;float&gt;()}");
///     }
///
///     #endregion
/// }
/// </code>
/// </example>
public partial class @GameControls: IInputActionCollection2, IDisposable
{
    /// <summary>
    /// Provides access to the underlying asset instance.
    /// </summary>
    public InputActionAsset asset { get; }

    /// <summary>
    /// Constructs a new instance.
    /// </summary>
    public @GameControls()
    {
        asset = InputActionAsset.FromJson(@"{
    ""name"": ""GameControls"",
    ""maps"": [
        {
            ""name"": ""Gameplay"",
            ""id"": ""2d4654ac-2588-47b1-8884-72ee76f1dfd0"",
            ""actions"": [
                {
                    ""name"": ""RhythmInput_Left"",
                    ""type"": ""Button"",
                    ""id"": ""648bbd19-3e04-40e6-8235-c89e964512cb"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""RhythmInput_Right"",
                    ""type"": ""Button"",
                    ""id"": ""63c5773e-bf19-4352-a09b-5fe1350446de"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""RhythmInput_Down"",
                    ""type"": ""Button"",
                    ""id"": ""1193f32c-0324-4436-b22a-f7644d46f8fd"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""PlaceBanner"",
                    ""type"": ""Button"",
                    ""id"": ""2df110da-0d56-4d3a-8573-a9eb8cd53e3f"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""CycleTarget"",
                    ""type"": ""Button"",
                    ""id"": ""d68aede0-9c53-4b39-98d6-d6eacf57ac72"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""ToggleCameraLock"",
                    ""type"": ""Button"",
                    ""id"": ""c664009b-68ac-4ea4-9fdb-cbd2b8549da4"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""CameraZoom"",
                    ""type"": ""Button"",
                    ""id"": ""3a036d70-0b64-443e-9f0e-c58fe60d5a03"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""CameraMove"",
                    ""type"": ""Value"",
                    ""id"": ""24b7b11b-d69c-48c0-bf16-5bf594b405fd"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""CameraPan"",
                    ""type"": ""Value"",
                    ""id"": ""fbc61d84-f26d-4e8b-b21c-bc2bd422a8cd"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""TriggerUi"",
                    ""type"": ""Button"",
                    ""id"": ""3c7e19f3-c3ec-4c83-801e-922f803d1e47"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""ac4054cc-f579-4ec3-a82c-4bfabbdbd95a"",
                    ""path"": ""<Keyboard>/x"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""RhythmInput_Left"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""b3a85196-fbd7-4ce6-8e2a-6da7314fceeb"",
                    ""path"": ""<Gamepad>/buttonWest"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""RhythmInput_Left"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""50649b96-d950-4495-a4f5-615ffcbd08e3"",
                    ""path"": ""<Keyboard>/v"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""RhythmInput_Right"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""25ab5b68-7fd9-4536-8189-88659265ad57"",
                    ""path"": ""<Gamepad>/buttonEast"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""RhythmInput_Right"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""a88b1ae0-f7f3-42e6-9395-41dfe330dd97"",
                    ""path"": ""<Gamepad>/buttonSouth"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""RhythmInput_Down"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""41d76315-2cef-4fbe-8784-bd5c1b428d69"",
                    ""path"": ""<Keyboard>/c"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""RhythmInput_Down"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""ec7c79ca-4cc0-405c-a5be-1e8a9fd2fc12"",
                    ""path"": ""<Mouse>/leftButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""PlaceBanner"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""35b0aabf-84cc-47bf-9627-0fee925f073e"",
                    ""path"": ""<Gamepad>/dpad/down"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""PlaceBanner"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""1D Axis"",
                    ""id"": ""a95013db-c4d1-4eeb-b613-b39b149aeaf7"",
                    ""path"": ""1DAxis"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraZoom"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""negative"",
                    ""id"": ""6677cb1e-2a3c-4c08-bfd3-ec8ad8a7bc5f"",
                    ""path"": ""<Mouse>/scroll/down"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraZoom"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""positive"",
                    ""id"": ""4ff1b947-c4d4-4aac-ab75-fdb5cc2834e1"",
                    ""path"": ""<Mouse>/scroll/up"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraZoom"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""1D Axis"",
                    ""id"": ""9839acbb-b4f8-4947-879e-7f1150d6b1a3"",
                    ""path"": ""1DAxis"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraZoom"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""negative"",
                    ""id"": ""912a2248-cdda-4900-9605-2d9f29479655"",
                    ""path"": ""<Gamepad>/leftTrigger"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraZoom"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""positive"",
                    ""id"": ""bb5fd19b-6701-4557-bdd2-4a3519887e1a"",
                    ""path"": ""<Gamepad>/rightTrigger"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraZoom"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""1D Axis"",
                    ""id"": ""c2bb4ff1-77a8-47f7-9771-cc34d36b64ba"",
                    ""path"": ""1DAxis"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CycleTarget"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""negative"",
                    ""id"": ""2aee24b3-8e61-4079-80ec-bad6ef63fc33"",
                    ""path"": ""<Gamepad>/dpad/left"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CycleTarget"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""positive"",
                    ""id"": ""ad4cd63e-cd19-4d9d-a297-ccb5774b2938"",
                    ""path"": ""<Gamepad>/dpad/right"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CycleTarget"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""One Modifier"",
                    ""id"": ""18d9e34b-549e-4827-87dc-8fed8d23b861"",
                    ""path"": ""OneModifier"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraPan"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""modifier"",
                    ""id"": ""18b27899-1dbb-4e13-a0d0-97156a1c9d84"",
                    ""path"": ""<Mouse>/rightButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraPan"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""binding"",
                    ""id"": ""531e82e7-3ade-4020-ad79-f5d46218eaa6"",
                    ""path"": ""<Mouse>/delta"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraPan"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": """",
                    ""id"": ""c6f25bb0-b6fd-40c5-9318-82d0399a1f39"",
                    ""path"": ""<Gamepad>/leftStickPress"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""ToggleCameraLock"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""ddcb90cd-2372-43f2-94fc-8b146ae4a9dd"",
                    ""path"": ""<Gamepad>/leftStick"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""CameraMove"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""18d44481-dad9-4c91-8e64-3afd3c6028f1"",
                    ""path"": ""<Keyboard>/rightBracket"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TriggerUi"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""59ef2554-949d-4e26-8118-df0b08313c1c"",
                    ""path"": ""<Gamepad>/buttonNorth"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TriggerUi"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""UI"",
            ""id"": ""d72966f5-7ab0-4012-9d2c-63771a5d2573"",
            ""actions"": [
                {
                    ""name"": ""Navigate"",
                    ""type"": ""Value"",
                    ""id"": ""001b3c36-1f5e-40d3-abf9-2d03ec373088"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""Submit"",
                    ""type"": ""Button"",
                    ""id"": ""2342f3fe-0f5f-459c-bd2b-b3fc85a2ae54"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Cancel"",
                    ""type"": ""Button"",
                    ""id"": ""7b3cfa6d-bca5-45b2-b45a-ba02acfdd2b7"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Point"",
                    ""type"": ""Value"",
                    ""id"": ""2a52c2d6-26f7-4c9e-a820-5edbd5bad977"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""Click"",
                    ""type"": ""Button"",
                    ""id"": ""b2e3c5de-debe-4161-9105-8a0a531b3639"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""a65dc81b-4477-40aa-99b1-218cc7f51a34"",
                    ""path"": ""<Gamepad>/buttonSouth"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Submit"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""14402926-5dae-4c51-9119-2e1e42261ab4"",
                    ""path"": ""<Keyboard>/enter"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Submit"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""b07f3919-f04d-48de-b1b5-b838a49accb3"",
                    ""path"": ""<Keyboard>/escape"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Cancel"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""03a7698c-dc36-44c9-8f0c-2eb9956bb6fc"",
                    ""path"": ""<Gamepad>/buttonEast"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Cancel"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""7b11af37-e79d-422c-9199-39a369de59f1"",
                    ""path"": ""<Mouse>/position"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Point"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""91c2f984-cafe-4b8f-8857-5742dc5093fa"",
                    ""path"": ""<Mouse>/leftButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Click"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""c404ca5a-8e39-49c3-82db-e799663b6e4f"",
                    ""path"": ""<Gamepad>/dpad"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""42ba3fcb-77b5-4c4b-a099-dbc1d1db2183"",
                    ""path"": ""<Gamepad>/leftStick"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""2D Vector"",
                    ""id"": ""ac53afcd-fa7e-4313-bcb7-08b62773efdb"",
                    ""path"": ""2DVector"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""47534a7c-65b9-4400-96c1-6cd629018024"",
                    ""path"": ""<Keyboard>/w"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""7fa4afdb-fe68-4683-95db-0922b7dd6d0d"",
                    ""path"": ""<Keyboard>/s"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""67306ba7-a56c-4928-b9d1-222ae1d777dc"",
                    ""path"": ""<Keyboard>/a"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""95d55052-289e-49e5-9dae-910afce6eca8"",
                    ""path"": ""<Keyboard>/d"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""2D Vector"",
                    ""id"": ""9fd020f9-b978-455a-89f0-3a0df8b6dc22"",
                    ""path"": ""2DVector"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""69a7b070-f8c9-4a89-b439-24e6902a48ba"",
                    ""path"": ""<Keyboard>/upArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""2fd01a50-26f6-4729-bd95-176f159667c1"",
                    ""path"": ""<Keyboard>/downArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""7a57c874-c29d-4b9b-affd-8d067c432068"",
                    ""path"": ""<Keyboard>/leftArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""adf45602-9b9a-4fe2-b386-043257257aec"",
                    ""path"": ""<Keyboard>/rightArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                }
            ]
        }
    ],
    ""controlSchemes"": []
}");
        // Gameplay
        m_Gameplay = asset.FindActionMap("Gameplay", throwIfNotFound: true);
        m_Gameplay_RhythmInput_Left = m_Gameplay.FindAction("RhythmInput_Left", throwIfNotFound: true);
        m_Gameplay_RhythmInput_Right = m_Gameplay.FindAction("RhythmInput_Right", throwIfNotFound: true);
        m_Gameplay_RhythmInput_Down = m_Gameplay.FindAction("RhythmInput_Down", throwIfNotFound: true);
        m_Gameplay_PlaceBanner = m_Gameplay.FindAction("PlaceBanner", throwIfNotFound: true);
        m_Gameplay_CycleTarget = m_Gameplay.FindAction("CycleTarget", throwIfNotFound: true);
        m_Gameplay_ToggleCameraLock = m_Gameplay.FindAction("ToggleCameraLock", throwIfNotFound: true);
        m_Gameplay_CameraZoom = m_Gameplay.FindAction("CameraZoom", throwIfNotFound: true);
        m_Gameplay_CameraMove = m_Gameplay.FindAction("CameraMove", throwIfNotFound: true);
        m_Gameplay_CameraPan = m_Gameplay.FindAction("CameraPan", throwIfNotFound: true);
        m_Gameplay_TriggerUi = m_Gameplay.FindAction("TriggerUi", throwIfNotFound: true);
        // UI
        m_UI = asset.FindActionMap("UI", throwIfNotFound: true);
        m_UI_Navigate = m_UI.FindAction("Navigate", throwIfNotFound: true);
        m_UI_Submit = m_UI.FindAction("Submit", throwIfNotFound: true);
        m_UI_Cancel = m_UI.FindAction("Cancel", throwIfNotFound: true);
        m_UI_Point = m_UI.FindAction("Point", throwIfNotFound: true);
        m_UI_Click = m_UI.FindAction("Click", throwIfNotFound: true);
    }

    ~@GameControls()
    {
        UnityEngine.Debug.Assert(!m_Gameplay.enabled, "This will cause a leak and performance issues, GameControls.Gameplay.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_UI.enabled, "This will cause a leak and performance issues, GameControls.UI.Disable() has not been called.");
    }

    /// <summary>
    /// Destroys this asset and all associated <see cref="InputAction"/> instances.
    /// </summary>
    public void Dispose()
    {
        UnityEngine.Object.Destroy(asset);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.bindingMask" />
    public InputBinding? bindingMask
    {
        get => asset.bindingMask;
        set => asset.bindingMask = value;
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.devices" />
    public ReadOnlyArray<InputDevice>? devices
    {
        get => asset.devices;
        set => asset.devices = value;
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.controlSchemes" />
    public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Contains(InputAction)" />
    public bool Contains(InputAction action)
    {
        return asset.Contains(action);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.GetEnumerator()" />
    public IEnumerator<InputAction> GetEnumerator()
    {
        return asset.GetEnumerator();
    }

    /// <inheritdoc cref="IEnumerable.GetEnumerator()" />
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Enable()" />
    public void Enable()
    {
        asset.Enable();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Disable()" />
    public void Disable()
    {
        asset.Disable();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.bindings" />
    public IEnumerable<InputBinding> bindings => asset.bindings;

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.FindAction(string, bool)" />
    public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
    {
        return asset.FindAction(actionNameOrId, throwIfNotFound);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.FindBinding(InputBinding, out InputAction)" />
    public int FindBinding(InputBinding bindingMask, out InputAction action)
    {
        return asset.FindBinding(bindingMask, out action);
    }

    // Gameplay
    private readonly InputActionMap m_Gameplay;
    private List<IGameplayActions> m_GameplayActionsCallbackInterfaces = new List<IGameplayActions>();
    private readonly InputAction m_Gameplay_RhythmInput_Left;
    private readonly InputAction m_Gameplay_RhythmInput_Right;
    private readonly InputAction m_Gameplay_RhythmInput_Down;
    private readonly InputAction m_Gameplay_PlaceBanner;
    private readonly InputAction m_Gameplay_CycleTarget;
    private readonly InputAction m_Gameplay_ToggleCameraLock;
    private readonly InputAction m_Gameplay_CameraZoom;
    private readonly InputAction m_Gameplay_CameraMove;
    private readonly InputAction m_Gameplay_CameraPan;
    private readonly InputAction m_Gameplay_TriggerUi;
    /// <summary>
    /// Provides access to input actions defined in input action map "Gameplay".
    /// </summary>
    public struct GameplayActions
    {
        private @GameControls m_Wrapper;

        /// <summary>
        /// Construct a new instance of the input action map wrapper class.
        /// </summary>
        public GameplayActions(@GameControls wrapper) { m_Wrapper = wrapper; }
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/RhythmInput_Left".
        /// </summary>
        public InputAction @RhythmInput_Left => m_Wrapper.m_Gameplay_RhythmInput_Left;
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/RhythmInput_Right".
        /// </summary>
        public InputAction @RhythmInput_Right => m_Wrapper.m_Gameplay_RhythmInput_Right;
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/RhythmInput_Down".
        /// </summary>
        public InputAction @RhythmInput_Down => m_Wrapper.m_Gameplay_RhythmInput_Down;
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/PlaceBanner".
        /// </summary>
        public InputAction @PlaceBanner => m_Wrapper.m_Gameplay_PlaceBanner;
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/CycleTarget".
        /// </summary>
        public InputAction @CycleTarget => m_Wrapper.m_Gameplay_CycleTarget;
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/ToggleCameraLock".
        /// </summary>
        public InputAction @ToggleCameraLock => m_Wrapper.m_Gameplay_ToggleCameraLock;
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/CameraZoom".
        /// </summary>
        public InputAction @CameraZoom => m_Wrapper.m_Gameplay_CameraZoom;
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/CameraMove".
        /// </summary>
        public InputAction @CameraMove => m_Wrapper.m_Gameplay_CameraMove;
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/CameraPan".
        /// </summary>
        public InputAction @CameraPan => m_Wrapper.m_Gameplay_CameraPan;
        /// <summary>
        /// Provides access to the underlying input action "Gameplay/TriggerUi".
        /// </summary>
        public InputAction @TriggerUi => m_Wrapper.m_Gameplay_TriggerUi;
        /// <summary>
        /// Provides access to the underlying input action map instance.
        /// </summary>
        public InputActionMap Get() { return m_Wrapper.m_Gameplay; }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Enable()" />
        public void Enable() { Get().Enable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Disable()" />
        public void Disable() { Get().Disable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.enabled" />
        public bool enabled => Get().enabled;
        /// <summary>
        /// Implicitly converts an <see ref="GameplayActions" /> to an <see ref="InputActionMap" /> instance.
        /// </summary>
        public static implicit operator InputActionMap(GameplayActions set) { return set.Get(); }
        /// <summary>
        /// Adds <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <param name="instance">Callback instance.</param>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c> or <paramref name="instance"/> have already been added this method does nothing.
        /// </remarks>
        /// <seealso cref="GameplayActions" />
        public void AddCallbacks(IGameplayActions instance)
        {
            if (instance == null || m_Wrapper.m_GameplayActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_GameplayActionsCallbackInterfaces.Add(instance);
            @RhythmInput_Left.started += instance.OnRhythmInput_Left;
            @RhythmInput_Left.performed += instance.OnRhythmInput_Left;
            @RhythmInput_Left.canceled += instance.OnRhythmInput_Left;
            @RhythmInput_Right.started += instance.OnRhythmInput_Right;
            @RhythmInput_Right.performed += instance.OnRhythmInput_Right;
            @RhythmInput_Right.canceled += instance.OnRhythmInput_Right;
            @RhythmInput_Down.started += instance.OnRhythmInput_Down;
            @RhythmInput_Down.performed += instance.OnRhythmInput_Down;
            @RhythmInput_Down.canceled += instance.OnRhythmInput_Down;
            @PlaceBanner.started += instance.OnPlaceBanner;
            @PlaceBanner.performed += instance.OnPlaceBanner;
            @PlaceBanner.canceled += instance.OnPlaceBanner;
            @CycleTarget.started += instance.OnCycleTarget;
            @CycleTarget.performed += instance.OnCycleTarget;
            @CycleTarget.canceled += instance.OnCycleTarget;
            @ToggleCameraLock.started += instance.OnToggleCameraLock;
            @ToggleCameraLock.performed += instance.OnToggleCameraLock;
            @ToggleCameraLock.canceled += instance.OnToggleCameraLock;
            @CameraZoom.started += instance.OnCameraZoom;
            @CameraZoom.performed += instance.OnCameraZoom;
            @CameraZoom.canceled += instance.OnCameraZoom;
            @CameraMove.started += instance.OnCameraMove;
            @CameraMove.performed += instance.OnCameraMove;
            @CameraMove.canceled += instance.OnCameraMove;
            @CameraPan.started += instance.OnCameraPan;
            @CameraPan.performed += instance.OnCameraPan;
            @CameraPan.canceled += instance.OnCameraPan;
            @TriggerUi.started += instance.OnTriggerUi;
            @TriggerUi.performed += instance.OnTriggerUi;
            @TriggerUi.canceled += instance.OnTriggerUi;
        }

        /// <summary>
        /// Removes <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <remarks>
        /// Calling this method when <paramref name="instance" /> have not previously been registered has no side-effects.
        /// </remarks>
        /// <seealso cref="GameplayActions" />
        private void UnregisterCallbacks(IGameplayActions instance)
        {
            @RhythmInput_Left.started -= instance.OnRhythmInput_Left;
            @RhythmInput_Left.performed -= instance.OnRhythmInput_Left;
            @RhythmInput_Left.canceled -= instance.OnRhythmInput_Left;
            @RhythmInput_Right.started -= instance.OnRhythmInput_Right;
            @RhythmInput_Right.performed -= instance.OnRhythmInput_Right;
            @RhythmInput_Right.canceled -= instance.OnRhythmInput_Right;
            @RhythmInput_Down.started -= instance.OnRhythmInput_Down;
            @RhythmInput_Down.performed -= instance.OnRhythmInput_Down;
            @RhythmInput_Down.canceled -= instance.OnRhythmInput_Down;
            @PlaceBanner.started -= instance.OnPlaceBanner;
            @PlaceBanner.performed -= instance.OnPlaceBanner;
            @PlaceBanner.canceled -= instance.OnPlaceBanner;
            @CycleTarget.started -= instance.OnCycleTarget;
            @CycleTarget.performed -= instance.OnCycleTarget;
            @CycleTarget.canceled -= instance.OnCycleTarget;
            @ToggleCameraLock.started -= instance.OnToggleCameraLock;
            @ToggleCameraLock.performed -= instance.OnToggleCameraLock;
            @ToggleCameraLock.canceled -= instance.OnToggleCameraLock;
            @CameraZoom.started -= instance.OnCameraZoom;
            @CameraZoom.performed -= instance.OnCameraZoom;
            @CameraZoom.canceled -= instance.OnCameraZoom;
            @CameraMove.started -= instance.OnCameraMove;
            @CameraMove.performed -= instance.OnCameraMove;
            @CameraMove.canceled -= instance.OnCameraMove;
            @CameraPan.started -= instance.OnCameraPan;
            @CameraPan.performed -= instance.OnCameraPan;
            @CameraPan.canceled -= instance.OnCameraPan;
            @TriggerUi.started -= instance.OnTriggerUi;
            @TriggerUi.performed -= instance.OnTriggerUi;
            @TriggerUi.canceled -= instance.OnTriggerUi;
        }

        /// <summary>
        /// Unregisters <param cref="instance" /> and unregisters all input action callbacks via <see cref="GameplayActions.UnregisterCallbacks(IGameplayActions)" />.
        /// </summary>
        /// <seealso cref="GameplayActions.UnregisterCallbacks(IGameplayActions)" />
        public void RemoveCallbacks(IGameplayActions instance)
        {
            if (m_Wrapper.m_GameplayActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        /// <summary>
        /// Replaces all existing callback instances and previously registered input action callbacks associated with them with callbacks provided via <param cref="instance" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c>, calling this method will only unregister all existing callbacks but not register any new callbacks.
        /// </remarks>
        /// <seealso cref="GameplayActions.AddCallbacks(IGameplayActions)" />
        /// <seealso cref="GameplayActions.RemoveCallbacks(IGameplayActions)" />
        /// <seealso cref="GameplayActions.UnregisterCallbacks(IGameplayActions)" />
        public void SetCallbacks(IGameplayActions instance)
        {
            foreach (var item in m_Wrapper.m_GameplayActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_GameplayActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    /// <summary>
    /// Provides a new <see cref="GameplayActions" /> instance referencing this action map.
    /// </summary>
    public GameplayActions @Gameplay => new GameplayActions(this);

    // UI
    private readonly InputActionMap m_UI;
    private List<IUIActions> m_UIActionsCallbackInterfaces = new List<IUIActions>();
    private readonly InputAction m_UI_Navigate;
    private readonly InputAction m_UI_Submit;
    private readonly InputAction m_UI_Cancel;
    private readonly InputAction m_UI_Point;
    private readonly InputAction m_UI_Click;
    /// <summary>
    /// Provides access to input actions defined in input action map "UI".
    /// </summary>
    public struct UIActions
    {
        private @GameControls m_Wrapper;

        /// <summary>
        /// Construct a new instance of the input action map wrapper class.
        /// </summary>
        public UIActions(@GameControls wrapper) { m_Wrapper = wrapper; }
        /// <summary>
        /// Provides access to the underlying input action "UI/Navigate".
        /// </summary>
        public InputAction @Navigate => m_Wrapper.m_UI_Navigate;
        /// <summary>
        /// Provides access to the underlying input action "UI/Submit".
        /// </summary>
        public InputAction @Submit => m_Wrapper.m_UI_Submit;
        /// <summary>
        /// Provides access to the underlying input action "UI/Cancel".
        /// </summary>
        public InputAction @Cancel => m_Wrapper.m_UI_Cancel;
        /// <summary>
        /// Provides access to the underlying input action "UI/Point".
        /// </summary>
        public InputAction @Point => m_Wrapper.m_UI_Point;
        /// <summary>
        /// Provides access to the underlying input action "UI/Click".
        /// </summary>
        public InputAction @Click => m_Wrapper.m_UI_Click;
        /// <summary>
        /// Provides access to the underlying input action map instance.
        /// </summary>
        public InputActionMap Get() { return m_Wrapper.m_UI; }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Enable()" />
        public void Enable() { Get().Enable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Disable()" />
        public void Disable() { Get().Disable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.enabled" />
        public bool enabled => Get().enabled;
        /// <summary>
        /// Implicitly converts an <see ref="UIActions" /> to an <see ref="InputActionMap" /> instance.
        /// </summary>
        public static implicit operator InputActionMap(UIActions set) { return set.Get(); }
        /// <summary>
        /// Adds <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <param name="instance">Callback instance.</param>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c> or <paramref name="instance"/> have already been added this method does nothing.
        /// </remarks>
        /// <seealso cref="UIActions" />
        public void AddCallbacks(IUIActions instance)
        {
            if (instance == null || m_Wrapper.m_UIActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_UIActionsCallbackInterfaces.Add(instance);
            @Navigate.started += instance.OnNavigate;
            @Navigate.performed += instance.OnNavigate;
            @Navigate.canceled += instance.OnNavigate;
            @Submit.started += instance.OnSubmit;
            @Submit.performed += instance.OnSubmit;
            @Submit.canceled += instance.OnSubmit;
            @Cancel.started += instance.OnCancel;
            @Cancel.performed += instance.OnCancel;
            @Cancel.canceled += instance.OnCancel;
            @Point.started += instance.OnPoint;
            @Point.performed += instance.OnPoint;
            @Point.canceled += instance.OnPoint;
            @Click.started += instance.OnClick;
            @Click.performed += instance.OnClick;
            @Click.canceled += instance.OnClick;
        }

        /// <summary>
        /// Removes <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <remarks>
        /// Calling this method when <paramref name="instance" /> have not previously been registered has no side-effects.
        /// </remarks>
        /// <seealso cref="UIActions" />
        private void UnregisterCallbacks(IUIActions instance)
        {
            @Navigate.started -= instance.OnNavigate;
            @Navigate.performed -= instance.OnNavigate;
            @Navigate.canceled -= instance.OnNavigate;
            @Submit.started -= instance.OnSubmit;
            @Submit.performed -= instance.OnSubmit;
            @Submit.canceled -= instance.OnSubmit;
            @Cancel.started -= instance.OnCancel;
            @Cancel.performed -= instance.OnCancel;
            @Cancel.canceled -= instance.OnCancel;
            @Point.started -= instance.OnPoint;
            @Point.performed -= instance.OnPoint;
            @Point.canceled -= instance.OnPoint;
            @Click.started -= instance.OnClick;
            @Click.performed -= instance.OnClick;
            @Click.canceled -= instance.OnClick;
        }

        /// <summary>
        /// Unregisters <param cref="instance" /> and unregisters all input action callbacks via <see cref="UIActions.UnregisterCallbacks(IUIActions)" />.
        /// </summary>
        /// <seealso cref="UIActions.UnregisterCallbacks(IUIActions)" />
        public void RemoveCallbacks(IUIActions instance)
        {
            if (m_Wrapper.m_UIActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        /// <summary>
        /// Replaces all existing callback instances and previously registered input action callbacks associated with them with callbacks provided via <param cref="instance" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c>, calling this method will only unregister all existing callbacks but not register any new callbacks.
        /// </remarks>
        /// <seealso cref="UIActions.AddCallbacks(IUIActions)" />
        /// <seealso cref="UIActions.RemoveCallbacks(IUIActions)" />
        /// <seealso cref="UIActions.UnregisterCallbacks(IUIActions)" />
        public void SetCallbacks(IUIActions instance)
        {
            foreach (var item in m_Wrapper.m_UIActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_UIActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    /// <summary>
    /// Provides a new <see cref="UIActions" /> instance referencing this action map.
    /// </summary>
    public UIActions @UI => new UIActions(this);
    /// <summary>
    /// Interface to implement callback methods for all input action callbacks associated with input actions defined by "Gameplay" which allows adding and removing callbacks.
    /// </summary>
    /// <seealso cref="GameplayActions.AddCallbacks(IGameplayActions)" />
    /// <seealso cref="GameplayActions.RemoveCallbacks(IGameplayActions)" />
    public interface IGameplayActions
    {
        /// <summary>
        /// Method invoked when associated input action "RhythmInput_Left" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnRhythmInput_Left(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "RhythmInput_Right" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnRhythmInput_Right(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "RhythmInput_Down" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnRhythmInput_Down(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "PlaceBanner" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnPlaceBanner(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "CycleTarget" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnCycleTarget(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "ToggleCameraLock" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnToggleCameraLock(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "CameraZoom" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnCameraZoom(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "CameraMove" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnCameraMove(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "CameraPan" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnCameraPan(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "TriggerUi" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnTriggerUi(InputAction.CallbackContext context);
    }
    /// <summary>
    /// Interface to implement callback methods for all input action callbacks associated with input actions defined by "UI" which allows adding and removing callbacks.
    /// </summary>
    /// <seealso cref="UIActions.AddCallbacks(IUIActions)" />
    /// <seealso cref="UIActions.RemoveCallbacks(IUIActions)" />
    public interface IUIActions
    {
        /// <summary>
        /// Method invoked when associated input action "Navigate" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnNavigate(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Submit" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnSubmit(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Cancel" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnCancel(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Point" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnPoint(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Click" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnClick(InputAction.CallbackContext context);
    }
}


// --- FILE: Scripts/MainMenu/MainMenuHexFloor.cs ---
using UnityEngine;
using System.Collections;
using Sirenix.OdinInspector;

public class MainMenuHexFloor : MonoBehaviour
{
    [Header("Hexagon Floor Settings")]
    [SerializeField] private GameObject hexagonTilePrefab;
    [SerializeField] private float hexSize = 1f;
    [Tooltip("Décalage Y pour positionner le sol à la bonne hauteur")]
    [SerializeField] private float yOffset = 0f;
    
    [Header("Grid Centering")]
    [SerializeField] private bool centerGrid = true;
    [Tooltip("Décale la grille pour qu'elle soit centrée sur ce GameObject")]
    [SerializeField] private bool useRectangularGrid = true;
    [ShowIf("useRectangularGrid")]
    [SerializeField] private int gridWidth = 10;
    [ShowIf("useRectangularGrid")]
    [SerializeField] private int gridHeight = 8;
    
    [Header("Spacing Settings")]
    [SerializeField] private float tileSpacing = 1.0f;
    [Tooltip("Espacement supplémentaire entre les tuiles (0 = tuiles collées)")]
    
    [HideIf("useRectangularGrid")]
    [SerializeField] private int circularRadius = 5;
    
    [Header("Visual Variety")]
    [SerializeField] private bool useRandomRotation = false;
    [ShowIf("useRandomRotation")]
    [SerializeField] private Vector3 randomRotationRange = new Vector3(0, 360, 0);
    
    [SerializeField] private bool useRandomScale = false;
    [ShowIf("useRandomScale")]
    [SerializeField] private Vector2 scaleRange = new Vector2(0.9f, 1.1f);
    
    [Header("Performance")]
    [SerializeField] private bool generateOnStart = true;
    [SerializeField] private bool useCoroutineGeneration = false;
    [ShowIf("useCoroutineGeneration")]
    [SerializeField] private int tilesPerFrame = 5;
    
    [Header("Debug")]
    [SerializeField] private bool showDebugInfo = false;
    
    private bool isGenerated = false;

    private void Start()
    {
        if (generateOnStart)
        {
            if (useCoroutineGeneration)
                StartCoroutine(GenerateFloorCoroutine());
            else
                GenerateFloor();
        }
    }

    [Button("Generate Floor", ButtonSizes.Large)]
    public void GenerateFloor()
    {
        if (hexagonTilePrefab == null)
        {
            Debug.LogError("[MainMenuHexFloor] Hexagon tile prefab is not assigned!");
            return;
        }

        ClearExistingFloor();

        if (useRectangularGrid)
            GenerateRectangularGrid();
        else
            GenerateCircularGrid();

        isGenerated = true;
        
        if (showDebugInfo)
            Debug.Log($"[MainMenuHexFloor] Floor generated with {transform.childCount} hexagon tiles");
    }

    [Button("Clear Floor", ButtonSizes.Medium)]
    public void ClearExistingFloor()
    {
        for (int i = transform.childCount - 1; i >= 0; i--)
        {
            if (Application.isPlaying)
                Destroy(transform.GetChild(i).gameObject);
            else
                DestroyImmediate(transform.GetChild(i).gameObject);
        }
        
        isGenerated = false;
    }

    private void GenerateRectangularGrid()
    {
        float hexWidth = hexSize * 1.5f + tileSpacing;
        float hexHeight = hexSize * Mathf.Sqrt(3f) * 0.5f + tileSpacing;
        
        Vector3 gridOffset = Vector3.zero;
        if (centerGrid)
        {
            float totalWidth = (gridWidth - 1) * hexWidth;
            float totalHeight = (gridHeight - 1) * hexHeight;
            gridOffset = new Vector3(-totalWidth * 0.5f, 0f, -totalHeight * 0.5f);
        }
        
        for (int row = 0; row < gridHeight; row++)
        {
            for (int col = 0; col < gridWidth; col++)
            {
                Vector3 position = CalculateHexPosition(col, row, hexSize, tileSpacing) + gridOffset + transform.position;
                CreateHexagonTile(position, col, row);
            }
        }
    }

    private void GenerateCircularGrid()
    {
        for (int q = -circularRadius; q <= circularRadius; q++)
        {
            int r1 = Mathf.Max(-circularRadius, -q - circularRadius);
            int r2 = Mathf.Min(circularRadius, -q + circularRadius);
            
            for (int r = r1; r <= r2; r++)
            {
                Vector3 position = AxialToWorldPosition(q, r, hexSize, tileSpacing) + transform.position;
                CreateHexagonTile(position, q, r);
            }
        }
    }

    private IEnumerator GenerateFloorCoroutine()
    {
        if (hexagonTilePrefab == null)
        {
            Debug.LogError("[MainMenuHexFloor] Hexagon tile prefab is not assigned!");
            yield break;
        }

        ClearExistingFloor();

        int tilesCreated = 0;
        
        float hexWidth = hexSize * 1.5f + tileSpacing;
        float hexHeight = hexSize * Mathf.Sqrt(3f) * 0.75f + tileSpacing;
        
        Vector3 gridOffset = Vector3.zero;
        if (centerGrid && useRectangularGrid)
        {
            float totalWidth = (gridWidth - 1) * hexWidth;
            float totalHeight = (gridHeight - 1) * hexHeight;
            gridOffset = new Vector3(-totalWidth * 0.5f, 0f, -totalHeight * 0.5f);
        }
        
        if (useRectangularGrid)
        {
            for (int row = 0; row < gridHeight; row++)
            {
                for (int col = 0; col < gridWidth; col++)
                {
                    Vector3 position = CalculateHexPosition(col, row, hexSize, tileSpacing) + gridOffset + transform.position;
                    CreateHexagonTile(position, col, row);
                    
                    tilesCreated++;
                    if (tilesCreated >= tilesPerFrame)
                    {
                        tilesCreated = 0;
                        yield return null;
                    }
                }
            }
        }
        else
        {
            for (int q = -circularRadius; q <= circularRadius; q++)
            {
                int r1 = Mathf.Max(-circularRadius, -q - circularRadius);
                int r2 = Mathf.Min(circularRadius, -q + circularRadius);
                
                for (int r = r1; r <= r2; r++)
                {
                    Vector3 position = AxialToWorldPosition(q, r, hexSize, tileSpacing) + transform.position;
                    CreateHexagonTile(position, q, r);
                    
                    tilesCreated++;
                    if (tilesCreated >= tilesPerFrame)
                    {
                        tilesCreated = 0;
                        yield return null;
                    }
                }
            }
        }

        isGenerated = true;
        
        if (showDebugInfo)
            Debug.Log($"[MainMenuHexFloor] Floor generated with {transform.childCount} hexagon tiles");
    }

    private Vector3 CalculateHexPosition(int col, int row, float size, float spacing)
    {
        float hexWidth = size * 1.5f + spacing;
        float hexHeight = size * Mathf.Sqrt(3f) * 0.75f + spacing;
        
        float xPos = col * hexWidth;
        float zPos = row * hexHeight;
        
        if (row % 2 == 1)
            xPos += hexWidth * 0.5f;
            
        return new Vector3(xPos, yOffset, zPos);
    }

    private Vector3 AxialToWorldPosition(int q, int r, float size, float spacing)
    {
        float hexWidth = size * 1.5f + spacing;
        float hexHeight = size * Mathf.Sqrt(3f) * 0.5f + spacing;
        
        float x = hexWidth * (2f/3f * q);
        float z = hexHeight * (Mathf.Sqrt(3f)/3f * q + 2f/3f * Mathf.Sqrt(3f) * r);
        
        return new Vector3(x, yOffset, z);
    }

    private void CreateHexagonTile(Vector3 position, int col, int row)
    {
        GameObject hexTile = Instantiate(hexagonTilePrefab, position, Quaternion.identity, transform);
        hexTile.name = $"HexTile_{col}_{row}";
        
        hexTile.transform.rotation = Quaternion.Euler(0f, 0f, 0f);
        hexTile.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
        
        if (useRandomScale)
        {
            ApplyScaleVariation(hexTile);
        }
    }

    private void ApplyScaleVariation(GameObject hexTile)
    {
        if (useRandomScale)
        {
            float randomScale = Random.Range(scaleRange.x, scaleRange.y);
            hexTile.transform.localScale = Vector3.one * randomScale;
        }
    }

    private void ApplyVisualVariations(GameObject hexTile)
    {
        if (useRandomRotation)
        {
            Vector3 randomRot = new Vector3(
                Random.Range(-randomRotationRange.x, randomRotationRange.x),
                Random.Range(-randomRotationRange.y, randomRotationRange.y),
                Random.Range(-randomRotationRange.z, randomRotationRange.z)
            );
            hexTile.transform.localRotation = Quaternion.Euler(randomRot);
        }
        ApplyScaleVariation(hexTile);
    }

    private void OnDrawGizmosSelected()
    {
        if (!showDebugInfo) return;
        
        float totalHexSize = hexSize + tileSpacing;
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube(transform.position, new Vector3(gridWidth * totalHexSize * 1.5f, 0.1f, gridHeight * totalHexSize * Mathf.Sqrt(3f)));
    }
    
    public bool IsGenerated => isGenerated;
    public int TileCount => transform.childCount;
    
    public void RegenerateFloor()
    {
        if (isGenerated)
        {
            GenerateFloor();
        }
    }
}

// --- FILE: Scripts/MainMenu/TimeLine/TimelineManager.cs ---
using UnityEngine;
using UnityEngine.Playables;
using UnityEngine.Timeline;

public class TimelineManager : MonoBehaviour
{
    public static TimelineManager Instance { get; private set; }

    [Header("Timeline Management")]
    [SerializeField] private PlayableDirector[] playableDirectors;
    [SerializeField] private TimelineAsset[] initialTimelines;
    [SerializeField] private TimelineAsset[] playTimelines;
    [SerializeField] private bool autoFindDirectors = false;
    [SerializeField] private GameObject[] targetObjects;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        if (autoFindDirectors)
        {
            FindAllPlayableDirectors();
        }
    }

    private void FindAllPlayableDirectors()
    {
        PlayableDirector[] foundDirectors = FindObjectsOfType<PlayableDirector>();
        playableDirectors = foundDirectors;
        
        Debug.Log($"Trouvé {foundDirectors.Length} PlayableDirectors dans la scène");
        
        // Sauvegarder les timelines actuelles comme timelines initiales
        initialTimelines = new TimelineAsset[foundDirectors.Length];
        for (int i = 0; i < foundDirectors.Length; i++)
        {
            if (foundDirectors[i].playableAsset is TimelineAsset timeline)
            {
                initialTimelines[i] = timeline;
            }
        }
    }

    public void SwitchToPlayTimelines()
    {
        for (int i = 0; i < playableDirectors.Length; i++)
        {
            if (playableDirectors[i] != null && playTimelines[i] != null && targetObjects[i] != null)
            {
                // Arrêter la timeline actuelle
                playableDirectors[i].Stop();
            
                // Changer la timeline
                playableDirectors[i].playableAsset = playTimelines[i];
            
                // Réassigner les bindings
                AssignBindingsToTimeline(playableDirectors[i], targetObjects[i]);
                
                // Redémarrer la timeline
                playableDirectors[i].Play();
            }
        }
    }

    public void SwitchToInitialTimelines()
    {
        for (int i = 0; i < playableDirectors.Length; i++)
        {
            if (playableDirectors[i] != null && initialTimelines[i] != null && targetObjects[i] != null)
            {
                // Arrêter la timeline actuelle
                playableDirectors[i].Stop();
            
                // Changer la timeline
                playableDirectors[i].playableAsset = initialTimelines[i];
            
                // Réassigner les bindings
                AssignBindingsToTimeline(playableDirectors[i], targetObjects[i]);
                
                // Redémarrer la timeline
                playableDirectors[i].Play();
            }
        }
    }

    public void SwitchTimeline(int directorIndex, TimelineAsset newTimeline, GameObject targetObject = null)
    {
        if (directorIndex >= 0 && directorIndex < playableDirectors.Length && playableDirectors[directorIndex] != null)
        {
            PlayableDirector director = playableDirectors[directorIndex];
            
            // Arrêter la timeline actuelle
            director.Stop();
            
            // Changer la timeline
            director.playableAsset = newTimeline;
            
            // Réassigner les bindings si un objet cible est fourni
            if (targetObject != null)
            {
                AssignBindingsToTimeline(director, targetObject);
            }
            else if (directorIndex < targetObjects.Length && targetObjects[directorIndex] != null)
            {
                AssignBindingsToTimeline(director, targetObjects[directorIndex]);
            }
            
            // Redémarrer la timeline
            director.Play();
        }
    }

    private void AssignBindingsToTimeline(PlayableDirector director, GameObject targetObject)
    {
        if (director.playableAsset is TimelineAsset timeline)
        {
            foreach (var track in timeline.GetOutputTracks())
            {
                // Pour les Animation Tracks
                if (track is AnimationTrack)
                {
                    var animator = targetObject.GetComponent<Animator>();
                    if (animator != null)
                    {
                        director.SetGenericBinding(track, animator);
                    }
                }
                // Pour les Activation Tracks
                else if (track.GetType().Name == "ActivationTrack")
                {
                    director.SetGenericBinding(track, targetObject);
                }
                // Pour d'autres types de tracks, assignez le Transform par défaut
                else
                {
                    director.SetGenericBinding(track, targetObject.transform);
                }
            }
        
            Debug.Log($"Bindings assignés pour {targetObject.name}");
        }
    }

    public void PlayTimeline(int directorIndex)
    {
        if (directorIndex >= 0 && directorIndex < playableDirectors.Length && playableDirectors[directorIndex] != null)
        {
            playableDirectors[directorIndex].Play();
        }
    }

    public void StopTimeline(int directorIndex)
    {
        if (directorIndex >= 0 && directorIndex < playableDirectors.Length && playableDirectors[directorIndex] != null)
        {
            playableDirectors[directorIndex].Stop();
        }
    }

    public void StopAllTimelines()
    {
        foreach (var director in playableDirectors)
        {
            if (director != null)
            {
                director.Stop();
            }
        }
    }
    
    public void PlayAllTimelines()
    {
        foreach (var director in playableDirectors)
        {
            if (director != null)
            {
                director.Play();
            }
        }
    }
}

// --- FILE: Scripts/Movements/BossMovementSystem.cs ---
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class BossMovementSystem : MonoBehaviour, IMovement
{
    public IEnumerator MoveToTile(Transform unitTransform, Vector3 startPos, Vector3 endPos, float duration)
    {
        float elapsed = 0f;
        while (elapsed < duration)
        {
            unitTransform.position = Vector3.Lerp(startPos, endPos, elapsed / duration);
            elapsed += Time.deltaTime;
            yield return null;
        }
        unitTransform.position = endPos;
    }

    /// <summary>
    /// Vérifie si la zone de destination (7 cases) est entièrement libre pour le boss.
    /// </summary>
    public bool IsDestinationAreaClear(Tile nextCentralTile, Unit bossUnit)
    {
        if (nextCentralTile == null) return false;

        List<Tile> destinationTiles = HexGridManager.Instance.GetTilesWithinRange(nextCentralTile.column, nextCentralTile.row, 1);

        if (destinationTiles.Count < 7)
        {
            Debug.LogWarning("La zone de destination du boss est en bord de carte et n'est pas complète. Mouvement interdit.");
            return false;
        }

        foreach (var tile in destinationTiles)
        {
            Vector2Int tilePos = new Vector2Int(tile.column, tile.row);

            // ----- LA CORRECTION EST ICI -----
            // On vérifie si la case est occupée par une AUTRE unité (différente du boss)
            // OU si elle est réservée par une AUTRE unité.
            bool isOccupiedByOther = tile.currentUnit != null && tile.currentUnit != bossUnit;
            bool isReservedByOther = TileReservationController.Instance.IsTileReservedByOtherUnit(tilePos, bossUnit);

            if (isOccupiedByOther || isReservedByOther)
            {
                Debug.Log($"Mouvement du boss bloqué par la case {tilePos} qui est occupée ou réservée par un autre.");
                return false;
            }
        }

        return true; // Toutes les cases sont libres !
    }
}

// --- FILE: Scripts/Movements/JumpMovement.cs ---
using UnityEngine;
using System.Collections;

public class JumpMovement : MonoBehaviour, IMovement
{
    [SerializeField] private float jumpHeight = 1f;
    [Header("Debug")]
    [SerializeField] private bool showJumpLogs = true;

    // Fixed implementation to match the interface signature
    public IEnumerator MoveToTile(Transform unitTransform, Vector3 startPos, Vector3 targetPos, float duration)
    {
        float elapsed = 0f;

        if (showJumpLogs)
        {
            Debug.Log($"[JUMP] Starting jump from {startPos} to {targetPos} " +
                      $"(Distance: {Vector3.Distance(startPos, targetPos):F2})");
        }

        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / duration;

            // Calculate jump arc using sine function
            float yOffset = Mathf.Sin(t * Mathf.PI) * jumpHeight;

            // Interpolate position
            unitTransform.position = Vector3.Lerp(startPos, targetPos, t) + Vector3.up * yOffset;

            yield return null;
        }

        // Ensure exact final position
        unitTransform.position = targetPos;

        if (showJumpLogs)
        {
            Debug.Log($"[JUMP] Landed at {targetPos} " +
                      $"(Final distance: {Vector3.Distance(startPos, targetPos):F2})");
        }
    }

    public void Initialize(Unit unit)
    {
        // Initialization if needed
    }
}

// --- FILE: Scripts/Observers/IBannerObserver.cs ---
using UnityEngine;

namespace Game.Observers
{
    public interface IBannerObserver
    {
        void OnBannerPlaced(int column, int row);
    }
}

// --- FILE: Scripts/Observers/IComboObserver.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Game.Observers
{
    // Interface for combo observers
    public interface IComboObserver
    {
        void OnComboUpdated(int newCombo);
        void OnComboReset();
    }
}


// --- FILE: Scripts/Observers/IGoldObserver.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Game.Observers
{
    // Interface for gold observers
    public interface IGoldObserver
    {
        void OnGoldUpdated(int newAmount);
    }
}


// --- FILE: Scripts/Observers/IMapObserver.cs ---
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IMapObserver
{
    void OnTileStateChanged(Tile tile);
}


// --- FILE: Scripts/Observers/ISequenceObserver.cs ---
using UnityEngine;
using System;

public class SequenceObserver : MonoBehaviour
{
    private void OnEnable()
    {
       // SequenceController.OnSequenceExecuted += HandleSequenceExecuted;
    }

    private void OnDisable()
    {
        //SequenceController.OnSequenceExecuted -= HandleSequenceExecuted;
    }

    /*
    private void HandleSequenceExecuted(Sequence executedSequence, int perfectCount)
    {
        Debug.Log($"Sequence executed: {executedSequence.responseMessage} with {perfectCount} perfect inputs.");
        // Add custom reactions here (e.g., trigger unit production, play effects, etc.)
    } */
}

// --- FILE: Scripts/ScriptableObjects/BaseSpellEffect_SO.cs ---
namespace ScriptableObjects
{
    using UnityEngine;

    public abstract class BaseSpellEffect_SO : ScriptableObject
    {
        // GameObject caster: l'entité qui lance le sort (pourrait être null pour des sorts "globaux")
        private int perfectCount;
        public abstract void ExecuteEffect(GameObject caster, int perfectCount);
        public virtual string GetEffectDescription() { return "Effet de sort générique."; } // Pour l'UI
    }
}

// --- FILE: Scripts/ScriptableObjects/BuildingStats.cs ---
using UnityEngine;
using Sirenix.OdinInspector;

[CreateAssetMenu(fileName = "NewBuildingStats", menuName = "Building/Stats")]
public class BuildingStats : SerializedScriptableObject
{
    [Title("Building Stats")]
    public int health = 500;
    public int defense = 5;

    [Title("Resource Generation")]
    public int goldGeneration = 10;
    public int goldGenerationDelay = 4; // How many beats between generating gold

    [Title("Garrison")]
    public int Garrison = 0; // Number of units that can be garrisoned
}

// --- FILE: Scripts/ScriptableObjects/CharacterData_SO.cs ---
namespace ScriptableObjects
{
	using UnityEngine;
	using System.Collections.Generic;
	using Sirenix.OdinInspector;
	#if UNITY_EDITOR
	using UnityEditor;
	#endif



	public enum InputType { X, C, V }

	[CreateAssetMenu(fileName = "CharacterData_New", menuName = "GameData/Character Data")]
	public class CharacterData_SO : ScriptableObject
	{
    [BoxGroup("Identification", ShowLabel = false)]
    [HorizontalGroup("Identification/Split", Width = 100)]
    [PreviewField(100, ObjectFieldAlignment.Left), HideLabel]
    public Sprite Icon;

    [VerticalGroup("Identification/Split/Info")]
    [InfoBox("ID Unique utilisé pour la sauvegarde et les références internes.")]
    public string CharacterID = "Char_Default";

    [VerticalGroup("Identification/Split/Info")]
    public string DisplayName = "Default Character";

    [TextArea(3, 5)]
    [BoxGroup("Description")]
    public string Description;

    [Title("Gameplay")]

    [BoxGroup("Gameplay")]
    [BoxGroup("Gameplay/Stats", ShowLabel = false)]
    [InfoBox("ScriptableObject contenant les statistiques de ce personnage.")]
    [InlineEditor(InlineEditorModes.FullEditor)]
    public StatSheet_SO Stats; 
    
    public GameObject GameplayUnitPrefab;

    [BoxGroup("Gameplay/Invocation")]
    [ListDrawerSettings(NumberOfItemsPerPage = 4)] // Affichage compact
    [InfoBox("Séquence de 4 inputs (X, C, ou V) pour invoquer ce personnage.")]
    [ValidateInput("ValidateSequenceLength", "La séquence d'invocation doit comporter exactement 4 inputs.")]
    public List<InputType> InvocationSequence = new List<InputType>(4); // Initialise avec 4 éléments par défaut si besoin

    [BoxGroup("Gameplay/Invocation")] // Placé dans le même groupe que la séquence
    [MinValue(0)]
    [SuffixLabel("or")]
    [GUIColor(0.9f, 0.9f, 0.2f)] // Pour le rendre plus visible
    public int GoldCost = 0;
    // --- Validation pour Odin Inspector ---
    #if UNITY_EDITOR
    private bool ValidateSequenceLength(List<InputType> sequence)
    {
        return sequence != null && sequence.Count == 4;
    }
    #endif
    // ------------------------------------
	[Header("Momentum System")]
    [Tooltip("Cost in momentum charges to invoke this unit. 0 for basic units.")]
    public int MomentumCost = 0;

    [Tooltip("Momentum gained (as a fraction of a charge) when this unit is successfully invoked.")]
    [Range(0f, 1f)]
    public float MomentumGainOnInvoke = 0.2f;

    [Tooltip("Momentum gained (as a fraction of a charge) when this unit completes its primary objective (capture or defensive kill).")]
    [Range(0f, 1f)]
    public float MomentumGainOnObjectiveComplete = 0.5f;
	
    [Title("Fever Mode Buffs")]
    [InfoBox("Modificateurs appliqués lorsque le Mode Fever est actif.")]
    public FeverBuffs feverBuffs;

    [Title("Hub & UI")]
    [AssetsOnly]
    public GameObject HubVisualPrefab;
    [AssetsOnly]
    public GameObject MenuAnimationPrefab;
    [Title("Audio (Wwise)")]
    [InfoBox("Assigner les Events Wwise spécifiques à ce personnage.")]
    public AK.Wwise.Event InvocationSound; // Décommenté - Assigne tes events Wwise ici
    public AK.Wwise.Event SelectionSound;
    // Ajouter d'autres sons si nécessaire (attaque, capacité spéciale, etc.)

    [Title("Statut Initial")]
    [InfoBox("Cocher si ce personnage est débloqué dès le début du jeu.")]
    public bool UnlockedByDefault = false;

    [Title("Cooldown d'Invocation")]
    [BoxGroup("Cooldown")]
    [MinValue(0)]
    [Tooltip("Temps en beats avant de pouvoir invoquer à nouveau ce personnage.")]
    public float InvocationCooldown = 5;
	}
	
	[System.Serializable]
	public struct FeverBuffs
	{
		[Tooltip("Multiplicateur de la vitesse d'attaque. Ex: 1.3 pour +30%. Mettre à 1 pour aucun changement.")]
		[Range(1f, 3f)]
		public float AttackSpeedMultiplier;

		[Tooltip("Nombre de projectiles supplémentaires tirés par les unités à distance.")]
		[Range(0, 5)]
		public int ExtraProjectiles;

		[Tooltip("Multiplicateur de défense. Ex: 2.0 pour doubler la défense.")]
		[Range(1f, 5f)]
		public float DefenseMultiplier;
	}
}



// --- FILE: Scripts/ScriptableObjects/CharacterProgressionData_SO.cs ---
﻿namespace ScriptableObjects
{
    using UnityEngine;

    [CreateAssetMenu(fileName = "ProgressionData_New", menuName = "GameData/Character Progression Data")]
    public class CharacterProgressionData_SO : ScriptableObject
    {
        [Header("Courbe d'Expérience")]
        [Tooltip("Définit le montant total d'XP requis pour atteindre un niveau. X=Niveau, Y=XP Requis.")]
        public AnimationCurve XpRequirementCurve;

        [Header("Courbes de Statistiques")]
        [Tooltip("Définit la statistique de base (SANS équipement) à un niveau donné. X=Niveau, Y=Valeur de la Stat.")]
        public AnimationCurve HealthCurve;
        public AnimationCurve AttackCurve;
        public AnimationCurve DefenseCurve;

        /// <summary>
        /// Retourne le total d'XP requis pour atteindre un niveau spécifique.
        /// </summary>
        public int GetXPRequiredForLevel(int level)
        {
            return Mathf.RoundToInt(XpRequirementCurve.Evaluate(level));
        }

        /// <summary>
        /// Calcule les statistiques d'un personnage pour un niveau donné.
        /// </summary>
        public UnitStats_SO GetStatsForLevel(UnitStats_SO baseStats, int level)
        {
            // On crée une copie pour ne pas modifier l'asset de base.
            UnitStats_SO calculatedStats = Instantiate(baseStats);

            calculatedStats.Health += Mathf.RoundToInt(HealthCurve.Evaluate(level));
            calculatedStats.Attack += Mathf.RoundToInt(AttackCurve.Evaluate(level));
            calculatedStats.Defense += Mathf.RoundToInt(DefenseCurve.Evaluate(level));

            return calculatedStats;
        }
    }
}

// --- FILE: Scripts/ScriptableObjects/EnvStats.cs ---
namespace ScriptableObjects
{
    using UnityEngine;
    using Sirenix.OdinInspector;

    [CreateAssetMenu(fileName = "NewEnvironmentStats", menuName = "Game/Environment Stats")]
    public class EnvironmentStats : ScriptableObject
    {
        [Header("Basic Settings")] [Tooltip("The name of this environment type")]
        public string environmentTypeName;

        [Tooltip("Descriptive text for this environment")] [TextArea(3, 5)]
        public string description;

        [Header("Gameplay Effects")] [Tooltip("Does this environment provide cover?")]
        public bool providesCover;

        [ShowIf("providesCover")] [Range(0, 50)] [Tooltip("Percentage of damage reduction when unit is in cover")]
        public int coverDamageReduction = 20;
    }
}

// --- FILE: Scripts/ScriptableObjects/EquipmentData_SO.cs ---
﻿namespace ScriptableObjects
{
    using UnityEngine;
    using System.Collections.Generic;

// Enum to define which character stat a modifier affects.
    public enum StatType
    {
        Health,
        Attack,
        Defense,
        // Add other stats as needed, e.g., Speed, Magic, CriticalChance
    }

// Enum for equipment slots to ensure items can only be equipped in the correct place.
    public enum EquipmentSlotType
    {
        Weapon,
        Helmet,
        Armor,
        Accessory
    }

// A simple struct to define a stat modification.
    [System.Serializable]
    public struct StatModifier
    {
        public StatType StatToModify;
        public int Value;
    }

    [CreateAssetMenu(fileName = "EQP_NewEquipment", menuName = "GameData/Equipment Data")]
    public class EquipmentData_SO : ScriptableObject
    {
        [Header("Identification")]
        public string EquipmentID; // e.g., "WEP_IRON_SWORD"
        public string DisplayName; // e.g., "Iron Sword"
        public Sprite Icon;
    
        [Header("Categorization")]
        public EquipmentSlotType SlotType;

        [TextArea]
        public string Description;

        [Header("Stat Modifiers")]
        public List<StatModifier> Modifiers;
    }
}


// --- FILE: Scripts/ScriptableObjects/GlobalSpellData_SO.cs ---
namespace ScriptableObjects
{
	using UnityEngine;
	using System.Collections.Generic;
	using Sirenix.OdinInspector; // Assuming ValidateInput attribute is from Odin Inspector
	using AK.Wwise;

	[CreateAssetMenu(fileName = "NewGlobalSpellData", menuName = "ScriptableObjects/GlobalSpellData", order = 1)]
	public class GlobalSpellData_SO : ScriptableObject
	{
    public string SpellID; // Identifiant unique, ex: "SPELL_GOLD_BOOST"
    public string DisplayName; // Nom du sort pour l'UI, ex: "Pluie d'Or"

    [TextArea]
    public string Description;

    public Sprite Icon; // Optionnel, pour affichage UI

    [ValidateInput("ValidateSpellSequence", "La séquence doit contenir exactement 4 éléments.")]
    public List<InputType> SpellSequence = new List<InputType>(4);

    public int GoldCost = 0; // Optionnel, si les sorts ont aussi un coût

    public AK.Wwise.Event ActivationSound; // Optionnel, pour un son spécifique au lancement du sort

    public BaseSpellEffect_SO SpellEffect; // Partie clé pour la flexibilité des effets

    [Header("Cooldown")]
    [Tooltip("Temps de rechargement en secondes avant de pouvoir relancer ce sort.")]
    [MinValue(0)]
    public float BeatCooldown = 15f; 
    
    [Tooltip("Cost in momentum charges to cast this spell.")]
    public int MomentumCost = 1;
    
    private bool ValidateSpellSequence(List<InputType> sequence)
    {
        return sequence != null && sequence.Count == 4;
    }
	}

}

// --- FILE: Scripts/ScriptableObjects/LevelData_SO.cs ---
namespace ScriptableObjects
{
	using UnityEngine;
	using Sirenix.OdinInspector;
	using System.Collections.Generic; // Ajouté pour les listes potentielles


	public enum LevelType
	{
    	SystemScene,    // Pour MainMenu, Hub, Core, etc.
    	GameplayLevel,  // Pour les niveaux jouables classiques
    	Cinematic,      // Pour les scènes cinématiques
	}

	[CreateAssetMenu(fileName = "LevelData_New", menuName = "GameData/Level Data")]
	public class LevelData_SO : ScriptableObject
	{
    [BoxGroup("Identification")]
    [InfoBox("ID Unique utilisé pour la sauvegarde et les références internes.")]
    public string LevelID = "Level_Default";

    [BoxGroup("Identification")]
    public string DisplayName = "Niveau par défaut";
	
	[BoxGroup("Identification")]
    [Tooltip("Index pour trier les niveaux. Le plus petit s'affiche en premier.")]
    public int OrderIndex = 0;

    [BoxGroup("Scene")]
    [Required("Le nom de la scène à charger est requis.")]
    [SceneObjectsOnly] // Ou garde string si tu préfères taper le nom
    public string SceneName = "Level_Gameplay_Template"; // Mets un nom de scène template

    [TextArea(3, 5)]
    [BoxGroup("Description")]
    public string Description;

    [Title("Conditions de Déblocage")]
    [InfoBox("Laissez vide si le niveau est débloqué par défaut ou via une autre logique.")]
    [AssetsOnly] // Si tu débloques via l'ID d'un autre LevelData_SO
    public LevelData_SO RequiredPreviousLevel; // Remplacé string par référence directe

    public int RequiredPlayerLevel; // 0 si pas requis
    [Title("Affichage & Accès")]
    public LevelType TypeOfLevel = LevelType.GameplayLevel; // Par défaut

    [Title("Récompenses")]
    public int ExperienceReward;
    public int CurrencyReward;
    [AssetsOnly] // Pour lier directement au SO du personnage à débloquer
    public CharacterData_SO CharacterUnlockReward;

    [Tooltip("Liste des équipements (items) à débloquer en récompense de victoire.")] [AssetsOnly]
    public List<EquipmentData_SO> ItemRewards;
	    
    [Title("Gameplay Settings")]
    [Range(1, 5)] public int Difficulty = 1; // Exemple d'échelle
    public float RhythmBPM = 120f; // Remplacé speed par BPM pour être clair

    [Header("Scenario Configuration")]
    [Tooltip("Scénario à exécuter pour ce niveau")]
    public LevelScenario_SO scenario;
    [Title("Audio (Wwise)")]
    public AK.Wwise.Event BackgroundMusic; // Décommenté
    public AK.Wwise.Switch MusicStateSwitch; // Potentiel Switch Wwise pour ce niveau
    // public AK.Wwise.Event VictoryMusic;
    // public AK.Wwise.Event DefeatMusic;
	}
}

// --- FILE: Scripts/ScriptableObjects/LevelScenario_SO.cs ---
﻿// Fichier: Scripts/Scenarios/LevelScenario_SO.cs
using UnityEngine;
using System.Collections.Generic;
using ScriptableObjects;

// --- Enums pour le système de scénario ---

/// <summary>
/// Définit les conditions qui peuvent déclencher un événement de scénario.
/// </summary>
public enum TriggerType
{
    OnLevelStart,
    OnZoneEnter,
    OnBossDied,
    OnWaveCleared,
    OnTimerElapsed,
    OnAllTargetsWithTagDestroyed,
    OnSpecificTargetDestroyed,
    OnBuildingCaptured
}

/// <summary>
/// Définit les actions que le scénario peut exécuter.
/// </summary>
public enum ActionType
{
    StartWave,
    ActivateSpawnerBuilding,
    DeactivateSpawnerBuilding,
    EndLevel,
    TriggerVictory,
    TriggerDefeat,
    TriggerGameObject,
    ShowBossWarningBanner
}

// --- Classe sérialisable pour un événement ---

[System.Serializable]
public class ScenarioEvent
{
    [Tooltip("Nom de l'événement pour l'organisation (ex: 'Première Vague d'Assaut').")]
    public string eventName;

    [Header("Trigger Settings")]
    [Tooltip("La condition qui déclenchera cet événement.")]
    public TriggerType triggerType;

    [Tooltip("Paramètre pour le trigger. Ex: l'ID de la TriggerZone, le nom du GameObject pour OnSpecificTargetDestroyed ou OnBuildingCaptured, ou le Tag pour OnAllTargetsWithTagDestroyed.")]
    public string triggerParameter;

    [Header("Action Settings")]
    [Tooltip("L'action à exécuter lorsque l'événement est déclenché.")]
    public ActionType actionType;

    [Tooltip("Délai en secondes avant que l'action ne s'exécute après le déclenchement.")]
    public float delay;

    [Header("Action Parameters")]
    [Tooltip("La vague d'ennemis à lancer (si ActionType = StartWave).")]
    public Wave_SO actionParameter_Wave;

    [Tooltip("Le résultat du niveau (true = Victoire, false = Défaite) si ActionType = EndLevel.")]
    public bool actionParameter_Victory;

    // ----- MODIFICATION ICI -----
    [Tooltip("Le nom EXACT du GameObject cible pour les actions comme TriggerGameObject, StartWave, ActivateSpawnerBuilding, etc.")]
    public string actionParameter_GameObjectName;
    // ---------------------------
}

// --- Définition du ScriptableObject ---

[CreateAssetMenu(fileName = "LevelScenario_New", menuName = "KyotoVania/Level Scenario")]
public class LevelScenario_SO : ScriptableObject
{
    [Tooltip("Nom descriptif de ce scénario pour une identification facile.")]
    public string scenarioName;

    [Tooltip("La séquence d'événements qui constitue ce scénario.")]
    public List<ScenarioEvent> events = new List<ScenarioEvent>();
}

// --- FILE: Scripts/ScriptableObjects/StatSheet_SO.cs ---
﻿using UnityEngine;
using Sirenix.OdinInspector;

namespace ScriptableObjects
{
    public enum UnitType
    {
        Regular,
        Elite,
        Boss,
        Null
    }
    [CreateAssetMenu(fileName = "StatSheet_New", menuName = "GameData/Stat Sheet")]
    public class StatSheet_SO : ScriptableObject
    {
        [Header("Base Stats (Level 1)")]
        [Title("Unit Combat Stats")] [MinValue(1)] // Assure que la vie est au moins 1
        public int BaseHealth = 100;

        [MinValue(0)] // La défense peut être 0
        public int BaseDefense = 10;

        [MinValue(0)] // L'attaque peut être 0
        public int BaseAttack = 15;

        [MinValue(1)] // Portée d'attaque minimale de 1 (ou 0 si tu permets des attaques sans portée?)
        public int AttackRange = 1; // En nombre de tuiles

        [MinValue(1)] // Délai minimum d'une pulsation/beat
        public int AttackDelay = 1; // En nombre de beats

        [Title("Unit Movement & Detection")] [MinValue(1)] // Délai minimum d'une pulsation/beat
        public int MovementDelay = 1; // En nombre de beats avant de bouger

        [MinValue(0)] // La détection peut être 0 (ne voit rien)
        public int DetectionRange = 3; // En nombre de tuiles

        [Title("Unit Type")] [EnumToggleButtons] // Permet de choisir le type de manière plus visuelle
        public UnitType Type = UnitType.Regular; // Type de l'unité, peut être Regular, Elite ou Boss

        
        
        [Header("Courbe d'Expérience")]
        [Tooltip("Définit le montant total d'XP requis pour atteindre un niveau. X=Niveau, Y=XP Requis.")]
        public AnimationCurve XpRequirementCurve;
        [Header("Progression Curves (Bonus per level)")]
        [Tooltip("Définit la statistique de base (SANS équipement) à un niveau donné. X=Niveau, Y=Valeur de la Stat.")]
        public AnimationCurve HealthCurve;
        public AnimationCurve AttackCurve;
        public AnimationCurve DefenseCurve;
        
        /// <summary>
        /// Retourne le montant total d'XP requis pour atteindre un niveau donné.
        /// </summary>
        /// <param name="level">Le niveau pour lequel on veut connaître le requis en XP.</param>
        /// <returns>Le montant d'XP requis. Retourne int.MaxValue si la courbe n'est pas définie.</returns>
        public int GetXPRequiredForLevel(int level)
        {
            if (XpRequirementCurve == null || XpRequirementCurve.keys.Length == 0)
            {
                Debug.LogError("XpRequirementCurve n'est pas configurée pour le StatSheet: " + this.name);
                // On retourne une valeur très élevée pour éviter des level-ups accidentels.
                return int.MaxValue;
            }

            // On évalue la courbe au niveau demandé.
            return Mathf.RoundToInt(XpRequirementCurve.Evaluate(level));
        }
    }
}

// --- FILE: Scripts/ScriptableObjects/TileReactionProfile_SO.cs ---
namespace ScriptableObjects
{
    using UnityEngine;
    using Sirenix.OdinInspector;
    
    [CreateAssetMenu(fileName = "NewTileReactionProfile", menuName = "GameData/Tile Reaction Profile")]
    public class TileReactionProfile_SO : ScriptableObject
    {
        [Title("Common Settings")]
        [Range(0f, 1f)]
        public float reactionProbability = 0.65f;
    
        [Tooltip("For debugging or specific effects, always react regardless of probability.")]
        public bool alwaysReact = false;
    
        // --- Ground Tile Specific Parameters ---
        [BoxGroup("Ground Tile Settings")]
        [ShowIf("IsProfileForGround")]
        [Range(0f, 1f)] public float upMin = 0.05f;
    
        [BoxGroup("Ground Tile Settings")]
        [ShowIf("IsProfileForGround")]
        [Range(0f, 1f)] public float upMax = 0.2f;
    
        [BoxGroup("Ground Tile Settings")]
        [ShowIf("IsProfileForGround")]
        [Range(-1f, 0f)] public float downMin = -0.2f;
    
        [BoxGroup("Ground Tile Settings")]
        [ShowIf("IsProfileForGround")]
        [Range(-1f, 0f)] public float downMax = -0.05f;
    
        [BoxGroup("Ground Tile Settings")]
        [ShowIf("IsProfileForGround")]
        [Tooltip("Duration of ground movement as a multiplier of the beat duration.")]
        public float groundAnimBeatMultiplier = 0.4f;
    
        [BoxGroup("Ground Tile Settings")]
        [ShowIf("IsProfileForGround")]
        [Tooltip("Absolute variation in movement duration (seconds). Can be positive or negative range.")]
        public float durationVariation = 0.05f;
    
        [BoxGroup("Ground Tile Settings")]
        [ShowIf("IsProfileForGround")]
        public AnimationCurve movementCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);
    
        [BoxGroup("Ground Tile Settings")]
        [ShowIf("IsProfileForGround")]
        [Range(0f, 1f)] public float bouncePercentage = 0.4f;
    
        [BoxGroup("Ground Tile Settings")]
        [ShowIf("IsProfileForGround")]
        public float bounceDuration = 0.2f;
    
        // --- Combo Reaction Settings ---
        [Title("Combo Reaction Settings")]
        [Tooltip("Should this profile's reactivity change with combo?")]
        public bool reactToCombo = true;
    
        [ShowIf("reactToCombo")]
        [Tooltip("Increase reaction probability by this percentage for each combo threshold reached")]
        public float comboReactionBoostPercentage = 20f;
    
        [ShowIf("reactToCombo")]
        [Tooltip("Combo count required to increase the reaction probability")]
        public int comboThreshold = 5;
    
        [ShowIf("reactToCombo")]
        [Tooltip("Maximum increase to reaction probability (percentage)")]
        public float maxReactionBoostPercentage = 100f;
    
    
        // --- Water Tile Specific Parameters ---
        [BoxGroup("Water Tile Settings")]
        [ShowIf("IsProfileForWater")]
        public float waterWaveAmplitude = 0.1f;
    
        [BoxGroup("Water Tile Settings")]
        [ShowIf("IsProfileForWater")]
        public float waterWaveFrequency = 2.0f;
    
        // RETIRÉ: waterFixedSequenceNumber
        // RETIRÉ: waterFixedSequenceTotal
    
        [BoxGroup("Water Tile Settings")]
        [ShowIf("IsProfileForWater")]
        [Tooltip("Number of beats to wait between wave cycles for this profile.")]
        [Range(0, 10)] public int waterBeatsBetweenWaves = 0; // Conservé dans le profil
    
        [BoxGroup("Water Tile Settings")]
        [ShowIf("IsProfileForWater")]
        public float waterScaleFactor = 1.2f;
    
        [BoxGroup("Water Tile Settings")]
        [ShowIf("IsProfileForWater")]
        public float waterMoveHeight = 0.15f;
    
        [BoxGroup("Water Tile Settings")]
        [ShowIf("IsProfileForWater")]
        [Range(0.1f, 0.9f)] public float preBeatFraction = 0.5f;
    
        [BoxGroup("Water Tile Settings")] 
        [ShowIf("IsProfileForWater")]
        [Range(0.1f, 2f)] public float waterAnimationDurationMultiplier = 0.8f;
    
        // --- Mountain Tile Specific Parameters ---
        [BoxGroup("Mountain Tile Settings")]
        [ShowIf("IsProfileForMountain")]
        [Range(0f, 1f)] public float mountainReactionStrength = 0.5f;
        // Ajoutez ici une variable pour la durée de la secousse des montagnes si nécessaire,
        // ex: public float mountainShakeDurationMultiplier = 0.3f;
    
    
        [Title("Profile Type Hint")] // Renommé pour plus de clarté
        public enum ProfileApplicability
        {
            Generic,
            Ground,
            Water,
            Mountain
        }
        [EnumToggleButtons]
        [Tooltip("Hint for the primary intended use of this profile. Does not restrict assignment but helps with ShowIf in inspector.")]
        public ProfileApplicability applicableTileType = ProfileApplicability.Generic;
    
        private bool IsProfileForGround() => applicableTileType == ProfileApplicability.Ground || applicableTileType == ProfileApplicability.Generic;
        private bool IsProfileForWater() => applicableTileType == ProfileApplicability.Water || applicableTileType == ProfileApplicability.Generic;
        private bool IsProfileForMountain() => applicableTileType == ProfileApplicability.Mountain || applicableTileType == ProfileApplicability.Generic;
    }
}


// --- FILE: Scripts/ScriptableObjects/UnitStats_SO.cs ---
namespace ScriptableObjects
{
    using UnityEngine;
    using Sirenix.OdinInspector;

    //enum for type of unit 
    

    [CreateAssetMenu(fileName = "UnitStats_New", menuName = "GameData/Unit Stats")]
    public class UnitStats_SO : ScriptableObject
    {
        [Title("Unit Combat Stats")] [MinValue(1)] // Assure que la vie est au moins 1
        public int Health = 100;

        [MinValue(0)] // La défense peut être 0
        public int Defense = 10;

        [MinValue(0)] // L'attaque peut être 0
        public int Attack = 15;

        [MinValue(1)] // Portée d'attaque minimale de 1 (ou 0 si tu permets des attaques sans portée?)
        public int AttackRange = 1; // En nombre de tuiles

        [MinValue(1)] // Délai minimum d'une pulsation/beat
        public int AttackDelay = 1; // En nombre de beats

        [Title("Unit Movement & Detection")] [MinValue(1)] // Délai minimum d'une pulsation/beat
        public int MovementDelay = 1; // En nombre de beats avant de bouger

        [MinValue(0)] // La détection peut être 0 (ne voit rien)
        public int DetectionRange = 3; // En nombre de tuiles

        [Title("Unit Type")] [EnumToggleButtons] // Permet de choisir le type de manière plus visuelle
        public UnitType Type = UnitType.Regular; // Type de l'unité, peut être Regular, Elite ou Boss


    }
}

// --- FILE: Scripts/ScriptableObjects/Wave_SO.cs ---
﻿namespace ScriptableObjects
{
    using System.Collections.Generic;
    using UnityEngine;
    
    [CreateAssetMenu(fileName = "New Wave", menuName = "Game/Wave")]
    public class Wave_SO : ScriptableObject
    {
        [Header("Wave Configuration")]
        public string waveName;
        
        [Header("Spawn Requests")]
        public List<UnitSpawnRequest> spawnRequests = new List<UnitSpawnRequest>();
        
        /// <summary>
        /// Définit une demande de spawn d'unité dans une vague
        /// </summary>
        [System.Serializable]
        public class UnitSpawnRequest
        {
            [Header("Unit Configuration")]
            [Tooltip("Prefab de l'unité à générer")]
            public GameObject unitPrefab;
            
            [Tooltip("Nombre d'unités à générer")]
            public int count = 1;
            
            [Header("Timing")]
            [Tooltip("Délai en secondes avant ce spawn spécifique, après le début de la vague")]
            public float spawnDelay = 0f;
            
            [Header("Spawn Behavior")]
            [Tooltip("Tag du bâtiment spawner à utiliser (optionnel)")]
            public string spawnerBuildingTag;
            
            [Header("Debug")]
            [Tooltip("Nom pour identifier cette demande de spawn")]
            public string requestName;
        }
        
        /// <summary>
        /// Retourne la durée totale de la vague basée sur le plus grand délai de spawn
        /// </summary>
        public float GetWaveDuration()
        {
            float maxDelay = 0f;
            foreach (var request in spawnRequests)
            {
                if (request.spawnDelay > maxDelay)
                    maxDelay = request.spawnDelay;
            }
            return maxDelay;
        }
    }
}


// --- FILE: Scripts/ScriptableObjects/Effects/GenerateGoldEffect_SO.cs ---
namespace ScriptableObjects
{
    using UnityEngine;

    [CreateAssetMenu(fileName = "GenerateGoldEffect_New", menuName = "GameData/Effects/Generate Gold Effect")]
    public class GenerateGoldEffect_SO : BaseSpellEffect_SO
    {
        public int BaseGoldAmount = 50;
        public int BonusPerPerfectInput = 10;

        public override void ExecuteEffect(GameObject caster, int perfectCount)
        {
            int totalGold = BaseGoldAmount + (BonusPerPerfectInput * perfectCount);
            if (GoldController.Instance != null)
            {
                GoldController.Instance.AddGold(totalGold);
                Debug.Log(
                    $"[GenerateGoldEffect] Added {totalGold} gold (Base: {BaseGoldAmount}, Bonus: {BonusPerPerfectInput} x {perfectCount})");
            }
            else
            {
                Debug.LogWarning("[GenerateGoldEffect] GoldController instance not found.");
            }
        }

        public override string GetEffectDescription()
        {
            return $"Génère {BaseGoldAmount} or (+{BonusPerPerfectInput} par input parfait)";
        }
    }
}

// --- FILE: Scripts/ScriptableObjects/Effects/GlobalUnitBuffEffect_SO.cs ---
using UnityEngine;
using System.Collections.Generic;
using ScriptableObjects;
using Gameplay;

public enum StatToBuff
{
    Attack,
    Defense,
    Speed
}

[CreateAssetMenu(fileName = "GlobalUnitBuffEffect_New", menuName = "GameData/Effects/Global Unit Buff Effect")]
public class GlobalUnitBuffEffect_SO : BaseSpellEffect_SO
{
    public StatToBuff Stat; 
    public float BuffMultiplier = 1.2f; 
    public float BuffDuration = 10f; 
    public int BonusDurationPerPerfectInput = 2; //

    public override void ExecuteEffect(GameObject caster, int perfectCount) //
    {
        float totalDuration = BuffDuration + (BonusDurationPerPerfectInput * perfectCount); //

        // Utiliser AllyUnitRegistry pour obtenir les unités alliées actives
        if (AllyUnitRegistry.Instance == null)
        {
            Debug.LogWarning("[GlobalUnitBuffEffect] AllyUnitRegistry.Instance non trouvé. Impossible d'appliquer le buff.");
            return;
        }

        IReadOnlyList<AllyUnit> activeAllyUnits = AllyUnitRegistry.Instance.ActiveAllyUnits; //
        if (activeAllyUnits.Count == 0)
        {
            Debug.LogWarning("[GlobalUnitBuffEffect] Aucune unité alliée active trouvée dans AllyUnitRegistry.");
            return;
        }

        Debug.Log($"[GlobalUnitBuffEffect] Application du buff '{Stat}' (x{BuffMultiplier}) pour {totalDuration}s à {activeAllyUnits.Count} unités alliées.");

        foreach (AllyUnit allyUnit in activeAllyUnits)
        {
            if (allyUnit != null)
            {
                allyUnit.ApplyBuff(Stat, BuffMultiplier, totalDuration);
            }
        }
    }

    public override string GetEffectDescription() //
    {
        // Calcule la durée totale avec un exemple d'un input parfait pour la description.
        float exampleTotalDuration = BuffDuration + (BonusDurationPerPerfectInput * 1); //
        // Calcule le pourcentage d'augmentation pour l'affichage.
        int percentBuff = Mathf.RoundToInt((BuffMultiplier - 1f) * 100); //
        // Retourne la description de l'effet.
        return $"Augmente {Stat} de {percentBuff}% pour toutes les unités alliées pendant {exampleTotalDuration}s.";
    }
    
}

// --- FILE: Scripts/ScriptableObjects/Effects/ZapBannerTargetEffect_SO.cs ---
﻿namespace ScriptableObjects
{
    using UnityEngine;

    [CreateAssetMenu(fileName = "NewZapBannerTargetEffect", menuName = "ScriptableObjects/SpellEffects/ZapBannerTarget", order = 1)]
    public class ZapBannerTargetEffect_SO : BaseSpellEffect_SO
    {
        [Header("Effect Configuration")]
        [Tooltip("The visual effect to spawn at the target")]
        public GameObject zapVFX;
        
        [Tooltip("Vertical offset for the VFX spawn position relative to the building")]
        public float vfxYOffset = 1f;
        
        [Tooltip("Amount of damage to deal to the target building")]
        public int damageAmount = 25;
        
        [Tooltip("Sound to play when the lightning strikes")]
        public AK.Wwise.Event zapSound;
        
        [Tooltip("Sound to play if there is no valid target")]
        public AK.Wwise.Event failSound;

        public override void ExecuteEffect(GameObject caster, int perfectCount)
        {
            // Check if we have a banner controller and it has a target
            if (!BannerController.Exists || !BannerController.Instance.HasActiveBanner || BannerController.Instance.CurrentBuilding == null)
            {
                Debug.LogWarning("[ZapBannerTargetEffect] No valid banner target found!");
                
                // Play fail sound if available
                if (failSound != null && failSound.IsValid() && caster != null)
                {
                    failSound.Post(caster);
                }
                
                return; // Early exit - no target
            }

            // Get the target building
            Building targetBuilding = BannerController.Instance.CurrentBuilding;
            
            // Check if the target is an enemy building
            if (!(targetBuilding is EnemyBuilding) || targetBuilding.Team != TeamType.Enemy)
            {
                Debug.LogWarning($"[ZapBannerTargetEffect] Target {targetBuilding.name} is not an enemy building! Type: {targetBuilding.GetType().Name}, Team: {targetBuilding.Team}");
                
                // Play fail sound if available
                if (failSound != null && failSound.IsValid() && caster != null)
                {
                    failSound.Post(caster);
                }
                
                return; // Early exit - not an enemy building
            }
            
            // Calculate bonus damage from perfect timing
            int totalDamage = damageAmount;
            if (perfectCount > 0)
            {
                // 10% bonus damage per perfect hit in the sequence
                totalDamage += Mathf.FloorToInt(damageAmount * 0.1f * perfectCount);
                Debug.Log($"[ZapBannerTargetEffect] Perfect sequence bonus! Damage increased from {damageAmount} to {totalDamage}");
            }
            
            // Spawn VFX at target position
            if (zapVFX != null)
            {
                // Spawn effect at the building's position with configurable offset
                Vector3 spawnPosition = targetBuilding.transform.position + new Vector3(0, vfxYOffset, 0);
                GameObject vfxInstance = Object.Instantiate(zapVFX, spawnPosition, Quaternion.identity);
                
                // Destroy VFX after 3 seconds
                Object.Destroy(vfxInstance, 3f);
            }
            
            // Play zap sound at target location
            if (zapSound != null && zapSound.IsValid())
            {
                if (caster != null)
                {
                    zapSound.Post(caster);
                }
            }
            
            // Deal damage to the target
            targetBuilding.TakeDamage(totalDamage);
            
            Debug.Log($"[ZapBannerTargetEffect] Lightning strike dealt {totalDamage} damage to {targetBuilding.name}");
        }
        
        public override string GetEffectDescription()
        {
            return $"Lance un éclair sur le bâtiment ennemi actuellement ciblé par la bannière, infligeant {damageAmount} points de dégâts. Les frappes parfaites augmentent les dégâts.";
        }
    }
}


// --- FILE: Scripts/Units/AllyUnit.cs ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Game.Observers;
using Unity.Behavior;
using Unity.Behavior.GraphFramework;
using Gameplay;

public class AllyUnit : Unit, IBannerObserver
{
    // --- Behavior Graph Agent Reference ---
    [Header("Behavior Graph")]
    [Tooltip("Assign the Behavior Graph Agent component from this GameObject here.")]
    [SerializeField] private BehaviorGraphAgent m_Agent;
    public BlackboardReference Blackboard => m_Agent?.BlackboardReference;

    // --- Blackboard Variable Cache ---
    // Clés pour le Blackboard
    private const string BB_HAS_BANNER_TARGET = "HasBannerTarget";
    private const string BB_BANNER_TARGET_POSITION = "BannerTargetPosition";
    private const string BB_FINAL_DESTINATION_POSITION = "FinalDestinationPosition"; // Utilisé par FindSmartStepNode
    private const string BB_INITIAL_TARGET_BUILDING = "InitialTargetBuilding";
    private const string BB_HAS_INITIAL_OBJECTIVE_SET = "HasInitialObjectiveSet";
    private const string BB_IS_ATTACKING = "IsAttacking";
    private const string BB_IS_CAPTURING = "IsCapturing";
    private const string BB_IS_DEFENDING = "IsDefending"; 
    private const string BB_IS_OBJECTIVE_COMPLETED = "IsObjectiveCompleted"; // Pour signaler la fin de l'objectif

    // Variables Blackboard mises en cache
    private BlackboardVariable<bool> bbHasBannerTarget;
    private BlackboardVariable<Vector2Int> bbBannerTargetPosition;
    private BlackboardVariable<Vector2Int> bbFinalDestinationPosition;
    private BlackboardVariable<Building> bbInitialTargetBuilding;
    private BlackboardVariable<bool> bbHasInitialObjectiveSet;
    private BlackboardVariable<bool> bbIsAttacking;
    private BlackboardVariable<bool> bbIsCapturing;
    private BlackboardVariable<bool> bbIsObjectiveCompleted;
    private BlackboardVariable<bool> bbIsDefending; 
    // Nouvelle variable Blackboard pour la défense
    private BlackboardVariable<bool> bbDefendedBuildingIsUnderAttack;
    // Nouvelle variable Blackboard pour l'ennemi détecté
    private BlackboardVariable<Unit> bbDetectedEnemyUnit;

    [Header("Ally Settings")]
    [SerializeField] public bool enableVerboseLogging = true; // Public pour que les nœuds puissent vérifier

    private Building initialObjectiveBuildingInstance;
    private bool hasInitialObjectiveBeenSetThisLife = false;
    private UnitSpawnFeedback spawnFeedbackPlayer;
    public PlayerBuilding currentReserveBuilding;
    public Tile currentReserveTile;

	public float MomentumGainOnObjectiveComplete; 

    protected override IEnumerator Start()
    {
        yield return StartCoroutine(base.Start());

        if (m_Agent == null) m_Agent = GetComponent<BehaviorGraphAgent>();
        spawnFeedbackPlayer = GetComponent<UnitSpawnFeedback>();

        if (m_Agent == null)
        {
            Debug.LogError($"[{name}] BehaviorGraphAgent component not found on {gameObject.name}! AI will not run.", gameObject);
            SetSpawningState(false);
            yield break;
        }


        if (spawnFeedbackPlayer != null)
        {
            LogAlly($"SpawnFeedbackPlayer trouvé. Désactivation de l'agent '{m_Agent.name}' pour la séquence de spawn.");
            m_Agent.enabled = false; 

            bool localSpawnCompletedSignal = false; // Flag local pour la coroutine Start
            spawnFeedbackPlayer.OnSpawnCompleted += () => {
                localSpawnCompletedSignal = true;
                LogAlly("Signal OnSpawnCompleted reçu de UnitSpawnFeedback.");
            };

            LogAlly("Lancement de PlaySpawnFeedback...");
            spawnFeedbackPlayer.PlaySpawnFeedback(); // Lance la séquence de feedback

            LogAlly("En attente de la fin de la séquence de spawn (WaitUntil)...");
            yield return new WaitUntil(() => localSpawnCompletedSignal); // Attend que le feedback soit terminé
            LogAlly("Fin de la séquence de spawn signalée.");
        }
        else
        {
            LogAlly("UnitSpawnFeedback non trouvé. Passage direct à l'initialisation de l'IA.", true); // isWarning = true
            SetSpawningState(false); 
        }
        
        LogAlly($"Réactivation de l'agent '{m_Agent.name}'.");
        m_Agent.enabled = true;

        if (m_Agent.BlackboardReference == null)
        {
            Debug.LogError($"[{name}] BlackboardReference est null sur BehaviorGraphAgent APRES l'avoir réactivé! AI pourrait mal fonctionner.", gameObject);
            // Pas de yield break ici, car le reste de l'initialisation pourrait être utile
        }
        else
        {
            LogAlly("Mise en cache des variables Blackboard...");
            CacheBlackboardVariables();
            InitializeBlackboardFlags();
            Building.OnBuildingAttackedByUnit += HandleBuildingAttackedByUnit;
        }

        if (AllyUnitRegistry.Instance != null)
        {
            AllyUnitRegistry.Instance.RegisterUnit(this);
            LogAlly($"Enregistré auprès de AllyUnitRegistry.");
        }
        else
        {
            Debug.LogWarning($"[{name}] AllyUnitRegistry.Instance non trouvé. Impossible de s'enregistrer.");
        }

        if (BannerController.Exists)
        {
            BannerController.Instance.AddObserver(this);
            LogAlly("Abonné à BannerController.");
            if (BannerController.Instance.HasActiveBanner && !hasInitialObjectiveBeenSetThisLife)
            {
                LogAlly("Bannière active détectée au spawn, définition de l'objectif initial.");
            }
        }
        else
        {
            LogAlly("BannerController n'existe pas. Pas d'abonnement ni d'objectif initial via bannière.", true);
        }
        LogAlly("Initialisation de AllyUnit terminée. L'IA devrait prendre le relais.");
    }
    
    private void InitializeBlackboardFlags()
    {
        if(m_Agent == null || m_Agent.BlackboardReference == null) {
            LogAlly("Impossible d'initialiser les flags du Blackboard, agent ou référence null.", true);
            return;
        }
        LogAlly("Initialisation des flags du Blackboard...");
        if (bbHasBannerTarget != null) bbHasBannerTarget.Value = false;
        else LogAlly("bbHasBannerTarget non mis en cache.", true);

        if (bbHasInitialObjectiveSet != null) bbHasInitialObjectiveSet.Value = false;
        else LogAlly("bbHasInitialObjectiveSet non mis en cache.", true);

        if (bbIsAttacking != null) bbIsAttacking.Value = false;
        else LogAlly("bbIsAttacking non mis en cache.", true);

        if (bbIsCapturing != null) bbIsCapturing.Value = false;
        else LogAlly("bbIsCapturing non mis en cache.", true);

        if (bbIsDefending != null) bbIsDefending.Value = false; // Ajouté
        else LogAlly("bbIsDefending non mis en cache.", true); // Ajouté

        if (bbIsObjectiveCompleted != null) bbIsObjectiveCompleted.Value = false;
        else LogAlly("bbIsObjectiveCompleted non mis en cache.", true);
        LogAlly("Flags du Blackboard initialisés.");
    }

    private void LogAlly(string message, bool isWarning = false)
    {
        if (enableVerboseLogging || isWarning)
        {
            string logMessage = $"[{name}] {message}";
            if (isWarning) Debug.LogWarning(logMessage, gameObject);
            else Debug.Log(logMessage, gameObject);
        }
    }


    private void CacheBlackboardVariables()
    {
        var blackboardRef = m_Agent.BlackboardReference;
        if (blackboardRef == null) return; // Déjà géré dans Start, mais sécurité

        // Variables liées à la bannière et à l'objectif initial
        blackboardRef.GetVariable(BB_HAS_BANNER_TARGET, out bbHasBannerTarget);
        blackboardRef.GetVariable(BB_BANNER_TARGET_POSITION, out bbBannerTargetPosition);
        blackboardRef.GetVariable(BB_FINAL_DESTINATION_POSITION, out bbFinalDestinationPosition);
        blackboardRef.GetVariable(BB_INITIAL_TARGET_BUILDING, out bbInitialTargetBuilding);
        blackboardRef.GetVariable(BB_HAS_INITIAL_OBJECTIVE_SET, out bbHasInitialObjectiveSet);
        if (!blackboardRef.GetVariable(BB_IS_DEFENDING, out bbIsDefending))
        {
            LogAlly($"La variable Blackboard '{BB_IS_DEFENDING}' est manquante. La logique de défense pourrait ne pas fonctionner.", true);
        }
        // Nouvelle variable Blackboard pour la défense du bâtiment
        if (!blackboardRef.GetVariable("DefendedBuildingIsUnderAttack", out bbDefendedBuildingIsUnderAttack))
        {
            LogAlly("Blackboard variable 'DefendedBuildingIsUnderAttack' is missing. Defensive alert logic may not work.", true);
        }
        // Nouvelle variable Blackboard pour l'ennemi détecté
        if (!blackboardRef.GetVariable("DetectedEnemyUnit", out bbDetectedEnemyUnit))
        {
            LogAlly("Blackboard variable 'DetectedEnemyUnit' is missing. Enemy detection logic may not work.", true);
        }
        // Variables d'état de l'unité
        blackboardRef.GetVariable(BB_IS_ATTACKING, out bbIsAttacking);
        blackboardRef.GetVariable(BB_IS_CAPTURING, out bbIsCapturing);
        blackboardRef.GetVariable(BB_IS_OBJECTIVE_COMPLETED, out bbIsObjectiveCompleted);
        
        
    }

    protected override Vector2Int? TargetPosition
    {
        get
        {
            // Si l'unité est en train d'attaquer ou de capturer, elle ne devrait pas avoir de
            // cible de mouvement active via cette propriété. Le Behavior Graph gère cela.
            bool isCurrentlyAttacking = bbIsAttacking?.Value ?? false;
            bool isCurrentlyCapturing = bbIsCapturing?.Value ?? false;

            if (isCurrentlyAttacking || isCurrentlyCapturing)
            {
                // Si une action est en cours, la cible de mouvement n'est pas pertinente via cette propriété.
                // Le nœud d'action spécifique (Attack, Capture) gère la position de l'unité.
                return null;
            }

            return bbFinalDestinationPosition.Value;

        }
    }

    public void OnBannerPlaced(int column, int row)
    {
        if (m_Agent == null || bbHasBannerTarget == null || bbBannerTargetPosition == null)
        {
            return;
        }

        Vector2Int newBannerPosition = new Vector2Int(column, row);
        bbHasBannerTarget.Value = true;
        bbBannerTargetPosition.Value = newBannerPosition;

        // Si l'objectif initial n'a pas encore été fixé pour cette unité (durant sa vie actuelle)
        if (!hasInitialObjectiveBeenSetThisLife)
    	{
        	LogAlly($"Définition de l'objectif initial à la position de la bannière: ({newBannerPosition.x},{newBannerPosition.y})");
        	//SetInitialObjectiveFromPosition(newBannerPosition);
    	}
    	else
		{
            //Log ally la valeur dans le BB
            LogAlly($"bbHasInitialObjectiveSet : {bbHasInitialObjectiveSet.Value}, bbInitialTargetBuilding : {bbInitialTargetBuilding.Value?.name ?? "null"}");
        	LogAlly($"Bannière déplacée vers ({newBannerPosition.x},{newBannerPosition.y}) mais objectif déjà fixé - ignoré.");
    	}
        // Si l'objectif initial a déjà été fixé, le Behavior Graph décidera s'il doit
        // abandonner l'objectif initial pour suivre la nouvelle position de la bannière.
        // Pour l'instant, FindSmartStepNode utilise toujours FinalDestinationPosition,
        // qui est lié à InitialTargetBuilding. On pourrait ajouter une logique ici ou dans le graph
        // pour redéfinir FinalDestinationPosition si la bannière bouge de manière significative
        // par rapport à l'objectif initial, ou si l'objectif initial est complété/détruit.
    }

    private void SetInitialObjectiveFromPosition(Vector2Int position)
    {
        if (hasInitialObjectiveBeenSetThisLife) // Ne pas redéfinir si déjà fait une fois.
        {
            return;
        }

        if (bbInitialTargetBuilding == null || bbHasInitialObjectiveSet == null || bbFinalDestinationPosition == null)
            return;

        Building buildingAtPos = FindBuildingAtPosition(position); // S'assure que la tuile et le bâtiment existent

        if (buildingAtPos != null)
        {
            UnsubscribeFromInitialBuildingEvents(); // Se désabonner de l'ancien si existant

            initialObjectiveBuildingInstance = buildingAtPos; // Garder une référence directe
            bbInitialTargetBuilding.Value = buildingAtPos;
            bbHasInitialObjectiveSet.Value = true;
            hasInitialObjectiveBeenSetThisLife = true; // Marquer comme défini pour cette vie

            // La destination finale pour le pathfinding devient la tuile de ce bâtiment initial
            Tile buildingTile = buildingAtPos.GetOccupiedTile();
            if (buildingTile != null)
            {
                bbFinalDestinationPosition.Value = new Vector2Int(buildingTile.column, buildingTile.row);
            }
            else
            {
                Debug.LogWarning($"[{name}] Building '{buildingAtPos.name}' has no occupied tile. Setting FinalDestinationPosition to an invalid position.");
                // Fallback: ne pas définir de FinalDestinationPosition ou la mettre à une position invalide
                bbHasInitialObjectiveSet.Value = false; // Marquer comme échec
                hasInitialObjectiveBeenSetThisLife = false;
                initialObjectiveBuildingInstance = null;
            }
            SubscribeToInitialBuildingEvents();
        }
        else
        {
            bbInitialTargetBuilding.Value = null;
            bbHasInitialObjectiveSet.Value = false;
            LogAlly("Aucun bâtiment trouvé à la position de la bannière. Objectif initial non défini.", true);
            // Laisser FinalDestinationPosition telle quelle ou la mettre à la position actuelle de l'unité si pas d'autre cible.
            // Si bbFinalDestinationPosition n'a pas de valeur valide, FindSmartStepNode devrait échouer proprement.
        }
    }

    private void SubscribeToInitialBuildingEvents()
    {
        if (initialObjectiveBuildingInstance != null)
        {
            // S'abonner aux deux événements: destruction ET changement d'équipe
            Building.OnBuildingDestroyed += HandleInitialBuildingEvent;
            Building.OnBuildingTeamChangedGlobal += HandleInitialBuildingTeamChange; // NOUVEL ABONNEMENT
            if (enableVerboseLogging) Debug.Log($"[{name}] Subscribed to OnBuildingDestroyed AND OnBuildingTeamChangedGlobal for '{initialObjectiveBuildingInstance.name}'.");
        }
    }

    private void UnsubscribeFromInitialBuildingEvents()
    {
        if (initialObjectiveBuildingInstance != null) // Toujours vérifier avant de se désabonner
        {
            Building.OnBuildingDestroyed -= HandleInitialBuildingEvent;
            Building.OnBuildingTeamChangedGlobal -= HandleInitialBuildingTeamChange; // NOUVEAU DÉSABONNEMENT
            if (enableVerboseLogging) Debug.Log($"[{name}] Unsubscribed from OnBuildingDestroyed AND OnBuildingTeamChangedGlobal for '{initialObjectiveBuildingInstance.name}'.");
        }
    }

    private void HandleInitialBuildingEvent(Building buildingEventSource)
    {
        // Vérifier si c'est bien notre bâtiment objectif initial ET qu'il a été détruit
        if (buildingEventSource == initialObjectiveBuildingInstance && buildingEventSource.CurrentHealth <= 0)
        {
            SignalObjectiveCompleted(); // Met bbIsObjectiveCompleted à true

            UnsubscribeFromInitialBuildingEvents();
            initialObjectiveBuildingInstance = null;
        }
        // Gérer aussi le cas de la capture par le joueur
        else if (buildingEventSource == initialObjectiveBuildingInstance && buildingEventSource.Team == TeamType.Player &&
                 (initialObjectiveBuildingInstance.Team == TeamType.Neutral || initialObjectiveBuildingInstance.Team == TeamType.Enemy)) // On vient de le capturer
        {
            SignalObjectiveCompleted();

            UnsubscribeFromInitialBuildingEvents();
            initialObjectiveBuildingInstance = null;
        }
    }

    private void HandleInitialBuildingTeamChange(Building buildingEventSource, TeamType oldTeam, TeamType newTeam)
    {
        if (buildingEventSource == initialObjectiveBuildingInstance)
        {
            if (newTeam == TeamType.Player && oldTeam != TeamType.Player) // Si le bâtiment devient allié (et ne l'était pas avant)
            {
                if (enableVerboseLogging) Debug.Log($"[{name}] Initial objective '{buildingEventSource.name}' was CAPTURED by Player (Team changed from {oldTeam} to {newTeam}).");
                SignalObjectiveCompleted();
            }
        }
    }

    private void CheckObjectiveCompletionAndSignal()
    {
        if (bbIsObjectiveCompleted != null && !(bbIsObjectiveCompleted.Value)) // Only signal once
        {
            if (enableVerboseLogging) Debug.Log($"[{name}] Signaling objective completed to Behavior Graph.");
            bbIsObjectiveCompleted.Value = true;
            // The SelectTargetNode will now pick up this flag.
        }
        // Clean up direct instance and subscriptions as objective is resolved
        UnsubscribeFromInitialBuildingEvents();
        initialObjectiveBuildingInstance = null;
        // bbHasInitialObjectiveSet remains true, but bbInitialTargetBuilding might be null or its state changed.
        // The graph needs bbIsObjectiveCompleted to take precedence.
    }

    // --- Helper Methods (Called by Custom Nodes) ---
    public Unit FindNearestEnemyUnit()
    {
        if (occupiedTile == null || HexGridManager.Instance == null) return null;
        var tilesInRange = HexGridManager.Instance.GetTilesWithinRange(occupiedTile.column, occupiedTile.row, DetectionRange);
        Unit nearestUnit = null;
        float nearestDistSq = float.MaxValue;
        Vector3 currentPos = transform.position;
        foreach (var tile in tilesInRange)
        {
            if (tile.currentUnit != null && IsValidUnitTarget(tile.currentUnit))
            {
                float distSq = (tile.currentUnit.transform.position - currentPos).sqrMagnitude;
                if (distSq < nearestDistSq) { nearestDistSq = distSq; nearestUnit = tile.currentUnit; }
            }
        }
        return nearestUnit;
    }

    protected override void OnRhythmBeat(float beatDuration)
    {
        // La logique de cette méthode était vide dans la classe AllyUnit, donc rien à changer à l'intérieur.
        // Seule la signature est importante pour la compilation.
    }

    public Building FindNearestEnemyBuilding()
    {
        if (occupiedTile == null || HexGridManager.Instance == null) return null;
        var tilesInRange = HexGridManager.Instance.GetTilesWithinRange(occupiedTile.column, occupiedTile.row, DetectionRange);
        Building nearestBuilding = null;
        float nearestDistSq = float.MaxValue;
        Vector3 currentPos = transform.position;
        foreach (var tile in tilesInRange)
        {
            if (tile.currentBuilding != null && tile.currentBuilding.Team == TeamType.Enemy && IsValidBuildingTarget(tile.currentBuilding))
            {
                float distSq = (tile.currentBuilding.transform.position - currentPos).sqrMagnitude;
                if (distSq < nearestDistSq) { nearestDistSq = distSq; nearestBuilding = tile.currentBuilding; }
            }
        }
        return nearestBuilding;
    }

    public Building FindBuildingAtPosition(Vector2Int pos)
    {
        if (HexGridManager.Instance == null)
        {
            Debug.LogError($"[{name}] HexGridManager.Instance is null in FindBuildingAtPosition. Cannot find building.");
            return null;
        }
        Tile targetTile = HexGridManager.Instance.GetTileAt(pos.x, pos.y);
        if (targetTile == null)
        {
            // if (enableVerboseLogging) Debug.LogWarning($"[{name}] No tile found at position ({pos.x},{pos.y}) in FindBuildingAtPosition.");
            return null;
        }
        return targetTile.currentBuilding;
    }

    public Unit FindUnitAtPosition(Vector2Int pos)
    {
        if (HexGridManager.Instance == null) return null;
        Tile targetTile = HexGridManager.Instance.GetTileAt(pos.x, pos.y);
        return targetTile?.currentUnit;
    }

    public override bool IsValidUnitTarget(Unit otherUnit) => otherUnit is EnemyUnit;
    public override bool IsValidBuildingTarget(Building building)
    {
        if (building == null || !building.IsTargetable) return false;
        return building.Team == TeamType.Enemy || building.Team == TeamType.Player || building.Team == TeamType.Neutral;
    }

    public override  bool PerformCapture(Building building)
    {
        NeutralBuilding neutralBuilding = building as NeutralBuilding;
        if (neutralBuilding == null || !neutralBuilding.IsRecapturable || (neutralBuilding.Team != TeamType.Neutral && neutralBuilding.Team != TeamType.Enemy))
        {
            if (enableVerboseLogging) Debug.Log($"[{name}] Cannot capture {building.name}. Not Neutral or Enemy Recapturable.");
            return false;
        }
        if (!IsBuildingInCaptureRange(neutralBuilding))
        {
            if (enableVerboseLogging) Debug.Log($"[{name}] Cannot capture {building.name}. Out of range.");
            return false;
        }
        currentState = UnitState.Capturing; // Mettre à jour l'état de l'unité

        FaceBuildingTarget(building);
        bool success = neutralBuilding.StartCapture(TeamType.Player, this);

        if (success)
        {
            buildingBeingCaptured = neutralBuilding;
            beatsSpentCapturing = 0;
            return true;
        }
        else
        {
            return false;
        }
    }

    public override void OnCaptureComplete() // Appelée par NeutralBuilding lorsque la capture est terminée par une unité.
    {
    Building buildingJustCaptured = this.buildingBeingCaptured; // Récupérer la référence AVANT de la nullifier

    if (enableVerboseLogging) Debug.Log($"[{name}] Received OnCaptureComplete notification for building '{(buildingJustCaptured != null ? buildingJustCaptured.name : "Unknown (was null)")}'.");

    // Réinitialiser l'état de capture de l'unité
    this.buildingBeingCaptured = null;
    this.beatsSpentCapturing = 0;
    // Note: SetState(UnitState.Idle) sera probablement géré par le Behavior Graph
    // lorsque IsCapturing deviendra false et qu'aucune autre action n'est choisie.

    // Mettre à jour le flag IsCapturing sur le Blackboard
    if (bbIsCapturing != null) // Assurez-vous que bbIsCapturing est mis en cache dans AllyUnit
    {
        bbIsCapturing.Value = false;
        if (enableVerboseLogging) Debug.Log($"[{name}] Set Blackboard '{BB_IS_CAPTURING}' to false.");
    }
    else
    {
        Debug.LogWarning($"[{name}] bbIsCapturing not cached/found in OnCaptureComplete. Blackboard flag not updated.");
    }

    if (initialObjectiveBuildingInstance != null && buildingJustCaptured == initialObjectiveBuildingInstance)
    {
        if (enableVerboseLogging) Debug.Log($"[{name}] Unit that completed capture: '{buildingJustCaptured.name}' WAS the initial objective. Ensuring SignalObjectiveCompleted.");
        SignalObjectiveCompleted(); // S'assure que c'est signalé, même si l'event global le ferait aussi.
    }
    else
    {
        if (enableVerboseLogging && initialObjectiveBuildingInstance != null)
        {
            Debug.LogWarning($"[{name}] Captured building '{(buildingJustCaptured != null ? buildingJustCaptured.name : "N/A")}' was NOT the initial objective '{initialObjectiveBuildingInstance.name}'.");
        }
        else if (enableVerboseLogging && initialObjectiveBuildingInstance == null)
        {
             Debug.Log($"[{name}] Captured building '{(buildingJustCaptured != null ? buildingJustCaptured.name : "N/A")}'. No initial objective was set or it was already cleared.");
        }
    }

}

    private void SignalObjectiveCompleted()
    {
        if (bbIsObjectiveCompleted != null && !bbIsObjectiveCompleted.Value)
        {
            if (enableVerboseLogging) Debug.Log($"[{name}] Signaling objective completed to Behavior Graph (setting '{BB_IS_OBJECTIVE_COMPLETED}' to true).");
            bbIsObjectiveCompleted.Value = true;
            UnsubscribeFromInitialBuildingEvents(); // Important de le faire ici
            initialObjectiveBuildingInstance = null;
        }
        else if (bbIsObjectiveCompleted == null)
        {
            Debug.LogError($"[{name}] Cannot signal objective completion: bbIsObjectiveCompleted is not cached!");
        }
    }


	public override void StopCapturing()
	{
    	if (currentState == UnitState.Capturing || buildingBeingCaptured != null)
    	{
        	if (enableVerboseLogging) Debug.Log($"[{name}] StopCapturing called. Was capturing: '{(buildingBeingCaptured != null ? buildingBeingCaptured.name : "N/A")}'");

	        Building buildingWeWereCapturing = this.buildingBeingCaptured;
	
        if (buildingWeWereCapturing != null)
        {
            // Important: S'assurer que buildingWeWereCapturing est bien un NeutralBuilding avant de caster
            NeutralBuilding nb = buildingWeWereCapturing as NeutralBuilding;
            if (nb != null)
            {
                nb.StopCapturing(this); // Notifier le bâtiment
            }
            else
    	        {
                Debug.LogWarning($"[{name}] Attempted to stop capturing a building '{buildingWeWereCapturing.name}' that is not a NeutralBuilding type.");
            }
        }

        this.buildingBeingCaptured = null;
        this.beatsSpentCapturing = 0;
        // SetState(UnitState.Idle); // Laisser le graph décider

        if (bbIsCapturing != null)
        {
            bbIsCapturing.Value = false;
             if (enableVerboseLogging) Debug.Log($"[{name}] Set Blackboard '{BB_IS_CAPTURING}' to false via StopCapturing.");
        }
        else
        {
            Debug.LogWarning($"[{name}] bbIsCapturing not cached/found in StopCapturing. Blackboard flag not updated.");
        }
        // isInteractingWithBuilding = false; // Laisser le graph gérer cela aussi

    	}
	}

    // Handler pour l'événement d'attaque sur bâtiment
    private void HandleBuildingAttackedByUnit(Building building, Unit attacker)
    {
        // Si cette unité défend ce bâtiment, on met à jour la variable Blackboard
        if (currentReserveBuilding != null && building == currentReserveBuilding)
        {
            if (bbDefendedBuildingIsUnderAttack != null)
            {
                bbDefendedBuildingIsUnderAttack.Value = true;
                if (enableVerboseLogging)
                    Debug.Log($"[{name}] Defended building '{building.name}' is under attack! Blackboard flag set.");
            }
        }
    }

    /// <summary>
    /// Appelée directement par le PlayerBuilding lorsqu'il est attaqué, pour notifier cette unité si elle défend ce bâtiment.
    /// </summary>
    public void OnDefendedBuildingAttacked(Building building, Unit attacker)
    {
        if (currentReserveBuilding != null && building == currentReserveBuilding)
        {
            if (bbDefendedBuildingIsUnderAttack != null)
            {
                bbDefendedBuildingIsUnderAttack.Value = true;
                if (enableVerboseLogging)
                    Debug.Log($"[{name}] (Direct) Defended building '{building.name}' is under attack by '{attacker?.name ?? "Unknown"}'. Blackboard flag set.");
                //on va devoir aussi faire en sorte d'enregistrer l'attaquant dans le BB, on peut utiliser bbDetectedEnemyUnit 
                if (bbDetectedEnemyUnit != null && attacker != null && IsValidUnitTarget(attacker))
                {
                    bbDetectedEnemyUnit.Value = attacker; // Enregistrer l'attaquant dans le BB
                    if (enableVerboseLogging)
                        Debug.Log($"[{name}] Detected enemy unit '{attacker.name}' attacking defended building '{building.name}'.");
                }
            }
        }
    }

    public override void OnDestroy()
    {
        if (AllyUnitRegistry.Instance != null)
        {
            AllyUnitRegistry.Instance.UnregisterUnit(this);
            if (enableVerboseLogging && Application.isPlaying) // Vérifier Application.isPlaying pour éviter les logs en sortie d'éditeur
            {
                Debug.Log($"[{name}] s'est désenregistré de AllyUnitRegistry.");
            }
        }

        UnsubscribeFromInitialBuildingEvents(); // Ensure cleanup
        ClearCurrentReservePosition();
        initialObjectiveBuildingInstance = null;

        // Désabonnement de l'événement d'attaque sur bâtiment
        Building.OnBuildingAttackedByUnit -= HandleBuildingAttackedByUnit;

        base.OnDestroy();

    }
	
     public void SetReservePosition(PlayerBuilding building, Tile reserveTile)
    {
        // 1. Si on avait une ancienne position de réserve (différente ou sur un autre bâtiment), la libérer.
        if (currentReserveBuilding != null && currentReserveTile != null)
        {
            // Si le nouveau bâtiment est différent OU si la nouvelle tuile est différente dans le même bâtiment
            if (currentReserveBuilding != building || currentReserveTile != reserveTile)
            {
                currentReserveBuilding.ReleaseReserveTile(currentReserveTile, this);
                LogAlly($"Ancienne position de réserve ({currentReserveTile.column},{currentReserveTile.row}) chez {currentReserveBuilding.name} libérée.");
            }
        }

        // 2. Assigner la nouvelle position de réserve
        currentReserveBuilding = building;
        currentReserveTile = reserveTile;

        if (currentReserveBuilding != null && currentReserveTile != null)
        {
            // L'assignation effective sur le bâtiment est importante
            bool success = currentReserveBuilding.AssignUnitToReserveTile(this, currentReserveTile);
            if (success) {
                LogAlly($"Nouvelle position de réserve assignée : ({currentReserveTile.column},{currentReserveTile.row}) chez {currentReserveBuilding.name}.");
            } else {
                LogAlly($"ÉCHEC de l'assignation à la position de réserve ({currentReserveTile.column},{currentReserveTile.row}) chez {currentReserveBuilding.name}.", true);
                // Si l'assignation échoue, on devrait peut-être nullifier currentReserveTile/Building pour éviter des états incohérents
                this.currentReserveBuilding = null;
                this.currentReserveTile = null;
            }
        } else {
            LogAlly("Tentative de SetReservePosition avec building ou tile null.", true);
        }
    }

    public void ClearCurrentReservePosition()
    {
        if (currentReserveBuilding != null && currentReserveTile != null)
        {
            currentReserveBuilding.ReleaseReserveTile(currentReserveTile, this);
        }
        
        currentReserveBuilding = null;
        currentReserveTile = null;
    }

    // Override de OnMovementComplete pour gérer les réserves
    public override void OnMovementComplete()
    {
        base.OnMovementComplete();
        
        // Si on arrive sur une case de réserve, s'assurer qu'elle est bien assignée
        if (currentReserveTile != null && occupiedTile == currentReserveTile)
        {
            if (enableVerboseLogging) 
                Debug.Log($"[{name}] Arrived at reserve position ({currentReserveTile.column},{currentReserveTile.row})");
        }
    }

}


// --- FILE: Scripts/Units/AllyUnitBlackboardInitializer.cs ---
using UnityEngine;
using Unity.Behavior;
public class AllyUnitBlackboardInitializer : MonoBehaviour
{
    private BehaviorGraphAgent m_Agent;

    void Start()
    {
        m_Agent = GetComponent<BehaviorGraphAgent>();
        var allyUnit = GetComponent<Unit>(); // Bien, tu récupères le composant en tant que Unit

        if (m_Agent == null) Debug.LogError($"[{gameObject.name}] Initializer: m_Agent is NULL.");
        else if (m_Agent.BlackboardReference == null) Debug.LogError($"[{gameObject.name}] Initializer: m_Agent.BlackboardReference is NULL.");

        // Cette vérification est bonne
        if (allyUnit == null) Debug.LogError($"[{gameObject.name}] Initializer: allyUnit component (of type Unit) is NULL.");

        if (m_Agent == null || m_Agent.BlackboardReference == null || allyUnit == null)
        {
            Debug.LogError($"[{gameObject.name}] Initializer missing critical components! Cannot set SelfUnit.", gameObject);
            return;
        }

        var blackboardRef = m_Agent.BlackboardReference;

        // La variable sur le Blackboard doit être de type Unit (ou un parent compatible)
        BlackboardVariable<Unit> bbSelfUnitForGraph;
        if (blackboardRef.GetVariable("SelfUnit", out bbSelfUnitForGraph)) // Clé "SelfUnit"
        {
            bbSelfUnitForGraph.Value = allyUnit; // C'est correct, tu assignes l'instance de Unit (qui est en fait ton AllyUnit)
            Debug.Log($"[{gameObject.name}] Initializer: Successfully set 'SelfUnit' on Blackboard with component of type {allyUnit.GetType().Name}.", gameObject);
        }
        else
        {
            // Cette erreur est cruciale si elle apparaît
            Debug.LogError($"[{gameObject.name}] Initializer: Blackboard variable 'SelfUnit' (expecting type Unit) NOT FOUND on the Blackboard Asset. Ensure it exists and is correctly named.", gameObject);
        }
    }
}

// --- FILE: Scripts/Units/BossUnit.cs ---
// Fichier: Scripts2/Units/BossUnit.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using ScriptableObjects;

[RequireComponent(typeof(AudioSource))]
public class BossUnit : EnemyUnit
{
    // --- L'INTERRUPTEUR ---
    protected override bool IsHardcoded => true;

    [Header("Boss Settings")]
    public Vector2Int FinalDestinationCoordinates;

    [Header("Stun Mechanic")]
    [Tooltip("Nombre de coups reçus avant que le boss ne soit étourdi.")]
    public int HitsToStun = 10;
    [Tooltip("Durée de l'étourdissement en nombre de battements (beats).")]
    public int StunDurationInBeats = 8;

    [Header("Stun Effects")]
    [Tooltip("Le préfabriqué de l'effet visuel à instancier lors de l'étourdissement.")]
    [SerializeField] private GameObject stunVFX;
    [Tooltip("Effet sonore à jouer lorsque le boss est étourdi (Optionnel).")]
    [SerializeField] private AudioClip stunSFX;
    [Tooltip("Le décalage en hauteur (axe Y) pour l'effet visuel d'étourdissement.")]
    [SerializeField] private float stunVFX_Y_Offset = 2.5f;

    // NOUVEAU: Effets pour la destruction du boss
    [Header("Destruction Effects")]
    [Tooltip("Le préfabriqué de l'effet visuel à instancier lors de la destruction du boss.")]
    [SerializeField] private GameObject destructionVFX;
    [Tooltip("Effet sonore à jouer lorsque le boss est détruit (Optionnel).")]
    [SerializeField] private AudioClip destructionSFX;

    // --- Variables privées ---
    private int _currentHitCounter = 0;
    private int _stunBeatCounter = 0;
    private bool _isStunned = false;
    private int _maximumHealth = 0;

    // --- Références aux composants ---
    private BossMovementSystem bossMovementSystem;
    private AudioSource audioSource;

    protected override Vector2Int? TargetPosition => FinalDestinationCoordinates;

    // --- GESTION DES DÉGÂTS ET DE LA MORT ---

    /// <summary>
    /// Prend des dégâts basés sur un pourcentage de la vie maximale.
    /// </summary>
    public void TakePercentageDamage(float percentage)
    {
        if (percentage <= 0) return;
        int damageToTake = Mathf.RoundToInt(_maximumHealth * (percentage / 100f));
        Health -= damageToTake;

        if (Health <= 0)
        {
            Health = 0;
            Die(); // Le boss est vaincu !
        }
    }

    /// <summary>
    /// NOUVEAU: Gère la séquence de destruction du boss.
    /// </summary>
    protected override void Die()
    {
        if (enableVerboseLogging) Debug.Log($"[BossUnit] Le boss a été vaincu ! Lancement de la séquence de destruction.");

        // On libère les tuiles occupées pour éviter les problèmes
        UnreserveAllTiles();

        // On s'assure que le boss ne peut plus rien faire
        StopAllCoroutines();
        this.enabled = false;

        // On joue les effets de destruction
        if (destructionVFX != null)
        {
            Instantiate(destructionVFX, transform.position, Quaternion.identity);
        }
        if (audioSource != null && destructionSFX != null)
        {
            // On joue le son à la position du boss, pour qu'il ne soit pas coupé lors de la destruction de l'objet
            AudioSource.PlayClipAtPoint(destructionSFX, transform.position);
        }

        // On appelle la méthode de base qui s'occupe de détruire le GameObject
        base.Die();
    }

    /// <summary>
    /// Les attaques des unités ne font que contribuer à l'étourdissement.
    /// </summary>
    public override void TakeDamage(int damage, Unit attacker = null)
    {
        if (_isStunned) return;
        _currentHitCounter++;
        if (_currentHitCounter >= HitsToStun)
        {
            StopAllCoroutines();
            IsMoving = false;
            SetState(UnitState.Idle);
            StartCoroutine(StunSequence());
        }
    }

    private IEnumerator StunSequence()
    {
        if (enableVerboseLogging) Debug.Log($"[BossUnit] ÉTOURDI pour {StunDurationInBeats} battements !");

        _isStunned = true;
        _stunBeatCounter = StunDurationInBeats;
        _currentHitCounter = 0;

        GameObject stunEffectInstance = null;
        if (stunVFX != null)
        {
            Vector3 spawnPosition = transform.position + new Vector3(0, stunVFX_Y_Offset, 0);
            stunEffectInstance = Instantiate(stunVFX, spawnPosition, Quaternion.identity);
        }
        if (audioSource != null && stunSFX != null)
        {
            audioSource.PlayOneShot(stunSFX);
        }

        yield return new WaitUntil(() => !_isStunned);

        if (enableVerboseLogging) Debug.Log("[BossUnit] L'étourdissement est terminé.");

        if (stunEffectInstance != null) Destroy(stunEffectInstance);
    }

    // --- GESTION DU RYTHME ---
    protected override void OnRhythmBeat(float beatDuration)
    {
        if (_isStunned)
        {
            _stunBeatCounter--;
            if (_stunBeatCounter <= 0) _isStunned = false;
            return;
        }

        // MISE À JOUR: Logique pour détruire le bâtiment cible
        if (IsAtTargetLocation())
        {
            _beatCounter++;
            if (_beatCounter >= MovementDelay)
            {
                _beatCounter = 0;
                DestroyTargetBuilding();
            }
            return; // On ne fait rien d'autre si on a atteint la destination
        }

        if (currentState == UnitState.Idle) UpdateFacingDirectionSafe();
        if (IsMoving) return;
        int moveDelay = MovementDelay;
        if (moveDelay <= 0) return;

        _beatCounter++;
        if (_beatCounter == moveDelay - 2)
        {
            if (AttackSystem != null)
            {
                StopCoroutine(nameof(AttackSystem.PerformAttack));
                SetState(UnitState.Attacking);
                StartCoroutine(AttackSystem.PerformAttack(transform, null, Attack, beatDuration));
            }
        }
        else if (_beatCounter >= moveDelay)
        {
            _beatCounter = 0;
            StartCoroutine(AdvanceOneRow());
        }
    }

    // --- INITIALISATION ET CYCLES DE VIE ---
    protected override IEnumerator Start()
    {
        yield return base.Start();
        bossMovementSystem = GetComponent<BossMovementSystem>();
        audioSource = GetComponent<AudioSource>();
        _maximumHealth = Health;
        if (bossMovementSystem == null) Debug.LogError("Le composant BossMovementSystem est manquant !");
        yield return new WaitForEndOfFrame();
        OccupyAdjacentTiles();
    }

    protected override void OnEnable()
    {
        if (MusicManager.Instance != null) MusicManager.Instance.OnBeat += OnRhythmBeat;
    }

    protected override void OnDisable()
    {
        if (MusicManager.Instance != null) MusicManager.Instance.OnBeat -= OnRhythmBeat;
    }

    // --- MOUVEMENT ET ACTION FINALE ---

    /// <summary>
    /// NOUVEAU: Trouve et détruit le bâtiment sur la tuile de destination finale.
    /// </summary>
    private void DestroyTargetBuilding()
    {
        if (!TargetPosition.HasValue) return;

        Tile targetTile = HexGridManager.Instance.GetTileAt(TargetPosition.Value.x, TargetPosition.Value.y);
        if (targetTile != null)
        {
            // Note: On suppose que la classe Tile a un moyen de trouver le bâtiment qui l'occupe.
            // "GetOccupyingBuilding()" est une supposition, vous devrez peut-être l'adapter à votre code.
            Building targetBuilding = ((Unit)this).targetBuilding;

            if (targetBuilding != null)
            {
                if (enableVerboseLogging) Debug.Log($"[BossUnit] Destination atteinte ! Destruction du bâtiment : {targetBuilding.name}");

                // Ici, vous pourriez jouer un effet d'explosion sur le bâtiment avant de le détruire.
                // Pour l'instant, nous le détruisons simplement.
                Destroy(targetBuilding.gameObject);

                // Le boss a accompli son objectif, vous pourriez déclencher la défaite du joueur ici.
                // Par exemple: GameManager.Instance.EndGame(GameResult.Defeat);
            }
        }
    }

    private IEnumerator AdvanceOneRow()
    {
        if (IsMoving || IsAtTargetLocation() || _isStunned) yield break;
        Tile nextCentralTile = GetNextTileTowardsDestination();
        if (nextCentralTile == null) yield break;
        if (bossMovementSystem == null || !bossMovementSystem.IsDestinationAreaClear(nextCentralTile, this))
        {
            SetState(UnitState.Idle);
            yield break;
        }
        IsMoving = true;
        SetState(UnitState.Moving);
        UnreserveAllTiles();
        Vector3 startPos = transform.position;
        Vector3 endPos = nextCentralTile.transform.position + Vector3.up * yOffset;
        yield return StartCoroutine(MovementSystem.MoveToTile(transform, startPos, endPos, 0.45f));
        AttachToTile(nextCentralTile);
        OccupyAdjacentTiles();
        IsMoving = false;
        SetState(UnitState.Idle);
    }

    // --- GESTION DES TUILES (inchangé) ---
    #region Tile Management
    public override List<Tile> GetOccupiedTiles()
    {
        if (occupiedTile == null || HexGridManager.Instance == null) return new List<Tile>();
        return HexGridManager.Instance.GetTilesWithinRange(occupiedTile.column, occupiedTile.row, 1);
    }
    private void OccupyAdjacentTiles()
    {
        List<Tile> tilesToOccupy = GetOccupiedTiles();
        if (TileReservationController.Instance == null) return;
        foreach (Tile tile in tilesToOccupy)
        {
            if (tile != null) TileReservationController.Instance.TryReserveTile(new Vector2Int(tile.column, tile.row), this);
        }
    }
    private void UnreserveAllTiles()
    {
        List<Tile> tilesToUnreserve = GetOccupiedTiles();
        if (TileReservationController.Instance == null) return;
        foreach (var tile in tilesToUnreserve)
        {
            if (tile != null) TileReservationController.Instance.ReleaseTileReservation(new Vector2Int(tile.column, tile.row), this);
        }
    }
    protected new void UpdateFacingDirectionSafe()
    {
        if (!_isAttacking && currentState != UnitState.Capturing && !IsMoving && !_isStunned) UpdateFacingDirection();
    }
    protected new void UpdateFacingDirection()
    {
        if (!TargetPosition.HasValue || occupiedTile == null || HexGridManager.Instance == null) return;
        Tile finalTargetTile = HexGridManager.Instance.GetTileAt(TargetPosition.Value.x, TargetPosition.Value.y);
        if (finalTargetTile == null || IsAtTargetLocation()) return;
        Tile nextStepTile = GetNextTileTowardsDestination();
        Tile tileToFace = nextStepTile ?? finalTargetTile;
        if (tileToFace != null && tileToFace != occupiedTile)
        {
            Vector3 direction = tileToFace.transform.position - transform.position;
            direction.y = 0;
            if (direction != Vector3.zero)
            {
                Quaternion yRotation = Quaternion.LookRotation(direction);
                Quaternion finalRotation = Quaternion.Euler(270, yRotation.eulerAngles.y, 0);
                transform.rotation = finalRotation;
            }
        }
    }

    /// <summary>
    /// Retourne une liste de toutes les tuiles vides et valides adjacentes à la zone occupée par le boss.
    /// Ce sont les "spots" depuis lesquels les unités peuvent lancer une attaque.
    /// </summary>
    /// <returns>Une liste de tuiles attaquables.</returns>
    public List<Tile> GetAttackablePerimeterTiles()
    {
        // Si les dépendances ne sont pas prêtes, on retourne une liste vide.
        if (HexGridManager.Instance == null || TileReservationController.Instance == null)
        {
            return new List<Tile>();
        }

        // Récupère toutes les tuiles que le boss occupe actuellement.
        List<Tile> occupied = GetOccupiedTiles();

        // Utilise un HashSet pour éviter les doublons de tuiles voisines.
        HashSet<Tile> perimeterTiles = new HashSet<Tile>();

        // 1. Pour chaque tuile occupée par le boss...
        foreach (Tile occupiedTile in occupied)
        {
            // ...trouve toutes ses tuiles voisines.
            List<Tile> neighbors = HexGridManager.Instance.GetAdjacentTiles(occupiedTile);
            foreach (Tile neighbor in neighbors)
            {
                // Ajoute chaque voisin au HashSet.
                if (neighbor != null)
                {
                    perimeterTiles.Add(neighbor);
                }
            }
        }

        // 2. Maintenant, on retire du périmètre les tuiles qui sont déjà occupées par le boss lui-même.
        foreach (Tile occupiedTile in occupied)
        {
            if (perimeterTiles.Contains(occupiedTile))
            {
                perimeterTiles.Remove(occupiedTile);
            }
        }

        // 3. Enfin, on ne garde que les tuiles qui ne sont pas réservées par une autre unité.
        List<Tile> finalAttackableTiles = new List<Tile>();
        foreach (Tile perimeterTile in perimeterTiles)
        {
            // Vérifie si la tuile est libre.
            if (!TileReservationController.Instance.IsTileReserved(new Vector2Int(perimeterTile.column, perimeterTile.row)))
            {
                finalAttackableTiles.Add(perimeterTile);
            }
        }

        return finalAttackableTiles;
    }

    #endregion
}

// --- FILE: Scripts/Units/EnemyUnit.cs ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Unity.Behavior; // Requis pour BehaviorGraphAgent
using Unity.Behavior.GraphFramework; // Requis pour Blackboard
using ScriptableObjects; // Pour CharacterProgressionData_SO

public class EnemyUnit : Unit
{
    // --- L'INTERRUPTEUR VIRTUEL ---
    // Permet aux classes enfants (comme le Boss) de spécifier qu'elles ont leur propre logique
    // et ne doivent pas utiliser l'arbre de comportement.
    protected virtual bool IsHardcoded => false;

    [Header("Behavior Graph")]
    [Tooltip("Assigner le Behavior Graph Agent de cet GameObject ici.")]
    [SerializeField] private BehaviorGraphAgent m_Agent;

    [Header("Enemy Settings")]
    [SerializeField] public bool enableVerboseLogging = true;
    [Tooltip("Si true, l'unité attaquera les bâtiments joueurs en priorité.")]
    [SerializeField] private bool prioritizePlayerBuildings = true;

    [Tooltip("Mode de comportement initial de l'unité.")]
    [SerializeField] private CurrentBehaviorMode initialBehaviorMode = CurrentBehaviorMode.Defensive;

    // --- Clés Blackboard (inchangées) ---
    public const string BB_SELF_UNIT = "SelfUnit";
    public const string BB_CURRENT_BEHAVIOR_MODE = "CurrentBehaviorMode";
    public const string BB_OBJECTIVE_BUILDING = "ObjectiveBuilding";
    public const string BB_DETECTED_PLAYER_UNIT = "DetectedPlayerUnit";
    public const string BB_DETECTED_TARGETABLE_BUILDING = "DetectedTargetableBuilding";
    public const string BB_SELECTED_ACTION_TYPE = "SelectedActionType";
    public const string BB_MOVEMENT_TARGET_POSITION = "FinalDestinationPosition";
    public const string BB_INTERACTION_TARGET_UNIT = "InteractionTargetUnit";
    public const string BB_INTERACTION_TARGET_BUILDING = "InteractionTargetBuilding";
    public const string BB_IS_MOVING = "IsMoving";
    public const string BB_IS_ATTACKING = "IsAttacking";
    public const string BB_IS_CAPTURING = "IsCapturing";
    public const string BB_IS_OBJECTIVE_COMPLETED = "IsObjectiveCompleted";
    public const string BB_PATHFINDING_FAILED = "PathfindingFailed";
    public const string BB_CURRENT_PATH = "CurrentPath";

    // Variables Blackboard mises en cache (inchangées)
    private BlackboardVariable<Unit> bbSelfUnit;
    private BlackboardVariable<CurrentBehaviorMode> bbCurrentBehaviorMode;
    private BlackboardVariable<Building> bbObjectiveBuilding;
    private BlackboardVariable<Unit> bbDetectedPlayerUnit;
    private BlackboardVariable<Building> bbDetectedTargetableBuilding;
    private BlackboardVariable<AIActionType> bbSelectedActionType;
    private BlackboardVariable<Vector2Int> bbMovementTargetPosition;
    private BlackboardVariable<Unit> bbInteractionTargetUnit;
    private BlackboardVariable<Building> bbInteractionTargetBuilding;
    private BlackboardVariable<bool> bbIsMoving;
    private BlackboardVariable<bool> bbIsAttacking;
    private BlackboardVariable<bool> bbIsCapturing;
    private BlackboardVariable<bool> bbIsObjectiveCompleted;
    private BlackboardVariable<bool> bbPathfindingFailed;
    private BlackboardVariable<List<Vector2Int>> bbCurrentPath;

    // OnEnable est appelé quand l'unité est activée. C'est ici que l'on va mettre la condition.
    protected override void OnEnable()
    {
        // --- LA CORRECTION PRINCIPALE EST ICI ---
        // On n'active la logique de l'IA (Behavior Graph) que si l'unité N'EST PAS hardcodée.
        if (!IsHardcoded)
        {
            // C'est la logique originale de la classe Unit pour s'abonner au rythme.
            // On ne l'appelle que pour les ennemis normaux. Le boss gèrera son propre abonnement.
            base.OnEnable();

            // Logique spécifique pour activer l'agent de l'IA.
            if (m_Agent != null && isAttached)
            {
                m_Agent.enabled = true;
                if (enableVerboseLogging) Debug.Log($"[{name}] Agent de comportement activé car IsHardcoded est false.");
            }
        }
        else
        {
             if (enableVerboseLogging) Debug.Log($"[{name}] Agent de comportement NON activé car IsHardcoded est true.");
        }
    }

    protected override IEnumerator Start()
    {
        if (m_Agent == null) m_Agent = GetComponent<BehaviorGraphAgent>();

        // Si l'unité EST hardcodée, on désactive l'agent pour être absolument sûr qu'il ne s'exécute pas.
        if(IsHardcoded && m_Agent != null)
        {
            m_Agent.enabled = false;
        }

        if (m_Agent == null && !IsHardcoded)
        {
            Debug.LogError($"[{name}] EnemyUnit.Start: BehaviorGraphAgent component not found! AI will not run.", gameObject);
            yield break;
        }

        if (m_Agent != null && m_Agent.BlackboardReference == null && !IsHardcoded)
        {
            Debug.LogError($"[{name}] EnemyUnit.Start: BlackboardReference is null on BehaviorGraphAgent! AI may not function correctly.", gameObject);
        }

        if (enableVerboseLogging) Debug.Log($"[{name}] EnemyUnit.Start: Début du processus d'initialisation. IsHardcoded: {IsHardcoded}");

        yield return StartCoroutine(base.Start());

        if (CharacterStatSheets != null)
        {
            InitializeFromCharacterStatsSheets(CharacterStatSheets);
        }
        else
        {
            Debug.LogError($"[{name}] EnemyUnit.Start: Aucun CharacterStatSheets n'est assigné !", gameObject);
            yield break;
        }

        if (this.isAttached)
        {
            // On initialise le blackboard uniquement pour les unités non-hardcodées.
            if (!IsHardcoded)
            {
                 if (enableVerboseLogging) Debug.Log($"[{name}] EnemyUnit.Start: Unité attachée, initialisation du Blackboard.");
                 CacheBlackboardVariables();
                 InitializeBlackboardValues();
            }
        }
        else
        {
            Debug.LogError($"[{name}] EnemyUnit.Start: ÉCHEC de l'attachement à une tuile.", gameObject);
        }

        if (EnemyRegistry.Instance != null)
        {
            EnemyRegistry.Instance.Register(this);
        }

        if (enableVerboseLogging)
            Debug.Log($"[{name}] EnemyUnit.Start: Processus d'initialisation terminé.");
    }

    // Nouvelle méthode pour centraliser l'initialisation du blackboard
    private void InitializeBlackboardValues()
    {
        if (bbCurrentBehaviorMode != null) bbCurrentBehaviorMode.Value = initialBehaviorMode;
        if (bbIsObjectiveCompleted != null) bbIsObjectiveCompleted.Value = false;
        if (bbIsMoving != null) bbIsMoving.Value = false;
        if (bbIsAttacking != null) bbIsAttacking.Value = false;
        if (bbIsCapturing != null) bbIsCapturing.Value = false;
        if (bbPathfindingFailed != null) bbPathfindingFailed.Value = false;
        if (bbCurrentPath != null) bbCurrentPath.Value = new List<Vector2Int>();
    }

    // Le reste du script (CacheBlackboardVariables, Update, TargetPosition, etc.) reste inchangé.
    #region Unchanged Methods
    private void CacheBlackboardVariables()
    {
        if (m_Agent == null || m_Agent.BlackboardReference == null)
        {
            Debug.LogError($"[{name}] CacheBlackboardVariables: BehaviorGraphAgent or its BlackboardReference is null. Cannot cache variables.", gameObject);
            return;
        }
        var blackboard = m_Agent.BlackboardReference;
        if (!blackboard.GetVariable(BB_SELF_UNIT, out bbSelfUnit))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_SELF_UNIT}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_CURRENT_BEHAVIOR_MODE, out bbCurrentBehaviorMode))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_CURRENT_BEHAVIOR_MODE}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_OBJECTIVE_BUILDING, out bbObjectiveBuilding))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_OBJECTIVE_BUILDING}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_IS_OBJECTIVE_COMPLETED, out bbIsObjectiveCompleted))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_IS_OBJECTIVE_COMPLETED}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_DETECTED_PLAYER_UNIT, out bbDetectedPlayerUnit))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_DETECTED_PLAYER_UNIT}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_DETECTED_TARGETABLE_BUILDING, out bbDetectedTargetableBuilding))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_DETECTED_TARGETABLE_BUILDING}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_SELECTED_ACTION_TYPE, out bbSelectedActionType))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_SELECTED_ACTION_TYPE}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_MOVEMENT_TARGET_POSITION, out bbMovementTargetPosition))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_MOVEMENT_TARGET_POSITION}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_INTERACTION_TARGET_UNIT, out bbInteractionTargetUnit))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_INTERACTION_TARGET_UNIT}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_INTERACTION_TARGET_BUILDING, out bbInteractionTargetBuilding))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_INTERACTION_TARGET_BUILDING}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_IS_MOVING, out bbIsMoving))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_IS_MOVING}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_IS_ATTACKING, out bbIsAttacking))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_IS_ATTACKING}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_IS_CAPTURING, out bbIsCapturing))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_IS_CAPTURING}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_PATHFINDING_FAILED, out bbPathfindingFailed))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_PATHFINDING_FAILED}' not found.", gameObject);
        if (!blackboard.GetVariable(BB_CURRENT_PATH, out bbCurrentPath))
            Debug.LogWarning($"[{name}] Blackboard variable '{BB_CURRENT_PATH}' not found.", gameObject);
    }

    private void Update() { }

    protected override Vector2Int? TargetPosition
    {
        get
        {
            if (m_Agent != null && m_Agent.BlackboardReference != null)
            {
                BlackboardVariable<Vector2Int> bbMoveTarget;
                if (m_Agent.BlackboardReference.GetVariable(BB_MOVEMENT_TARGET_POSITION, out bbMoveTarget))
                {
                    if (bbMoveTarget.Value.x < 0 || bbMoveTarget.Value.y < 0) return null;
                    return bbMoveTarget.Value;
                }
            }
            return null;
        }
    }

    public override bool IsValidUnitTarget(Unit otherUnit)
    {
        return otherUnit is AllyUnit;
    }

    public override bool IsValidBuildingTarget(Building building)
    {
        if (building == null || !building.IsTargetable) return false;
        return building.Team == TeamType.Player || building.Team == TeamType.Neutral;
    }

    public bool PerformCaptureEnemy(Building buildingToCapture)
    {
        NeutralBuilding neutralBuilding = buildingToCapture as NeutralBuilding;
        if (neutralBuilding == null || !neutralBuilding.IsRecapturable)
        {
            if (enableVerboseLogging) Debug.LogWarning($"[{name}] Cannot capture '{buildingToCapture.name}'.");
            return false;
        }
        if (neutralBuilding.Team == TeamType.Enemy)
        {
             if (enableVerboseLogging) Debug.Log($"[{name}] Building '{buildingToCapture.name}' already belongs to Enemy team.");
            return false;
        }
        if (!IsBuildingInCaptureRange(neutralBuilding))
        {
            if (enableVerboseLogging) Debug.LogWarning($"[{name}] Cannot capture '{neutralBuilding.name}': out of range.");
            return false;
        }
        SetState(UnitState.Capturing);
        FaceBuildingTarget(buildingToCapture);
        bool captureInitiated = neutralBuilding.StartCapture(TeamType.Enemy, this);
        if (captureInitiated)
        {
            this.buildingBeingCaptured = neutralBuilding;
            this.beatsSpentCapturing = 0;
            if (enableVerboseLogging) Debug.Log($"[{name}] Initiated capture of '{neutralBuilding.name}'.");
            return true;
        }
        else
        {
            if (enableVerboseLogging) Debug.LogWarning($"[{name}] Failed to initiate capture of '{neutralBuilding.name}'.");
            SetState(UnitState.Idle);
            return false;
        }
    }

    public override void OnDestroy()
    {
        if (EnemyRegistry.Instance != null)
        {
            EnemyRegistry.Instance.Unregister(this);
        }
        base.OnDestroy();
    }
    #endregion
}

// --- FILE: Scripts/Units/EnemyUnitBlackboardInitializer.cs ---
using UnityEngine;
using Unity.Behavior;
using Unity.Behavior.GraphFramework;

// S'assurer que cet initialiseur s'exécute avant les graphs par défaut
[DefaultExecutionOrder(-100)] // Exécuter avant les scripts par défaut (Default Time)
public class EnemyUnitBlackboardInitializer : MonoBehaviour
{
    private BehaviorGraphAgent m_Agent;
    private Unit m_EnemyUnit; // Renommé pour clarté

    // Awake est appelé avant tous les Start()
    void Awake()
    {
        m_Agent = GetComponent<BehaviorGraphAgent>();
        m_EnemyUnit = GetComponent<Unit>(); // Récupère le composant EnemyUnit

        if (m_Agent == null)
        {
            Debug.LogError($"[{gameObject.name}] EnemyUnitBlackboardInitializer: BehaviorGraphAgent component not found!", gameObject);
            enabled = false; // Désactiver si l'agent est manquant
            return;
        }
        if (m_EnemyUnit == null)
        {
            Debug.LogError($"[{gameObject.name}] EnemyUnitBlackboardInitializer: EnemyUnit component not found!", gameObject);
            enabled = false; // Désactiver si l'unité est manquante
            return;
        }

        // L'initialisation du Blackboard peut se faire ici ou dans Start().
        // Le faire dans Awake est généralement plus sûr pour les dépendances.
        InitializeBlackboard();
    }

    // La méthode Start du BehaviorGraphAgent s'exécutera après cet Awake.
    // Si vous préférez initialiser dans Start, assurez-vous que cet ordre est respecté
    // via Script Execution Order settings.
    void Start()
    {
        // Si le Blackboard n'a pas pu être initialisé dans Awake (par exemple, BlackboardReference était null à ce moment-là),
        // on peut tenter une nouvelle fois ici. C'est une sécurité.
        if (m_Agent != null && m_Agent.BlackboardReference != null && m_Agent.BlackboardReference.GetVariable(EnemyUnit.BB_SELF_UNIT, out BlackboardVariable<EnemyUnit> temp) && temp.Value == null)
        {
            Debug.LogWarning($"[{gameObject.name}] EnemyUnitBlackboardInitializer: Re-attempting Blackboard initialization in Start().", gameObject);
            InitializeBlackboard();
        }
    }


    void InitializeBlackboard()
    {
        if (m_Agent == null || m_EnemyUnit == null) return; // Déjà vérifié dans Awake

        if (m_Agent.BlackboardReference == null)
        {
            // Cela peut arriver si le Blackboard est assigné tardivement à l'agent.
            // Le Start() du BehaviorGraphAgent pourrait ne pas encore s'être exécuté.
            // Dans ce cas, le Behavior Graph lui-même ne devrait pas démarrer avant que BlackboardReference ne soit prêt.
            Debug.LogWarning($"[{gameObject.name}] EnemyUnitBlackboardInitializer: BlackboardReference is null on BehaviorGraphAgent during InitializeBlackboard. Will retry or fail if graph starts.", gameObject);
            return;
        }

        var blackboardRef = m_Agent.BlackboardReference;

        BlackboardVariable<Unit> bbSelfUnitForGraph;

        if (blackboardRef.GetVariable(EnemyUnit.BB_SELF_UNIT, out bbSelfUnitForGraph))
        {
            if (bbSelfUnitForGraph.Value == null) // N'écraser que si c'est null
                bbSelfUnitForGraph.Value = m_EnemyUnit;
            else if (bbSelfUnitForGraph.Value != m_EnemyUnit)
                 bbSelfUnitForGraph.Value = m_EnemyUnit;
        }
    }
}

// --- FILE: Scripts/Units/RuntimeStats.cs ---
﻿using UnityEditor;
using UnityEngine;


/// <summary>
/// Contient les statistiques finales d'une unité au moment de son exécution (runtime),
/// après calcul (niveau, équipement, etc.).
/// Il s'agit d'une simple classe de données (POCO).
/// </summary>
public class RuntimeStats
{
    public int MaxHealth { get; set; }
    public int Attack { get; set; }
    public int Defense { get; set; }
    public int AttackRange { get; set; }
    public int AttackDelay { get; set; }
    public int MovementDelay { get; set; }
    public int DetectionRange { get; set; }

    [ContextMenu("Log Stats")]
    public void LogStats()
    {
        Debug.Log($"MaxHealth: {MaxHealth}, Attack: {Attack}, Defense: {Defense}, " +
                  $"AttackRange: {AttackRange}, AttackDelay: {AttackDelay}, " +
                  $"MovementDelay: {MovementDelay}, DetectionRange: {DetectionRange}");
    }
}

// --- FILE: Scripts/Units/Unit.cs ---
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Sirenix.OdinInspector;
using System.Linq;
using ScriptableObjects;
using System;
using Random = UnityEngine.Random;

public enum UnitState
{
    Idle,
    Moving,
    Attacking,
    Capturing,
}

public abstract class Unit : MonoBehaviour, ITileReservationObserver
{
    // --- FEATURE DU FICHIER 1 : Événement de destruction ---
    /// <summary>
    /// Événement déclenché juste avant la destruction de l'unité.
    /// La bannière ou d'autres systèmes peuvent s'y abonner.
    /// </summary>
    public event Action OnUnitDestroyed;

    protected abstract Vector2Int? TargetPosition { get; }

    public struct LastDamageEvent
    {
        public Unit Attacker;
        public float Time;
    }

    public LastDamageEvent? LastAttackerInfo { get; private set; } = null;

    [Header("State & Core Mechanics")]
    public bool IsMoving;
    protected Tile occupiedTile;
    [SerializeField] protected float yOffset = 0f; // Gardé 'protected' pour la flexibilité des classes enfants
    public bool isAttached = false;
    public int Level;

    private Tile _reservedTile;

    [Header("Debugging")]
    [SerializeField] private bool debugUnitMovement = true;
    [SerializeField] private bool debugUnitCombat = false;

    [Header("Stats & Systems")]
    public RuntimeStats CurrentStats { get; private set; }
    private RuntimeStats baseStats;
    private FeverBuffs _feverBuffs;
    public FeverBuffs ActiveFeverBuffs => _feverBuffs;
    private bool _canReceiveFeverBuffs = false;
    public bool IsFeverActive { get; private set; } = false;

    // --- FEATURE DU FICHIER 2 : VFX pour le mode Fever ---
    [Header("Fever Aura VFX")]
    [Tooltip("Prefab de l'aura Fever à instancier sous l'unité quand le mode Fever est actif.")]
    [SerializeField] private GameObject feverAuraPrefab;
    private GameObject _activeFeverAuraInstance;


    public StatSheet_SO CharacterStatSheets;
    public int Health { get; protected set; }

    public virtual int Attack => CurrentStats != null ? CurrentStats.Attack : 0;
    public virtual int Defense => CurrentStats != null ? CurrentStats.Defense : 0;
    public virtual int AttackRange => CurrentStats != null ? CurrentStats.AttackRange : 0;
    public virtual int AttackDelay => CurrentStats != null ? CurrentStats.AttackDelay : 1;
    public virtual int MovementDelay => CurrentStats != null ? CurrentStats.MovementDelay : 1;
    public virtual int DetectionRange => CurrentStats != null ? CurrentStats.DetectionRange : 0;


    [SerializeField] private MonoBehaviour movementSystemComponent;
    [SerializeField] private MonoBehaviour attackSystemComponent;

    public IMovement MovementSystem { get; private set; }
    public IAttack AttackSystem { get; private set; }
    protected class ActiveBuff
    {
        public StatToBuff Stat;
        public float Multiplier;
        public float DurationRemaining;
        public Coroutine ExpiryCoroutine;
    }
    public bool IsSpawning { get; private set; } = true;
    public void SetSpawningState(bool isCurrentlySpawning)
    {
        IsSpawning = isCurrentlySpawning;
    }


    protected int _beatCounter = 0;
    private int _attackBeatCounter = 0;
    private int _stuckCount = 0;
    protected bool _isAttacking = false;

    public delegate void UnitAttackedHandler(Unit attacker, Unit target, int damage);
    public static event UnitAttackedHandler OnUnitAttacked;
    public delegate void UnitAttackedBuildingHandler(Unit attacker, Building target, int damage);
    public static event UnitAttackedBuildingHandler OnUnitAttackedBuilding;

    [Tooltip("VFX à jouer lors de l'animation de 'cheer and despawn'.")]
    [SerializeField] private GameObject cheerAndDespawnVFX; 

    /// <summary>
    /// Déclenché lorsqu'une unité est tuée par une autre.
    /// Param 1: Attaquant, Param 2: Victime.
    /// </summary>
    public static event Action<Unit, Unit> OnUnitKilled;

[Header("Animation")]
    [SerializeField] protected Animator animator;
    [SerializeField] protected bool useAnimations = true;

    public readonly int IdleParamId = Animator.StringToHash("IsIdle");
    public readonly int MovingParamId = Animator.StringToHash("IsMoving");
    public readonly int AttackTriggerId = Animator.StringToHash("Attack");
    public readonly int CaptureTriggerId = Animator.StringToHash("Capture");
    public readonly int DieTriggerId = Animator.StringToHash("Die");
    public readonly int CheerTriggerId = Animator.StringToHash("Cheer");

    [SerializeField] protected UnitState currentState = UnitState.Idle;

    public Unit targetUnit = null;
    public Building targetBuilding = null;
    protected bool isInteractingWithBuilding = false;
    protected NeutralBuilding buildingBeingCaptured = null;
    protected int beatsSpentCapturing = 0;

    protected List<ActiveBuff> activeBuffs = new List<ActiveBuff>();

    public Tile GetOccupiedTile() => occupiedTile;

    // --- FEATURE DU FICHIER 1 : Gestion des tuiles multiples ---
    public virtual List<Tile> GetOccupiedTiles()
    {
        // Pour une unité de base, on retourne une liste contenant uniquement sa tuile principale.
        if (occupiedTile != null)
        {
            return new List<Tile> { occupiedTile };
        }
        return new List<Tile>(); // Retourne une liste vide si l'unité n'est sur aucune tuile.
    }

    protected List<Tile> GetTilesInAttackRange()
    {
        if (occupiedTile == null || HexGridManager.Instance == null) return new List<Tile>();
        return HexGridManager.Instance.GetTilesWithinRange(occupiedTile.column, occupiedTile.row, Mathf.CeilToInt(AttackRange));
    }

    protected virtual IEnumerator Start()
    {
        if (animator == null) { animator = GetComponent<Animator>(); }
        if (useAnimations && animator == null)
        {
             Debug.LogWarning($"[{name}] Animator non trouvé/assigné, mais useAnimations est true. Animations désactivées.");
             useAnimations = false;
        }

        if (movementSystemComponent == null) { Debug.LogError("No movement system assigned!", this); yield break; }
        MovementSystem = movementSystemComponent as IMovement;
        if (MovementSystem == null) { Debug.LogError($"Movement component {movementSystemComponent.name} doesn't implement IMovement!", this); yield break; }

        if (attackSystemComponent != null)
        {
            AttackSystem = attackSystemComponent as IAttack;
            if (AttackSystem == null) { Debug.LogError($"Attack component {attackSystemComponent.name} doesn't implement IAttack!", this); }
        }
        else if (debugUnitCombat) Debug.Log($"[{name}] No attack system assigned. This unit cannot attack.");

        SetState(UnitState.Idle);

        // --- LOGIQUE FUSIONNÉE : Abonnement au système de Fever amélioré ---
        if (FeverManager.Instance != null)
        {
            // Si le mode Fever est déjà à son niveau maximum lors de l'apparition de l'unité,
            // on applique les effets immédiatement.
            if (FeverManager.Instance.CurrentFeverLevel > 0 && FeverManager.Instance.CurrentFeverLevel == FeverManager.Instance.MaxFeverLevel)
            {
                ApplyFeverEffects();
            }

            // On s'abonne aux changements de niveau pour les futurs paliers ou la fin du mode Fever.
            FeverManager.Instance.OnFeverLevelChanged += HandleFeverLevelChanged;
        }

        yield return StartCoroutine(AttachToNearestTile());

        if (TileReservationController.Instance != null)
        {
            TileReservationController.Instance.AddObserver(this);
        }
        else if(debugUnitMovement)
        {
            Debug.LogWarning($"[{name}] TileReservationController not found. Tile reservation features might not work as expected.");
        }
    }

    protected virtual void OnEnable()
    {
       if (isAttached && MusicManager.Instance != null)
       {
            MusicManager.Instance.OnBeat -= OnRhythmBeatInternal;
            MusicManager.Instance.OnBeat += OnRhythmBeatInternal;
       }
    }

    protected virtual void OnDisable()
    {
       if (MusicManager.Instance != null)
       {
            if (isAttached)
                MusicManager.Instance.OnBeat -= OnRhythmBeatInternal;
       }
        IsMoving = false;
        _isAttacking = false;
        if (currentState == UnitState.Capturing) StopCapturing();
    }

    public UnitType GetUnitType()
    {
        return CharacterStatSheets?.Type ?? UnitType.Null;
    }
#if UNITY_EDITOR
    [Button("Log Current Stats", ButtonSizes.Medium), GUIColor(0.4f, 0.8f, 1f)]
    [PropertyOrder(-10)]
    [ShowIf("@UnityEngine.Application.isPlaying")] // Version robuste de la condition
    private void LogCurrentStatsForInspector()
    {
        if (this.CurrentStats == null)
        {
            Debug.Log($"<color=orange>[{name}] CurrentStats est null. Les stats n'ont pas encore été calculées ou assignées.</color>");
            return;
        }
        Debug.Log($"--- Stats Log for <color=cyan>{name}</color> (Level {this.Level}) HP: {this.Health} at frame {Time.frameCount} ---");
        this.CurrentStats.LogStats();
    }
#endif

    // --- FEATURE DU FICHIER 2 : Logique du mode Fever améliorée ---
    private void HandleFeverLevelChanged(int newFeverLevel)
    {
        // Si le mode Fever s'active (n'importe quel niveau > 0) ET que cette unité n'a pas encore ses buffs
        if (newFeverLevel > 0 && !IsFeverActive)
        {
            ApplyFeverEffects();
        }
        // Si le mode Fever se désactive (niveau 0) ET que cette unité avait ses buffs
        else if (newFeverLevel == 0 && IsFeverActive)
        {
            RemoveFeverEffects();
        }
    }

    private void ApplyFeverEffects()
    {
        if (!_canReceiveFeverBuffs || baseStats == null)
        {
            if (debugUnitCombat) Debug.LogWarning($"[{name}] Cannot apply Fever effects: unit is not eligible or baseStats are null.");
            return;
        }

        IsFeverActive = true;
        if(debugUnitCombat) Debug.Log($"[{name}] Applying Fever effects.");

        // Appliquer les buffs de stats
        CurrentStats.AttackDelay = Mathf.Max(1, (int)(baseStats.AttackDelay / _feverBuffs.AttackSpeedMultiplier));
        CurrentStats.Defense = (int)(baseStats.Defense * _feverBuffs.DefenseMultiplier);

        // Activer le VFX
        if (_activeFeverAuraInstance == null && feverAuraPrefab != null)
        {
            _activeFeverAuraInstance = Instantiate(feverAuraPrefab, transform);
            _activeFeverAuraInstance.transform.localPosition = Vector3.zero;
        }
    }

    private void RemoveFeverEffects()
    {
        if (baseStats == null) return; // Sécurité

        IsFeverActive = false;
        if(debugUnitCombat) Debug.Log($"[{name}] Removing Fever effects.");

        // Restaurer les stats de base
        CurrentStats.AttackDelay = baseStats.AttackDelay;
        CurrentStats.Defense = baseStats.Defense;

        // Détruire le VFX
        if (_activeFeverAuraInstance != null)
        {
            Destroy(_activeFeverAuraInstance);
            _activeFeverAuraInstance = null;
        }
    }

    private IEnumerator AttachToNearestTile()
    {
        while (!isAttached)
        {
            if (HexGridManager.Instance != null)
            {
                Tile nearestTile = HexGridManager.Instance.GetClosestTile(transform.position);
                if (nearestTile != null && !nearestTile.IsOccupied)
                {
                    bool canAttach = false;
                    Vector2Int nearestTilePos = new Vector2Int(nearestTile.column, nearestTile.row);
                    if (TileReservationController.Instance != null)
                    {
                        if (!TileReservationController.Instance.IsTileReservedByOtherUnit(nearestTilePos, this))
                        {
                           if (TileReservationController.Instance.TryReserveTile(nearestTilePos, this))
                           {
                               canAttach = true;
                           } else {
                                if (debugUnitMovement) Debug.LogWarning($"[{name}] Could not reserve initial tile {nearestTilePos} even if not reserved by other.");
                           }
                        } else {
                             if (debugUnitMovement) Debug.LogWarning($"[{name}] Initial tile {nearestTilePos} is reserved by another unit.");
                        }
                    }
                    else
                    {
                        canAttach = true;
                    }

                    if (canAttach)
                    {
                        AttachToTile(nearestTile);
                        isAttached = true;

                        if (MusicManager.Instance != null)
                        {
                            MusicManager.Instance.OnBeat += OnRhythmBeatInternal;
                        }

                        if (debugUnitMovement) Debug.Log($"[{name}] Attached to tile ({nearestTile.column}, {nearestTile.row}) and subscribed to OnRhythmBeat.");
                        yield break;
                    }
                }
            }
            yield return new WaitForSeconds(0.1f);
        }
    }

    public virtual void OnCaptureBeat()
    {
        if (currentState != UnitState.Capturing) return;

        beatsSpentCapturing++;
        if (useAnimations && animator != null)
        {
            animator.SetTrigger(CaptureTriggerId);
        }
    }

    public virtual void StopCapturing()
    {
        if (currentState == UnitState.Capturing)
        {
            if (buildingBeingCaptured != null)
            {
                buildingBeingCaptured.StopCapturing(this);
                buildingBeingCaptured = null;
            }
            beatsSpentCapturing = 0;
            SetState(UnitState.Idle);
        }
    }

    private void OnRhythmBeatInternal(float beatDuration)
    {
        OnRhythmBeat(beatDuration);
    }

    protected virtual void OnRhythmBeat(float beatDuration)
    {
        HandleMovementOnBeat();
        if (!IsMoving)
        {
            HandleAttackOnBeat();
        }
        else
        {
            _attackBeatCounter = 0;
        }
        if (currentState == UnitState.Capturing) { HandleCaptureOnBeat(); }
    }

    #region Unchanged Methods
    protected virtual void HandleMovementOnBeat()
    {
        if (IsMoving || currentState == UnitState.Capturing) return;
        if (!TargetPosition.HasValue) { SetState(UnitState.Idle); return; }
        if (IsAtTargetLocation()) { SetState(UnitState.Idle); return; }
        if (IsSpawning)
        {
            if (debugUnitMovement) Debug.Log($"[{name}] HandleMovementOnBeat: Skipped due to IsSpawning = true.");
            return;
        }
        _beatCounter++;
        if (_beatCounter < MovementDelay) return;
        _beatCounter = 0;

        Tile nextTile = GetNextTileTowardsDestination();
        if (nextTile != null)
        {
            _stuckCount = 0;
            StartCoroutine(MoveToTile(nextTile));
        }
        else
        {
            _stuckCount++;
            if (debugUnitMovement) Debug.LogWarning($"[{name}] Cannot find next tile towards {TargetPosition.Value}. Stuck count: {_stuckCount}");
            if (_stuckCount > 3)
            {
                Tile forcedNextTile = ForceGetAnyAvailableNeighbor();
                if (forcedNextTile != null)
                {
                    if (debugUnitMovement) Debug.Log($"[{name}] Forcing move to random neighbor: ({forcedNextTile.column},{forcedNextTile.row})");
                    StartCoroutine(MoveToTile(forcedNextTile));
                    _stuckCount = 0;
                }
                else
                {
                    if (debugUnitMovement) Debug.LogWarning($"[{name}] Stuck and no available neighbor to move to.");
                    SetState(UnitState.Idle);
                }
            } else {
                 SetState(UnitState.Idle);
            }
        }
    }

    protected virtual void HandleAttackOnBeat()
    {
        if (_isAttacking || currentState == UnitState.Capturing || AttackSystem == null) return;

        _attackBeatCounter++;
        if (_attackBeatCounter >= AttackDelay)
        {
            _attackBeatCounter = 0;
            Debug.Log($"[{name}] HandleAttackOnBeat: Attempting to attack on beat {_attackBeatCounter}. :  AttackDelay: {AttackDelay}");
            Unit potentialUnitTarget = FindAttackableUnitTarget();
            Building potentialBuildingTarget = (potentialUnitTarget == null) ? FindAttackableBuildingTarget() : null;

            if (potentialUnitTarget != null)
            {
                targetUnit = potentialUnitTarget;
                targetBuilding = null;
                StartCoroutine(PerformAttackCoroutine(targetUnit));
            }
            else if (potentialBuildingTarget != null)
            {
                targetBuilding = potentialBuildingTarget;
                targetUnit = null;
                StartCoroutine(PerformAttackBuildingCoroutine(targetBuilding));
            }
             else
            {
                 if (currentState == UnitState.Attacking) SetState(UnitState.Idle);
            }
        }
    }

    protected virtual void HandleCaptureOnBeat()
    {
         if (buildingBeingCaptured == null || currentState != UnitState.Capturing) return;
         if (useAnimations && animator != null)
         {
             animator.SetTrigger(CaptureTriggerId);
         }
    }

    public IEnumerator MoveToTile(Tile targetTile)
    {
        string context = $"[{name}/{GetInstanceID()}]";

        if (MovementSystem == null || targetTile == null)
        {
            if (debugUnitMovement) Debug.LogWarning($"{context} MoveToTile ABORT: Preconditions not met. MS: {MovementSystem != null}, target: {targetTile?.name ?? "NULL"}", this);
            IsMoving = false; SetState(UnitState.Idle);
            yield break;
        }
        if (occupiedTile == targetTile)
        {
            if (debugUnitMovement) Debug.LogWarning($"{context} MoveToTile ABORT: Target tile {targetTile.name} is current tile.", this);
            IsMoving = false; SetState(UnitState.Idle);
            yield break;
        }
        if (debugUnitMovement) Debug.Log($"{context} MoveToTile START for target: {targetTile.name}. Current _reservedTile: {(_reservedTile?.name ?? "null")}", this);

        Vector2Int targetTilePos = new Vector2Int(targetTile.column, targetTile.row);
        bool reservationSuccess = false;

        if (TileReservationController.Instance != null)
        {
            if (_reservedTile != null && _reservedTile != targetTile)
            {
                if (debugUnitMovement) Debug.Log($"{context} MoveToTile: _reservedTile ({_reservedTile.name}) is different from targetTile ({targetTile.name}). Releasing _reservedTile.", this);
                TileReservationController.Instance.ReleaseTileReservation(new Vector2Int(_reservedTile.column, _reservedTile.row), this);
                _reservedTile = null;
            }
            reservationSuccess = TileReservationController.Instance.TryReserveTile(targetTilePos, this);
        }
        else
        {
            reservationSuccess = !targetTile.IsOccupied && targetTile.tileType == TileType.Ground;
        }

        if (!reservationSuccess)
        {
            if (debugUnitMovement) Debug.LogWarning($"{context} MoveToTile ABORT: Failed to reserve target tile {targetTile.name}.", this);
            IsMoving = false; SetState(UnitState.Idle);
            yield break;
        }
        _reservedTile = targetTile;
        if (debugUnitMovement) Debug.Log($"{context} MoveToTile: Successfully reserved targetTile {targetTile.name}. _reservedTile is now {targetTile.name}.", this);

        IsMoving = true;
        SetState(UnitState.Moving);
        Tile originalTile = occupiedTile;
        if (debugUnitMovement && originalTile != null) Debug.Log($"{context} MoveToTile: OriginalTile is {originalTile.name}.", this);

        try
        {
            if (debugUnitMovement) Debug.Log($"{context} MoveToTile: In try block. About to rotate.", this);
            yield return StartCoroutine(RotateToFaceTile(targetTile));

            if (originalTile != null)
            {
                if (TileReservationController.Instance != null)
                {
                    TileReservationController.Instance.ReleaseTileReservation(new Vector2Int(originalTile.column, originalTile.row), this);
                    if (debugUnitMovement) Debug.Log($"{context} MoveToTile: Released reservation for originalTile {originalTile.name} via Controller.", this);
                }
                originalTile.RemoveUnit();
                if (debugUnitMovement) Debug.Log($"{context} MoveToTile: Called RemoveUnit on originalTile {originalTile.name}.", this);
            }
            transform.SetParent(null, true);

            Vector3 currentWorldPosition = transform.position;
            Vector3 targetWorldPosition = targetTile.transform.position + Vector3.up * yOffset;

            if (debugUnitMovement) Debug.Log($"{context} MoveToTile: Calling MovementSystem.MoveToTile from {currentWorldPosition} to {targetWorldPosition}.", this);

            yield return StartCoroutine(MovementSystem.MoveToTile(transform, currentWorldPosition, targetWorldPosition, 0.45f));

            if (debugUnitMovement) Debug.Log($"{context} MoveToTile: MovementSystem.MoveToTile FINISHED.", this);

            if (this == null || !this.gameObject.activeInHierarchy) {
                if (debugUnitMovement) Debug.LogWarning($"{context} MoveToTile: Unit became inactive/destroyed during MovementSystem.MoveToTile. Aborting Attach.", this);
                yield break;
            }
            if (targetTile == null || !targetTile.gameObject.activeInHierarchy) {
                 if (debugUnitMovement) Debug.LogWarning($"{context} MoveToTile: targetTile {targetTilePos} became inactive/destroyed. Aborting Attach.", this);
                 if (_reservedTile == targetTile && TileReservationController.Instance != null) {
                     TileReservationController.Instance.ReleaseTileReservation(targetTilePos, this);
                     _reservedTile = null;
                 }
                 yield break;
            }

            if (debugUnitMovement) Debug.Log($"{context} MoveToTile: About to call AttachToTile for {targetTile.name}.", this);
            AttachToTile(targetTile);
            if (debugUnitMovement) Debug.Log($"{context} MoveToTile: AttachToTile for {targetTile.name} COMPLETED. OccupiedTile: {(occupiedTile?.name ?? "null")}", this);
        }
        finally
        {
            IsMoving = false;
            if (debugUnitMovement) Debug.Log($"{context} MoveToTile: In FINALLY. IsMoving set to false. Occupied: {(occupiedTile?.name ?? "null")}, _reservedTile: {(_reservedTile?.name ?? "null")}, targetTile: {targetTile.name}", this);

            if (currentState == UnitState.Moving)
            {
                 SetState(UnitState.Idle);
            }

            if (occupiedTile != targetTile)
            {
                if (_reservedTile == targetTile && TileReservationController.Instance != null)
                {
                    TileReservationController.Instance.ReleaseTileReservation(new Vector2Int(targetTile.column, targetTile.row), this);
                    if (debugUnitMovement) Debug.LogWarning($"{context} MoveToTile FINALLY: Movement FAILED/INTERRUPTED after reserving {targetTile.name} and before attaching. Reservation released.", this);
                    _reservedTile = null;
                }
            }
        }
    }

    public IEnumerator PerformAttackCoroutine(Unit target)
    {
        if (AttackSystem == null || target == null || target.Health <= 0)
        {
            if (debugUnitCombat) Debug.LogWarning($"[{name}] PerformAttackCoroutine: Conditions non remplies (AttackSystem null, cible nulle ou cible morte). Cible: {(target?.name ?? "NULL")}, Cible PV: {target?.Health ?? -1}");
            _isAttacking = false;
            SetState(UnitState.Idle);
            yield break;
        }

        _isAttacking = true;
        SetState(UnitState.Attacking);
        FaceUnitTarget(target);

        if (useAnimations && animator != null)
        {
            if (debugUnitCombat) Debug.Log($"[{name} ({Time.frameCount})] PerformAttackCoroutine: Déclenchement de l'animation d'attaque (ID: {AttackTriggerId}) pour la cible {target.name}.", this);
            animator.SetTrigger(AttackTriggerId);
        }
        else
        {
            if (useAnimations && animator == null && debugUnitCombat) Debug.LogWarning($"[{name}] PerformAttackCoroutine: Animator non assigné mais useAnimations est true.", this);
        }

        int calculatedDamage = Mathf.Max(1, Attack - target.Defense);
        float attackerAnimationDuration = 0.5f;

        if (AttackSystem != null)
        {
             if (debugUnitCombat) Debug.Log($"[{name}] PerformAttackCoroutine: Appel de AttackSystem.PerformAttack sur {target.name} avec {calculatedDamage} dégâts potentiels et une durée d'animation de {attackerAnimationDuration}s.", this);
            yield return StartCoroutine(
                AttackSystem.PerformAttack(
                    transform,
                    target.transform,
                    calculatedDamage,
                    attackerAnimationDuration
                )
            );
        }
        if (target == null)
        {
            if (debugUnitCombat) Debug.Log($"[{name}] PerformAttackCoroutine: La cible a été détruite pendant l'animation. L'attaque est annulée.", this);
            _isAttacking = false;
            SetState(UnitState.Idle);
            yield break;
        }
        if (debugUnitCombat) Debug.Log($"[{name}] PerformAttackCoroutine: Action d'attaque (lancement/coup) terminée pour {target.name}. _isAttacking sera mis à false.", this);
        _isAttacking = false;
        SetState(UnitState.Idle);
    }

    public IEnumerator PerformAttackBuildingCoroutine(Building target)
    {
        if (AttackSystem == null || target == null || target.CurrentHealth <= 0)
        {
            if (debugUnitCombat) Debug.LogWarning($"[{name}] PerformAttackBuildingCoroutine: Conditions non remplies. Cible: {(target?.name ?? "NULL")}, Cible PV: {target?.CurrentHealth ?? -1}");
            _isAttacking = false;
            SetState(UnitState.Idle);
            yield break;
        }

        _isAttacking = true;
        SetState(UnitState.Attacking);
        FaceBuildingTarget(target);

        if (useAnimations && animator != null)
        {
            if (debugUnitCombat) Debug.Log($"[{name} ({Time.frameCount})] PerformAttackBuildingCoroutine: Déclenchement de l'animation d'attaque (ID: {AttackTriggerId}) pour la cible {target.name}.", this);
            animator.SetTrigger(AttackTriggerId);
        }
         else
        {
            if (useAnimations && animator == null && debugUnitCombat) Debug.LogWarning($"[{name}] PerformAttackBuildingCoroutine: Animator non assigné mais useAnimations est true.", this);
        }

        int attackDamage = Attack;
        float attackerAnimationDuration = 0.5f;

        if (AttackSystem != null)
        {
            if (debugUnitCombat) Debug.Log($"[{name}] PerformAttackBuildingCoroutine: Appel de AttackSystem.PerformAttack sur {target.name} avec {attackDamage} dégâts potentiels et une durée d'animation de {attackerAnimationDuration}s.", this);
            yield return StartCoroutine(
                AttackSystem.PerformAttack(
                    transform,
                    target.transform,
                    attackDamage,
                    attackerAnimationDuration
                )
            );
        }

        if (debugUnitCombat) Debug.Log($"[{name}] PerformAttackBuildingCoroutine: Action d'attaque (lancement/coup) terminée pour {target.name}. _isAttacking sera mis à false.", this);
        _isAttacking = false;
        SetState(UnitState.Idle);
    }

    protected virtual Unit FindAttackableUnitTarget()
    {
        if (occupiedTile == null || AttackSystem == null) return null;
        List<Tile> tilesInRange = GetTilesInAttackRange();
        Unit closestValidTarget = null;
        float minDistanceSq = float.MaxValue;

        foreach (Tile tile in tilesInRange)
        {
            if (tile.currentUnit != null && IsValidUnitTarget(tile.currentUnit))
            {
                if (AttackSystem.CanAttack(transform, tile.currentUnit.transform, AttackRange))
                {
                    float distSq = (tile.currentUnit.transform.position - transform.position).sqrMagnitude;
                    if (distSq < minDistanceSq)
                    {
                        minDistanceSq = distSq;
                        closestValidTarget = tile.currentUnit;
                    }
                }
            }
        }
        return closestValidTarget;
    }

    protected virtual Building FindAttackableBuildingTarget()
    {
        if (occupiedTile == null || AttackSystem == null) return null;
        List<Tile> tilesInRange = GetTilesInAttackRange();
        Building closestValidTarget = null;
        float minDistanceSq = float.MaxValue;

        foreach (Tile tile in tilesInRange)
        {
            if (tile.currentBuilding != null && IsValidBuildingTarget(tile.currentBuilding))
            {
                if (AttackSystem.CanAttack(transform, tile.currentBuilding.transform, AttackRange))
                {
                     float distSq = (tile.currentBuilding.transform.position - transform.position).sqrMagnitude;
                    if (distSq < minDistanceSq)
                    {
                        minDistanceSq = distSq;
                        closestValidTarget = tile.currentBuilding;
                    }
                }
            }
        }
        return closestValidTarget;
    }

    public virtual void TakeDamage(int damage, Unit attacker = null)
    {
        if (debugUnitCombat) Debug.Log($"[{name}] TakeDamage called with {damage} damage from {attacker?.name ?? "unknown attacker"}.");
        if (damage <= 0) return;

        if (attacker != null)
        {
            OnUnitAttacked?.Invoke(attacker, this, damage);
            float levelDifference = attacker.Level - this.Level;
            float damageMultiplier = 1.0f + (levelDifference * 0.1f);
            damageMultiplier = Mathf.Max(0.1f, damageMultiplier);
            int modifiedDamage = Mathf.RoundToInt(damage * damageMultiplier);
            int actualDamage = Mathf.Max(1, modifiedDamage - this.Defense);
            Health -= actualDamage;
            LastAttackerInfo = new LastDamageEvent { Attacker = attacker, Time = Time.time };
            if (debugUnitCombat)
            {
                Debug.Log($"[{name}] Attaquant Lvl {attacker.Level} vs Défenseur Lvl {this.Level}. " +
                          $"Multiplicateur: {damageMultiplier:F2}. Dégâts modifiés: {modifiedDamage}. " +
                          $"Dégâts finaux après défense ({this.Defense}): {actualDamage}. " +
                          $"PV restants: {Health}/{CurrentStats.MaxHealth}");
            }
        }
        else
        {
            int actualDamage = Mathf.Max(1, damage - this.Defense);
            Health -= actualDamage;
            if (debugUnitCombat) Debug.Log($"[{name}] a subi {actualDamage} dégâts environnementaux. PV restants: {Health}/{CurrentStats.MaxHealth}");
        }

        if (Health <= 0)
        {
          if (attacker != null)
            {
                OnUnitKilled?.Invoke(attacker, this);
            }
          Die();
        }
    }

    // --- FEATURE DU FICHIER 1 : Méthode Die() modifiée ---
    protected virtual void Die()
    {
        if (debugUnitCombat) Debug.Log($"[{name}] Died.");

        // Déclenche l'événement pour notifier les observateurs (comme la bannière) avant toute autre chose
        OnUnitDestroyed?.Invoke();

        StopAllCoroutines();
        if (TileReservationController.Instance != null && occupiedTile != null)
        {
            TileReservationController.Instance.ReleaseTileReservation(new Vector2Int(occupiedTile.column, occupiedTile.row), this);
        }
        if (occupiedTile != null) occupiedTile.RemoveUnit();

        if (useAnimations && animator != null)
        {
            SetState(UnitState.Idle);
            _isAttacking = false;
            Destroy(gameObject);
        }
        else Destroy(gameObject);
    }

    protected void AttachToTile(Tile tile)
    {
        if (tile == null) { Debug.LogError($"[{name}] AttachToTile: tile is null!"); return; }

        if (_reservedTile != null && _reservedTile != tile && TileReservationController.Instance != null) {
             TileReservationController.Instance.ReleaseTileReservation(new Vector2Int(_reservedTile.column, _reservedTile.row), this);
             if (debugUnitMovement) Debug.Log($"[{name}] AttachToTile: Released PREVIOUS _reservedTile ({_reservedTile.column},{_reservedTile.row}).");
             _reservedTile = null;
        }

        Quaternion currentRotation = transform.rotation;
        occupiedTile = tile;
        transform.SetParent(tile.transform, true);
        transform.position = tile.transform.position + Vector3.up * yOffset;
        transform.rotation = currentRotation;
        tile.AssignUnit(this);

        if (TileReservationController.Instance != null) {
            bool reservedSuccessfully = TileReservationController.Instance.TryReserveTile(new Vector2Int(tile.column, tile.row), this);
            if (reservedSuccessfully)
            {
                _reservedTile = tile;
                if (debugUnitMovement) Debug.Log($"[{name}] AttachToTile: Successfully reserved and attached to tile ({tile.column}, {tile.row}). _reservedTile updated.");
            }
            else
            {
                 if (debugUnitMovement) Debug.LogError($"[{name}] AttachToTile: FAILED to reserve tile ({tile.column}, {tile.row}) even though attaching to it. This indicates a logic flaw!");
                _reservedTile = null;
            }
        } else {
             _reservedTile = tile;
        }

        if (debugUnitMovement && occupiedTile != null) Debug.Log($"[{name}] Attached to tile ({occupiedTile.column}, {occupiedTile.row}). Position: {transform.position}");
        else if (debugUnitMovement) Debug.LogWarning($"[{name}] Attached, but occupiedTile is unexpectedly null.");
    }

    public virtual void OnMovementComplete()
    {
        if (debugUnitMovement) Debug.Log($"[{name}] Movement complete. Now at ({occupiedTile?.column ?? -1}, {occupiedTile?.row ?? -1}).");
        _attackBeatCounter = 0;
    }

    protected Tile GetNextTileTowardsDestination()
    {
        if (!TargetPosition.HasValue || occupiedTile == null || HexGridManager.Instance == null) return null;

        Tile nextTile = HexGridManager.Instance.GetNextNeighborTowardsTarget(
            occupiedTile.column, occupiedTile.row, TargetPosition.Value.x, TargetPosition.Value.y, this
        );

        if (nextTile != null) {
             Vector2Int nextPos = new Vector2Int(nextTile.column, nextTile.row);
             if (TileReservationController.Instance != null &&
                 TileReservationController.Instance.IsTileReservedByOtherUnit(nextPos, this)) {
                 if (debugUnitMovement) Debug.LogWarning($"[{name}] Next preferred tile {nextPos} is reserved by another unit. Finding alternative.");
                 return FindAlternativeNeighbor(nextPos);
             }
             return nextTile;
        }
        return null;
    }

    public Tile GetNextTileTowardsDestinationForBG(Vector2Int finalDestination)
    {
        if (occupiedTile == null || HexGridManager.Instance == null)
        {
            if (debugUnitMovement) Debug.LogError($"[{name}] GetNextTileForBG: OccupiedTile or HexGridManager is null.");
            return null;
        }

        Tile nextTile = HexGridManager.Instance.GetNextNeighborTowardsTarget(
            occupiedTile.column,
            occupiedTile.row,
            finalDestination.x,
            finalDestination.y,
            this
        );

        if (nextTile != null)
        {
            if (debugUnitMovement) Debug.Log($"[{name}] GetNextTileForBG: Next tile towards ({finalDestination.x},{finalDestination.y}) is ({nextTile.column},{nextTile.row}).");
        }
        else
        {
            if (debugUnitMovement) Debug.LogWarning($"[{name}] GetNextTileForBG: No valid next tile found towards ({finalDestination.x},{finalDestination.y}).");
        }
        return nextTile;
    }

     private Tile FindAlternativeNeighbor(Vector2Int originallyPreferredTilePos)
     {
        if (occupiedTile?.Neighbors == null) return null;
        Tile bestAlternative = null;
        float minDistanceToFinalTarget = float.MaxValue;

        List<Tile> shuffledNeighbors = new List<Tile>(occupiedTile.Neighbors);
        for(int i=0; i<shuffledNeighbors.Count; ++i) {
            int r = Random.Range(i, shuffledNeighbors.Count);
            (shuffledNeighbors[i], shuffledNeighbors[r]) = (shuffledNeighbors[r], shuffledNeighbors[i]);
        }

        foreach (Tile neighbor in shuffledNeighbors)
        {
            if (neighbor == null || neighbor.IsOccupied) continue;
            Vector2Int neighborPos = new Vector2Int(neighbor.column, neighbor.row);
            if (neighborPos == originallyPreferredTilePos) continue;
            if (TileReservationController.Instance != null &&
                TileReservationController.Instance.IsTileReservedByOtherUnit(neighborPos, this)) continue;

            if(TargetPosition.HasValue) {
                float dist = HexGridManager.Instance.HexDistance(neighbor.column, neighbor.row, TargetPosition.Value.x, TargetPosition.Value.y);
                if (dist < minDistanceToFinalTarget) {
                    minDistanceToFinalTarget = dist;
                    bestAlternative = neighbor;
                }
            } else if(bestAlternative == null) {
                 bestAlternative = neighbor;
            }
        }
        if (bestAlternative != null && debugUnitMovement) Debug.Log($"[{name}] Found alternative neighbor: ({bestAlternative.column},{bestAlternative.row})");
        else if(debugUnitMovement && TargetPosition.HasValue) Debug.LogWarning($"[{name}] No unreserved alternative neighbor found that is closer to target {TargetPosition.Value}.");
        else if(debugUnitMovement) Debug.LogWarning($"[{name}] No unreserved alternative neighbor found.");
        return bestAlternative;
     }

    private Tile ForceGetAnyAvailableNeighbor()
    {
        if (occupiedTile?.Neighbors == null || occupiedTile.Neighbors.Count == 0) return null;
        List<Tile> neighbors = new List<Tile>(occupiedTile.Neighbors);
        for (int i = 0; i < neighbors.Count; i++) { int r = Random.Range(i, neighbors.Count); var tmp = neighbors[i]; neighbors[i] = neighbors[r]; neighbors[r] = tmp; }
        foreach (var neighbor in neighbors)
        {
            if (neighbor != null && !neighbor.IsOccupied)
            {
                if (TileReservationController.Instance == null || !TileReservationController.Instance.IsTileReservedByOtherUnit(new Vector2Int(neighbor.column, neighbor.row), this))
                {
                    return neighbor;
                }
            }
        }
        return null;
    }

    protected Quaternion CalculateRotationToFaceTile(Tile targetTile)
    {
        if (targetTile == null || targetTile == occupiedTile) return transform.rotation;
        Vector3 direction = targetTile.transform.position - transform.position;
        direction.y = 0;
        return (direction != Vector3.zero) ? Quaternion.LookRotation(direction) : transform.rotation;
    }

    protected IEnumerator RotateToFaceTile(Tile targetTile, float duration = 0.15f)
    {
        if (targetTile == null || targetTile == occupiedTile) yield break;
        Quaternion targetRotation = CalculateRotationToFaceTile(targetTile);
        if (Quaternion.Angle(transform.rotation, targetRotation) < 1f) yield break;

        if (duration <= 0) { transform.rotation = targetRotation; yield break; }
        float elapsed = 0;
        Quaternion startRotation = transform.rotation;
        while (elapsed < duration)
        {
            transform.rotation = Quaternion.Slerp(startRotation, targetRotation, elapsed / duration);
            elapsed += Time.deltaTime;
            yield return null;
        }
        transform.rotation = targetRotation;
    }

    protected void FaceTarget(Transform targetTransform)
    {
        if (targetTransform == null) return;
        Vector3 direction = targetTransform.position - transform.position;
        direction.y = 0;
        if (direction != Vector3.zero) transform.rotation = Quaternion.LookRotation(direction);
    }
    protected void FaceUnitTarget(Unit target) { FaceTarget(target?.transform); }
    protected void FaceBuildingTarget(Building target) { FaceTarget(target?.transform); }

    protected void UpdateFacingDirection()
    {
        if (!TargetPosition.HasValue || occupiedTile == null || HexGridManager.Instance == null) return;
        Tile finalTargetTile = HexGridManager.Instance.GetTileAt(TargetPosition.Value.x, TargetPosition.Value.y);
        if (finalTargetTile == null || IsAtTargetLocation()) return;
        Tile nextStepTile = GetNextTileTowardsDestination();
        Tile tileToFace = nextStepTile ?? finalTargetTile;
        if (tileToFace != null && tileToFace != occupiedTile) StartCoroutine(RotateToFaceTile(tileToFace));
    }
     protected void UpdateFacingDirectionSafe() { if (!_isAttacking && currentState != UnitState.Capturing && !IsMoving) UpdateFacingDirection(); }

    protected virtual void SetState(UnitState newState)
    {
        if (currentState == newState && !(newState == UnitState.Attacking || newState == UnitState.Capturing))
        {
            return;
        }

        if (debugUnitMovement || debugUnitCombat)
        {
            Debug.Log($"[{name} ({Time.frameCount})] SetState: Changing C# State from '{currentState}' to '{newState}'.", this);
        }

        UnitState previousCSharpState = currentState;
        currentState = newState;

        if (useAnimations && animator != null)
        {
            bool setAnimIdle = (newState == UnitState.Idle);
            bool setAnimMoving = (newState == UnitState.Moving);

            if (newState == UnitState.Attacking || newState == UnitState.Capturing)
            {
                setAnimIdle = false;
                setAnimMoving = false;
            }

            animator.SetBool(IdleParamId, setAnimIdle);
            animator.SetBool(MovingParamId, setAnimMoving);

            if (debugUnitMovement || debugUnitCombat)
            {
                Debug.Log($"[{name} ({Time.frameCount})] SetState: Animator Booleans Set -> IsIdle: {setAnimIdle}, IsMoving: {setAnimMoving}", this);
            }

            if (newState != UnitState.Attacking && previousCSharpState == UnitState.Attacking)
            {
                animator.ResetTrigger(AttackTriggerId);
                if (debugUnitCombat) Debug.Log($"[{name} ({Time.frameCount})] SetState: Resetting AttackTriggerId because newState is no longer Attacking.", this);
            }

            if (newState != UnitState.Capturing && previousCSharpState == UnitState.Capturing)
            {
                animator.ResetTrigger(CaptureTriggerId);
                if (debugUnitCombat) Debug.Log($"[{name} ({Time.frameCount})] SetState: Resetting CaptureTriggerId because newState is no longer Capturing.", this);
            }
        }
        else if (useAnimations && animator == null)
        {
            Debug.LogError($"[{name} ({Time.frameCount})] SetState: Animator is NULL for state {newState}.", this);
        }

        switch (newState)
        {
            case UnitState.Idle:
                isInteractingWithBuilding = false;
                if (buildingBeingCaptured != null) { buildingBeingCaptured.StopCapturing(this); buildingBeingCaptured = null; }
                beatsSpentCapturing = 0;
                if (!(this is AllyUnit)) { targetUnit = null; targetBuilding = null; }
                break;

            case UnitState.Attacking:
                if (buildingBeingCaptured != null) { buildingBeingCaptured.StopCapturing(this); buildingBeingCaptured = null; }
                beatsSpentCapturing = 0;
                break;

            case UnitState.Capturing:
                beatsSpentCapturing = 0;
                targetUnit = null;
                isInteractingWithBuilding = true;
                break;

            case UnitState.Moving:
                if (buildingBeingCaptured != null) { buildingBeingCaptured.StopCapturing(this); buildingBeingCaptured = null; }
                isInteractingWithBuilding = false;
                beatsSpentCapturing = 0;
                break;
        }
    }

    protected bool IsAtTargetLocation() => TargetPosition.HasValue && occupiedTile != null && occupiedTile.column == TargetPosition.Value.x && occupiedTile.row == TargetPosition.Value.y;

    public virtual bool IsValidUnitTarget(Unit otherUnit) => false;
    public virtual bool IsValidBuildingTarget(Building building) => building != null && building.IsTargetable;


    public bool IsBuildingInRange(Building building)
    {
         if (building == null || occupiedTile == null || HexGridManager.Instance == null) return false;
         Tile buildingTile = building.GetOccupiedTile();
         if (buildingTile == null) return false;
         var tilesInRange = HexGridManager.Instance.GetTilesWithinRange(occupiedTile.column, occupiedTile.row, Mathf.CeilToInt(AttackRange));
         return tilesInRange.Contains(buildingTile);
    }

    public bool IsUnitInRange(Unit unit)
    {
        if (unit == null || occupiedTile == null || HexGridManager.Instance == null) return false;
        Tile unitTile = unit.GetOccupiedTile();
        if (unitTile == null) return false;
        var tilesInRange = HexGridManager.Instance.GetTilesWithinRange(occupiedTile.column, occupiedTile.row, Mathf.CeilToInt(AttackRange));
        return tilesInRange.Contains(unitTile);
    }

    public bool IsBuildingInCaptureRange(Building building)
    {
        if (building == null || occupiedTile == null || HexGridManager.Instance == null) return false;
        Tile buildingTile = building.GetOccupiedTile();
        if (buildingTile == null) return false;
        var tilesInRange = HexGridManager.Instance.GetTilesWithinRange(occupiedTile.column, occupiedTile.row, 1);
        return tilesInRange.Contains(buildingTile);
    }

    public virtual bool PerformCapture(Building buildingToCapture)
    {
        NeutralBuilding neutralBuilding = buildingToCapture as NeutralBuilding;
        if (neutralBuilding == null || !neutralBuilding.IsRecapturable || (neutralBuilding.Team != TeamType.Neutral && neutralBuilding.Team != TeamType.Enemy))
        {
            if (debugUnitCombat) Debug.LogWarning($"[{name}] Cannot capture '{buildingToCapture.name}'.");
            return false;
        }
        if (!IsBuildingInCaptureRange(neutralBuilding))
        {
            if (debugUnitCombat) Debug.LogWarning($"[{name}] Cannot capture '{neutralBuilding.name}': out of range.");
            return false;
        }

        FaceBuildingTarget(neutralBuilding);
        TeamType teamToCaptureFor = (this is AllyUnit) ? TeamType.Player : TeamType.Enemy;
        bool captureStarted = neutralBuilding.StartCapture(teamToCaptureFor, this);

        if (captureStarted)
        {
            buildingBeingCaptured = neutralBuilding;
            SetState(UnitState.Capturing);
            if (useAnimations && animator != null) animator.SetTrigger(CaptureTriggerId);
            beatsSpentCapturing = 0;
            return true;
        }
        if(currentState == UnitState.Capturing) SetState(UnitState.Idle);
        return false;
    }

    public virtual void OnCaptureComplete()
    {
        if (debugUnitCombat) Debug.Log($"[{name}] Capture of '{buildingBeingCaptured?.name}' complete/ended.");
        buildingBeingCaptured = null;
        beatsSpentCapturing = 0;
        SetState(UnitState.Idle);
        targetBuilding = null;
        isInteractingWithBuilding = false;
        UpdateFacingDirectionSafe();
    }

     public void ReleaseCurrentReservation()
    {
        if (_reservedTile != null && TileReservationController.Instance != null)
        {
            TileReservationController.Instance.ReleaseTileReservation(new Vector2Int(_reservedTile.column, _reservedTile.row), this);
            if (debugUnitMovement) Debug.Log($"[{name}] Reservation on tile ({_reservedTile.column},{_reservedTile.row}) released by Unit.ReleaseCurrentReservation().");
            _reservedTile = null;
        } else if (_reservedTile != null && debugUnitMovement) {
            Debug.LogWarning($"[{name}] TileReservationController not found, cannot formally release reservation for tile ({_reservedTile.column},{_reservedTile.row}). Clearing local _reservedTile.");
            _reservedTile = null;
        }
    }

    public void OnTileReservationChanged(Vector2Int tilePos, Unit reservingUnit, bool isReserved)
    {
        if (reservingUnit != this && !isReserved && !IsMoving && TargetPosition.HasValue)
        {
            if (TargetPosition.Value.x == tilePos.x && TargetPosition.Value.y == tilePos.y)
            {
                if (debugUnitMovement) Debug.Log($"[{name}] Target tile {tilePos} became free. Triggering movement check.");
                _beatCounter = MovementDelay;
            }
        }
    }
    public virtual void ApplyBuff(StatToBuff stat, float multiplier, float duration)
    {
        if (duration <= 0) return;

        ActiveBuff newBuff = new ActiveBuff
        {
            Stat = stat,
            Multiplier = multiplier,
            DurationRemaining = duration
        };
        newBuff.ExpiryCoroutine = StartCoroutine(BuffExpiryCoroutine(newBuff));
        activeBuffs.Add(newBuff);

        Debug.Log($"[{name}] Buff appliqué: {stat} x{multiplier} pour {duration}s. Nouvelle Att: {Attack}, Nouvelle Def: {Defense}");
    }

    private IEnumerator BuffExpiryCoroutine(ActiveBuff buff)
    {
        yield return new WaitForSeconds(buff.DurationRemaining);
        RemoveBuff(buff);
    }

    protected virtual void RemoveBuff(ActiveBuff buff)
    {
        if (activeBuffs.Contains(buff))
        {
            activeBuffs.Remove(buff);
            Debug.Log($"[{name}] Buff expiré/retiré: {buff.Stat}. Att actuelle: {Attack}, Def actuelle: {Defense}");
        }
    }

    public virtual void OnDestroy()
    {
        // --- LOGIQUE FUSIONNÉE : Nettoyage complet ---
        if (FeverManager.Instance != null)
        {
            FeverManager.Instance.OnFeverLevelChanged -= HandleFeverLevelChanged;
        }
        if (_activeFeverAuraInstance != null)
        {
            Destroy(_activeFeverAuraInstance);
            _activeFeverAuraInstance = null;
        }
        if (MusicManager.Instance != null)
        {
            MusicManager.Instance.OnBeat -= OnRhythmBeatInternal;
        }

        if (TileReservationController.Instance != null)
        {
            if (occupiedTile != null)
            {
                TileReservationController.Instance.ReleaseTileReservation(new Vector2Int(occupiedTile.column, occupiedTile.row), this);
                if (debugUnitMovement) Debug.Log($"[{name}] OnDestroy: Released reservation for occupiedTile ({occupiedTile.column},{occupiedTile.row}).");
            }
            if (_reservedTile != null && _reservedTile != occupiedTile)
            {
                TileReservationController.Instance.ReleaseTileReservation(new Vector2Int(_reservedTile.column, _reservedTile.row), this);
                if (debugUnitMovement) Debug.Log($"[{name}] OnDestroy: Released reservation for _reservedTile ({_reservedTile.column},{_reservedTile.row}).");
            }
            TileReservationController.Instance.RemoveObserver(this);
        }

        if (occupiedTile != null)
        {
            occupiedTile.RemoveUnit();
        }
        _reservedTile = null;
        occupiedTile = null;

        foreach (var buff in activeBuffs)
        {
            if (buff.ExpiryCoroutine != null)
            {
                StopCoroutine(buff.ExpiryCoroutine);
            }
        }
        activeBuffs.Clear();
    }

    public IEnumerator PerformCheerAndDespawnCoroutine()
    {
        if (useAnimations && animator != null)
        {
            animator.SetBool(IdleParamId, false);
            animator.SetBool(MovingParamId, false);
            animator.SetTrigger(CheerTriggerId);
        }

        float cheerAnimationDuration = 2.0f;
        if (useAnimations && animator != null)
        {
            AnimationClip[] clips = animator.runtimeAnimatorController.animationClips;
            foreach (AnimationClip clip in clips)
            {
                if (clip.name.ToLower().Contains("cheer"))
                {
                    cheerAnimationDuration = clip.length;
                    break;
                }
            }
        }
        yield return new WaitForSeconds(cheerAnimationDuration);
        if (this is AllyUnit allyUnit)
        {
            if (MomentumManager.Instance != null && allyUnit.MomentumGainOnObjectiveComplete > 0)
            {
                MomentumManager.Instance.AddMomentum(allyUnit.MomentumGainOnObjectiveComplete);
                Debug.Log($"[Unit] L'unité offensive {allyUnit.name} a complété son objectif et a rapporté {allyUnit.MomentumGainOnObjectiveComplete} de momentum.");
            }
        }
        if (cheerAndDespawnVFX != null)
        {
            Instantiate(cheerAndDespawnVFX, transform.position, Quaternion.identity);
        }
        
        Die();
    }

    public virtual void InitializeFromCharacterStatsSheets(StatSheet_SO characterStatsReceived)
    {
        if (characterStatsReceived == null)
        {
            Debug.LogError("InitializeFromCharacterStatsSheets: characterStatsReceived is null. Cannot initialize unit.");
            return;
        }

        this.CharacterStatSheets = characterStatsReceived;
        this.CurrentStats = StatsCalculator.GetFinalStats(this.CharacterStatSheets, this.Level);
        this.Health = this.CurrentStats.MaxHealth;
    }

    public virtual void InitializeFromCharacterData(CharacterData_SO characterData)
    {
        if (characterData == null)
        {
            Debug.LogError("InitializeFromCharacterData: characterData est null !", this);
            return;
        }

        this.CharacterStatSheets = characterData.Stats;
        _feverBuffs = characterData.feverBuffs;
        _canReceiveFeverBuffs = true;

        int level = 1;
        List<EquipmentData_SO> equipment = new List<EquipmentData_SO>();

        if (this is AllyUnit && PlayerDataManager.Instance != null)
        {
            if (PlayerDataManager.Instance.Data.CharacterProgressData.TryGetValue(characterData.CharacterID, out var progress))
            {
                level = progress.CurrentLevel;
                if (PlayerDataManager.Instance.Data.EquippedItems.TryGetValue(characterData.CharacterID, out var equippedItemIDs))
                {
                    foreach (var itemID in equippedItemIDs)
                    {
                        EquipmentData_SO equipmentData = Resources.Load<EquipmentData_SO>($"Data/Equipment/{itemID}");
                        if (equipmentData != null)
                        {
                            equipment.Add(equipmentData);
                        }
                    }
                }
            }
        }

        this.baseStats = StatsCalculator.GetFinalStats(characterData, level, equipment);
        this.CurrentStats = new RuntimeStats
        {
            MaxHealth = baseStats.MaxHealth,
            Attack = baseStats.Attack,
            Defense = baseStats.Defense,
            AttackRange = baseStats.AttackRange,
            AttackDelay = baseStats.AttackDelay,
            MovementDelay = baseStats.MovementDelay,
            DetectionRange = baseStats.DetectionRange
        };

       if (this is AllyUnit allyUnit)
       {
           allyUnit.MomentumGainOnObjectiveComplete = characterData.MomentumGainOnObjectiveComplete;
       }

        this.Health = this.CurrentStats.MaxHealth;
    }
    #endregion
}

// --- FILE: Scripts/Utils/CloudAnimationMananger.cs ---
﻿using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Gestionnaire centralisé pour animer efficacement des centaines de nuages.
/// Utilise une seule boucle Update pour contrôler tous les nuages, maximisant les performances.
/// </summary>
public class CloudAnimationManager : MonoBehaviour
{
    public static CloudAnimationManager Instance { get; private set; }

    [Header("Animation Settings")]
    [Tooltip("Vitesse de rotation sur l'axe Y en degrés par seconde")]
    [SerializeField] private float rotationSpeed = 5f;
    
    [Tooltip("Vitesse du mouvement de flottement")]
    [SerializeField] private float bobbingSpeed = 1f;
    
    [Tooltip("Amplitude du mouvement de flottement")]
    [SerializeField] private float bobbingHeight = 0.2f;
    
    [Tooltip("Variation de phase entre les nuages (0 = synchronisé, 1 = complètement varié)")]
    [SerializeField, Range(0f, 1f)] private float phaseVariation = 0.8f;
    
    [Tooltip("Variation de vitesse entre les nuages")]
    [SerializeField, Range(0f, 1f)] private float speedVariation = 0.3f;

    [Header("Performance")]
    [Tooltip("Tag utilisé pour identifier les nuages")]
    [SerializeField] private string cloudTag = "Cloud";
    
    [Tooltip("Nombre maximum de nuages à traiter par frame (0 = tous)")]
    [SerializeField] private int cloudsPerFrame = 0;

    // Structures de données optimisées
    private Transform[] cloudTransforms;
    private Vector3[] initialPositions;
    private float[] phaseOffsets;
    private float[] speedMultipliers;
    private float[] rotationMultipliers;
    
    private int cloudCount = 0;
    private int currentCloudIndex = 0;
    
    // Pour le debug
    private float lastUpdateTime;
    private float updateDeltaTime;

    void Awake()
    {
        // Singleton pattern
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    void Start()
    {
        InitializeClouds();
    }

    /// <summary>
    /// Trouve tous les nuages et pré-calcule les valeurs nécessaires
    /// </summary>
    private void InitializeClouds()
    {
        // Trouver tous les GameObjects avec le tag "Cloud"
        GameObject[] cloudObjects = GameObject.FindGameObjectsWithTag(cloudTag);
        cloudCount = cloudObjects.Length;
        
        if (cloudCount == 0)
        {
            Debug.LogWarning($"[CloudAnimationManager] Aucun GameObject avec le tag '{cloudTag}' trouvé!");
            enabled = false;
            return;
        }
        
        // Allouer les tableaux
        cloudTransforms = new Transform[cloudCount];
        initialPositions = new Vector3[cloudCount];
        phaseOffsets = new float[cloudCount];
        speedMultipliers = new float[cloudCount];
        rotationMultipliers = new float[cloudCount];
        
        // Initialiser les données
        for (int i = 0; i < cloudCount; i++)
        {
            cloudTransforms[i] = cloudObjects[i].transform;
            initialPositions[i] = cloudTransforms[i].position;
            
            // Générer des variations uniques pour chaque nuage
            // Utilisation de la position pour un offset pseudo-aléatoire déterministe
            float pseudoRandom = (initialPositions[i].x * 73.1f + initialPositions[i].z * 37.7f) % 1f;
            pseudoRandom = Mathf.Abs(pseudoRandom);
            
            // Phase offset pour le bobbing (évite que tous les nuages bougent en synchrone)
            phaseOffsets[i] = pseudoRandom * Mathf.PI * 2f * phaseVariation;
            
            // Multiplicateurs de vitesse pour varier légèrement les mouvements
            speedMultipliers[i] = 1f + (pseudoRandom - 0.5f) * speedVariation * 2f;
            
            // Variation de la vitesse de rotation
            float rotRandom = (initialPositions[i].y * 13.7f + i * 7.3f) % 1f;
            rotationMultipliers[i] = 1f + (Mathf.Abs(rotRandom) - 0.5f) * speedVariation * 2f;
        }
        
        Debug.Log($"[CloudAnimationManager] Initialisé avec {cloudCount} nuages");
    }

    void Update()
    {
        if (cloudCount == 0) return;
        
        // Mesure du temps pour le debug (peut être retiré en production)
        #if UNITY_EDITOR
        float startTime = Time.realtimeSinceStartup;
        #endif
        
        float currentTime = Time.time;
        float deltaTime = Time.deltaTime;
        
        // Déterminer combien de nuages traiter ce frame
        int cloudsToProcess = cloudsPerFrame > 0 ? Mathf.Min(cloudsPerFrame, cloudCount) : cloudCount;
        
        // Traitement par lots si configuré
        if (cloudsPerFrame > 0)
        {
            // Traiter un sous-ensemble de nuages chaque frame
            for (int i = 0; i < cloudsToProcess; i++)
            {
                int index = (currentCloudIndex + i) % cloudCount;
                AnimateCloud(index, currentTime, deltaTime);
            }
            currentCloudIndex = (currentCloudIndex + cloudsToProcess) % cloudCount;
        }
        else
        {
            // Traiter tous les nuages d'un coup
            for (int i = 0; i < cloudCount; i++)
            {
                AnimateCloud(i, currentTime, deltaTime);
            }
        }
        
        // Mesure du temps pour le debug
        #if UNITY_EDITOR
        updateDeltaTime = (Time.realtimeSinceStartup - startTime) * 1000f;
        lastUpdateTime = Time.time;
        #endif
    }

    /// <summary>
    /// Anime un nuage individuel (appelé depuis la boucle principale)
    /// </summary>
    private void AnimateCloud(int index, float currentTime, float deltaTime)
    {
        if (cloudTransforms[index] == null) return;
        
        Transform cloud = cloudTransforms[index];
        
        // Rotation continue sur Y
        float rotationDelta = rotationSpeed * rotationMultipliers[index] * deltaTime;
        cloud.Rotate(0, rotationDelta, 0, Space.World);
        
        // Mouvement de flottement vertical (bobbing)
        float bobbingPhase = currentTime * bobbingSpeed * speedMultipliers[index] + phaseOffsets[index];
        float yOffset = Mathf.Sin(bobbingPhase) * bobbingHeight;
        
        // Appliquer la nouvelle position
        cloud.position = new Vector3(
            initialPositions[index].x,
            initialPositions[index].y + yOffset,
            initialPositions[index].z
        );
    }

    /// <summary>
    /// Permet de mettre à jour dynamiquement les paramètres d'animation
    /// </summary>
    public void SetAnimationParameters(float newRotationSpeed, float newBobbingSpeed, float newBobbingHeight)
    {
        rotationSpeed = newRotationSpeed;
        bobbingSpeed = newBobbingSpeed;
        bobbingHeight = newBobbingHeight;
    }

    /// <summary>
    /// Réinitialise les nuages si nécessaire (après génération de nouveaux nuages par exemple)
    /// </summary>
    public void RefreshCloudList()
    {
        InitializeClouds();
    }

    #if UNITY_EDITOR
    void OnGUI()
    {
        // Affichage optionnel des stats de performance en mode debug
        if (Debug.isDebugBuild && cloudCount > 0)
        {
            GUI.Label(new Rect(10, 10, 300, 20), $"Clouds: {cloudCount} | Update: {updateDeltaTime:F2}ms");
        }
    }
    #endif

    void OnDestroy()
    {
        if (Instance == this)
        {
            Instance = null;
        }
    }
}

// --- FILE: Scripts/Utils/CloudGenerator.cs ---
﻿using UnityEngine;
using System.Collections.Generic;

// Ajout de [ExecuteInEditMode] pour que le script fonctionne dans l'éditeur Unity
[ExecuteInEditMode]
public class CloudGenerator : MonoBehaviour
{
    [Header("Configuration des Nuages")]
    [Tooltip("La liste de vos prefabs de nuages. Faites-en glisser plusieurs pour de la variété.")]
    public List<GameObject> cloudPrefabs;

    [Tooltip("Le nombre total de nuages à générer.")]
    public int numberOfClouds = 200;

    [Header("Zone de Placement (Anneau)")]
    [Tooltip("Le centre autour duquel les nuages seront placés. Vous pouvez utiliser le centre de votre grille (board).")]
    public Transform centerPoint;

    [Tooltip("La distance minimale par rapport au centre.")]
    public float minRadius = 30f;

    [Tooltip("La distance maximale par rapport au centre.")]
    public float maxRadius = 80f;

    [Header("Placement en Hauteur")]
    [Tooltip("La hauteur minimale des nuages par rapport au centre.")]
    public float minHeight = -10f;

    [Tooltip("La hauteur maximale des nuages par rapport au centre.")]
    public float maxHeight = 15f;
    
    [Header("Variation Aléatoire")]
    [Tooltip("Taille minimale pour un nuage (ex: 0.8 = 80% de la taille originale).")]
    public float minScale = 0.8f;

    [Tooltip("Taille maximale pour un nuage (ex: 2.5 = 250% de la taille originale).")]
    public float maxScale = 2.5f;

    // Contexte Menu pour ajouter des boutons dans l'inspecteur du composant
    [ContextMenu("1. Générer les Nuages")]
    public void Generate()
    {
        // On s'assure d'avoir les prérequis
        if (cloudPrefabs == null || cloudPrefabs.Count == 0 || centerPoint == null)
        {
            Debug.LogError("[CloudGenerator] Assurez-vous d'assigner au moins un prefab de nuage et un point central !", this);
            return;
        }

        // On nettoie les anciens nuages avant d'en générer de nouveaux
        Clear();

        // On génère les nuages
        for (int i = 0; i < numberOfClouds; i++)
        {
            // --- 1. Calculer une position aléatoire en anneau ---
            float randomAngle = Random.Range(0f, 360f); // Un angle aléatoire sur le cercle
            float randomRadius = Random.Range(minRadius, maxRadius); // Une distance aléatoire dans l'anneau
            
            // Convertir les coordonnées polaires (angle, rayon) en coordonnées cartésiennes (x, z)
            Vector3 position = new Vector3(
                Mathf.Sin(randomAngle * Mathf.Deg2Rad) * randomRadius,
                0, // La hauteur est ajoutée ensuite
                Mathf.Cos(randomAngle * Mathf.Deg2Rad) * randomRadius
            );

            // --- 2. Ajouter la hauteur et centrer sur le point de référence ---
            position.y = Random.Range(minHeight, maxHeight);
            position += centerPoint.position;

            // --- 3. Choisir un prefab de nuage au hasard dans la liste ---
            GameObject randomCloudPrefab = cloudPrefabs[Random.Range(0, cloudPrefabs.Count)];

            // --- 4. Instancier le nuage ---
            GameObject cloudInstance = Instantiate(
                randomCloudPrefab, 
                position, 
                // Rotation Y aléatoire pour que tous les nuages ne soient pas orientés pareil
                Quaternion.Euler(0, Random.Range(0, 360), 0),
                // Le parent sera cet objet pour garder la scène propre
                this.transform 
            );
            
            // --- 5. Appliquer une taille aléatoire ---
            float randomScale = Random.Range(minScale, maxScale);
            cloudInstance.transform.localScale = Vector3.one * randomScale;
        }

        Debug.Log($"[CloudGenerator] {numberOfClouds} nuages ont été générés avec succès !", this);
    }

    // Un deuxième bouton pour nettoyer facilement la scène
    [ContextMenu("2. Nettoyer les Nuages")]
    public void Clear()
    {
        // On parcourt les enfants de cet objet à l'envers (plus sûr lors de la suppression)
        for (int i = this.transform.childCount - 1; i >= 0; i--)
        {
            // On utilise DestroyImmediate car nous sommes en mode éditeur. Destroy ne fonctionnerait pas.
            DestroyImmediate(this.transform.GetChild(i).gameObject);
        }
        Debug.Log("[CloudGenerator] Tous les nuages enfants ont été nettoyés.", this);
    }
}

// --- FILE: Scripts/Utils/EnvironmentAnimationManager.cs ---
﻿using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Interface pour les objets animables par le manager.
/// </summary>
public interface IAnimatableEnvironment
{
    Transform transform { get; }
    void OnAnimationComplete();
}

/// <summary>
/// Le manager d'animation pour les objets d'environnement.
/// ARCHITECTURE CLONÉE SUR CELLE DE TILEANIMATIONMANAGER POUR LA ROBUSTESSE ET LA PERFORMANCE.
/// </summary>
public class EnvironmentAnimationManager : MonoBehaviour
{
    public static EnvironmentAnimationManager Instance { get; private set; }

    private List<AnimationState> activeAnimations;
    private Queue<int> freeIndices;
    private int animationPoolSize = 200; // Ajustable si nécessaire

    private struct AnimationState
    {
        public bool isActive;
        public IAnimatableEnvironment environment;
        public Transform transform;

        // Timings
        public float startTime;
        public float duration;
        public AnimationCurve curve;

        // Valeurs initiales
        public Vector3 startPosition;
        public Quaternion startRotation;
        public Vector3 startScale;

        // Paramètres de l'animation
        public AnimationType type;
        public float bounceHeight;
        public float bounceRotation;
        public Vector3 rotationAxis;
        public float stretchIntensity;
        public Vector3 stretchAxis;
        public float squashFactor;
    }

    public enum AnimationType
    {
        Bounce,
        Stretch
    }

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;

        // Initialisation du pool, comme dans TileAnimationManager
        activeAnimations = new List<AnimationState>(animationPoolSize);
        freeIndices = new Queue<int>(animationPoolSize);
        for (int i = 0; i < animationPoolSize; i++)
        {
            activeAnimations.Add(new AnimationState());
            freeIndices.Enqueue(i);
        }
    }

    public void RequestAnimation(IAnimatableEnvironment env, AnimationType type, float duration, AnimationCurve curve,
                                 float bounceHeight = 0, float bounceRotation = 0, Vector3 rotationAxis = default,
                                 float stretchIntensity = 0, Vector3 stretchAxis = default, float squashFactor = 0)
    {
        if (freeIndices.Count == 0)
        {
            Debug.LogWarning("EnvironmentAnimationManager pool is full. No animation will be played.");
            return;
        }

        int index = freeIndices.Dequeue();
        var t = env.transform;

        activeAnimations[index] = new AnimationState
        {
            isActive = true,
            environment = env,
            transform = t,
            startTime = Time.time,
            duration = duration,
            curve = curve,
            startPosition = t.localPosition,
            startRotation = t.localRotation,
            startScale = t.localScale,
            type = type,
            bounceHeight = bounceHeight,
            bounceRotation = bounceRotation,
            rotationAxis = rotationAxis,
            stretchIntensity = stretchIntensity,
            stretchAxis = stretchAxis,
            squashFactor = squashFactor
        };
    }

    void Update()
    {
        if (activeAnimations == null || activeAnimations.Count == 0) return;

        float currentTime = Time.time;

        for (int i = 0; i < animationPoolSize; i++)
        {
            if (!activeAnimations[i].isActive) continue;

            var anim = activeAnimations[i];
            float elapsed = currentTime - anim.startTime;
            float progress = Mathf.Clamp01(elapsed / anim.duration);
            float easedProgress = anim.curve.Evaluate(progress);

            switch (anim.type)
            {
                case AnimationType.Bounce:
                    // Logique de rebond avec montée/descente et squash
                    float upDownProgress = Mathf.Sin(easedProgress * Mathf.PI); // 0 -> 1 -> 0
                    anim.transform.localPosition = Vector3.LerpUnclamped(anim.startPosition, anim.startPosition + Vector3.up * anim.bounceHeight, upDownProgress);
                    anim.transform.localRotation = Quaternion.SlerpUnclamped(anim.startRotation, anim.startRotation * Quaternion.AngleAxis(anim.bounceRotation, anim.rotationAxis), upDownProgress);

                    // Le squash se produit à la fin
                    if (progress > 0.8f)
                    {
                        float squashProgress = Mathf.Sin(((progress - 0.8f) / 0.2f) * Mathf.PI); // 0 -> 1 -> 0
                        float currentSquash = 1.0f - (1.0f - anim.squashFactor) * squashProgress;
                        float currentStretch = 1.0f + (1.0f - currentSquash) * 0.5f;
                        anim.transform.localScale = new Vector3(anim.startScale.x * currentStretch, anim.startScale.y * currentSquash, anim.startScale.z * currentStretch);
                    }
                    break;

                case AnimationType.Stretch:
                     // Logique de stretch avec un arc complet
                    float stretchProgress = Mathf.Sin(easedProgress * Mathf.PI); // 0 -> 1 -> 0
                    anim.transform.localScale = anim.startScale + anim.stretchAxis * (anim.stretchIntensity - 1) * stretchProgress;
                    break;
            }

            if (progress >= 1f)
            {
                // Fin de l'animation, on restaure l'état et on libère l'objet
                anim.transform.localPosition = anim.startPosition;
                anim.transform.localRotation = anim.startRotation;
                anim.transform.localScale = anim.startScale;

                anim.environment.OnAnimationComplete();
                
                // On remet dans le pool
                activeAnimations[i] = new AnimationState { isActive = false };
                freeIndices.Enqueue(i);
            }
        }
    }

    public void StopAllAnimationsFor(IAnimatableEnvironment env)
    {
        if (env == null || activeAnimations == null) return;
        for (int i = 0; i < animationPoolSize; i++)
        {
            if (activeAnimations[i].isActive && activeAnimations[i].environment == env)
            {
                var anim = activeAnimations[i];
                anim.transform.localPosition = anim.startPosition;
                anim.transform.localRotation = anim.startRotation;
                anim.transform.localScale = anim.startScale;
                
                anim.environment.OnAnimationComplete();

                activeAnimations[i] = new AnimationState { isActive = false };
                freeIndices.Enqueue(i);
            }
        }
    }
}

// --- FILE: Scripts/Utils/EnvironmentMigrationTool.cs ---
﻿

// --- FILE: Scripts/Utils/RegisterAsWwiseListener.cs ---
﻿using UnityEngine;

// Assurez-vous que ce script est sur un GameObject qui a aussi une Caméra et un AkAudioListener
[RequireComponent(typeof(Camera), typeof(AkAudioListener))]
public class RegisterAsWwiseListener : MonoBehaviour
{
   
}

